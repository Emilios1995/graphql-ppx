// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Apollo argNamedQuery.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {argNamedQuery: int};
    type t_variables = {query: int};
  };
  let query = \\"query ($query: Int!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\";
  type t = {argNamedQuery: int};
  type t_variables = {query: int};
  let parse: Raw.t => t =
    (value) => (
      {
        argNamedQuery: {
          let value = (value: Raw.t).argNamedQuery;
          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let argNamedQuery = {
          let value = (value: t).argNamedQuery;
          value;
        };
        {argNamedQuery: argNamedQuery};
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {query: (a => a)((inp: t_variables).query)};
  let makeVariables = (~query, ()) =>
    serializeVariables({query: query}: t_variables);
  module Z__INTERNAL = {
    type nonrec _graphql_query_82;
    /**Variable **$query** has the following graphql type:

\`\`\`
Int!
\`\`\`*/
    let _graphql_query_82: _graphql_query_82 = Obj.magic(0);
    type nonrec _graphql_query_75;
    /**Argument **query** on field **argNamedQuery** has the following graphql type:

\`\`\`
Int!
\`\`\`*/
    let _graphql_query_75: _graphql_query_75 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo comment.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {nonrecursiveInput: string};
    type t_variables = {arg: t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      nonNullableField: string,
      nullableArray: Js.Nullable.t(array(Js.Nullable.t(string))),
      field: Js.Nullable.t(string),
      enum: Js.Nullable.t(string),
      embeddedInput:
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
      custom: Js.Nullable.t(Js.Json.t),
    }
    and t_variables_EmbeddedInput = {field: Js.Nullable.t(string)};
  };
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {nonrecursiveInput: string};
  type t_variables = {arg: t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    nonNullableField: string,
    nullableArray: option(array(option(string))),
    field: option(string),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
    embeddedInput: option(array(option(t_variables_EmbeddedInput))),
    custom: option(Js.Json.t),
  }
  and t_variables_EmbeddedInput = {field: option(string)};
  let parse: Raw.t => t =
    (value) => (
      {
        nonrecursiveInput: {
          let value = (value: Raw.t).nonrecursiveInput;
          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let nonrecursiveInput = {
          let value = (value: t).nonrecursiveInput;
          value;
        };
        {nonrecursiveInput: nonrecursiveInput};
      }: Raw.t
    );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (a => serializeInputObjectNonrecursiveInput(a))(
          (inp: t_variables).arg,
        ),
    }
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {
      nonNullableField:
        (a => a)((inp: t_variables_NonrecursiveInput).nonNullableField),
      nullableArray:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).nullableArray,
        ),
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).field,
        ),
      enum:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).enum,
        ),
      embeddedInput:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).embeddedInput,
        ),
      custom:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).custom,
        ),
    }
  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_EmbeddedInput).field,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables)
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        ~custom=?,
        (),
      )
      : t_variables_NonrecursiveInput => {
    nonNullableField,
    nullableArray,
    field,
    enum,
    embeddedInput,
    custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {
    field: field,
  };
  module Z__INTERNAL = {
    type nonrec _graphql_arg_100;
    /**Variable **$arg** has the following graphql type:

\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}!
\`\`\`*/
    let _graphql_arg_100: _graphql_arg_100 = Obj.magic(0);
    type nonrec _graphql_arg_95;
    /**Argument **arg** on field **nonrecursiveInput** has the following graphql type:

\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}!
\`\`\`*/
    let _graphql_arg_95: _graphql_arg_95 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_NonrecursiveInput_49;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_49: _graphql_NonrecursiveInput_49 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo customDecoder.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module StringOfInt = {
  let parse = string_of_int;
  let serialize = int_of_string;
  type t = string;
};
module IntOfString = {
  let parse = int_of_string;
  let serialize = string_of_int;
  type t = int;
};
module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      __typename: string,
      string,
      int,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\n__typename  \\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {
    __typename: string,
    string: IntOfString.t,
    int: StringOfInt.t,
  };
  type t = {variousScalars: t_variousScalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {
              __typename: {
                let value = (value: Raw.t_variousScalars).__typename;
                value;
              },
              string: {
                let value = (value: Raw.t_variousScalars).string;
                IntOfString.parse(value);
              },
              int: {
                let value = (value: Raw.t_variousScalars).int;
                StringOfInt.parse(value);
              },
            }: t_variousScalars
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let int = {
                let value = (value: t_variousScalars).int;
                StringOfInt.serialize(value);
              }
              and string = {
                let value = (value: t_variousScalars).string;
                IntOfString.serialize(value);
              }
              and __typename = {
                let value = (value: t_variousScalars).__typename;
                value;
              };
              {__typename, string, int};
            }: Raw.t_variousScalars
          );
        };
        {variousScalars: variousScalars};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo customScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_customScalarField = {
      __typename: string,
      nullable: Js.Nullable.t(Js.Json.t),
      nonNullable: Js.Json.t,
    };
    type t = {customScalarField: t_customScalarField};
    type t_variables = {
      opt: Js.Nullable.t(Js.Json.t),
      req: Js.Json.t,
    };
  };
  let query = \\"query ($opt: CustomScalar, $req: CustomScalar!)  {\\\\ncustomScalarField(argOptional: $opt, argRequired: $req)  {\\\\n__typename  \\\\nnullable  \\\\nnonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_customScalarField = {
    __typename: string,
    nullable: option(Js.Json.t),
    nonNullable: Js.Json.t,
  };
  type t = {customScalarField: t_customScalarField};
  type t_variables = {
    opt: option(Js.Json.t),
    req: Js.Json.t,
  };
  let parse: Raw.t => t =
    (value) => (
      {
        customScalarField: {
          let value = (value: Raw.t).customScalarField;
          (
            {
              __typename: {
                let value = (value: Raw.t_customScalarField).__typename;
                value;
              },
              nullable: {
                let value = (value: Raw.t_customScalarField).nullable;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              nonNullable: {
                let value = (value: Raw.t_customScalarField).nonNullable;
                value;
              },
            }: t_customScalarField
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let customScalarField = {
          let value = (value: t).customScalarField;
          (
            {
              let nonNullable = {
                let value = (value: t_customScalarField).nonNullable;
                value;
              }
              and nullable = {
                let value = (value: t_customScalarField).nullable;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_customScalarField).__typename;
                value;
              };
              {__typename, nullable, nonNullable};
            }: Raw.t_customScalarField
          );
        };
        {customScalarField: customScalarField};
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      opt:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).opt,
        ),
      req: (a => a)((inp: t_variables).req),
    };
  let makeVariables = (~opt=?, ~req, ()) =>
    serializeVariables({opt, req}: t_variables);
  module Z__INTERNAL = {
    type nonrec _graphql_opt_119;
    /**Variable **$opt** has the following graphql type:

\`\`\`
CustomScalar
\`\`\`*/
    let _graphql_opt_119: _graphql_opt_119 = Obj.magic(0);
    type nonrec _graphql_argOptional_106;
    /**Argument **argOptional** on field **customScalarField** has the following graphql type:

\`\`\`
CustomScalar
\`\`\`*/
    let _graphql_argOptional_106: _graphql_argOptional_106 = Obj.magic(0);
    type nonrec _graphql_req_138;
    /**Variable **$req** has the following graphql type:

\`\`\`
CustomScalar!
\`\`\`*/
    let _graphql_req_138: _graphql_req_138 = Obj.magic(0);
    type nonrec _graphql_argRequired_125;
    /**Argument **argRequired** on field **customScalarField** has the following graphql type:

\`\`\`
CustomScalar!
\`\`\`*/
    let _graphql_argRequired_125: _graphql_argRequired_125 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo customTypes.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Color = {
  type t =
    | Red
    | Green
    | Blue;
  let parse = json =>
    switch (json |> Js.Json.decodeString) {
    | Some(\\"green\\") => Green
    | Some(\\"blue\\") => Blue
    | Some(\\"red\\")
    | Some(_)
    | None => Red
    };
  let serialize = color =>
    (
      switch (color) {
      | Red => \\"red\\"
      | Green => \\"green\\"
      | Blue => \\"blue\\"
      }
    )
    |> Js.Json.string;
};
module DateTime = {
  type t = Js.Date.t;
  let parse = json =>
    switch (json |> Js.Json.decodeString) {
    | Some(str) => str |> Js.Date.fromString
    | None => Js.Date.make()
    };
  let serialize = date => date |> Js.Date.toISOString |> Js.Json.string;
};
module MyQuery = {
  module Raw = {
    type t_customFields = {
      __typename: string,
      currentTime: Js.Json.t,
      favoriteColor: Js.Json.t,
      futureTime: Js.Nullable.t(Js.Json.t),
      nullableColor: Js.Nullable.t(Js.Json.t),
    };
    type t = {customFields: t_customFields};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ncustomFields  {\\\\n__typename  \\\\ncurrentTime  \\\\nfavoriteColor  \\\\nfutureTime  \\\\nnullableColor  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_customFields = {
    __typename: string,
    currentTime: DateTime.t,
    favoriteColor: Color.t,
    futureTime: option(DateTime.t),
    nullableColor: option(Color.t),
  };
  type t = {customFields: t_customFields};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        customFields: {
          let value = (value: Raw.t).customFields;
          (
            {
              __typename: {
                let value = (value: Raw.t_customFields).__typename;
                value;
              },
              currentTime: {
                let value = (value: Raw.t_customFields).currentTime;
                DateTime.parse(value);
              },
              favoriteColor: {
                let value = (value: Raw.t_customFields).favoriteColor;
                Color.parse(value);
              },
              futureTime: {
                let value = (value: Raw.t_customFields).futureTime;
                switch (Js.toOption(value)) {
                | Some(value) => Some(DateTime.parse(value))
                | None => None
                };
              },
              nullableColor: {
                let value = (value: Raw.t_customFields).nullableColor;
                switch (Js.toOption(value)) {
                | Some(value) => Some(Color.parse(value))
                | None => None
                };
              },
            }: t_customFields
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let customFields = {
          let value = (value: t).customFields;
          (
            {
              let nullableColor = {
                let value = (value: t_customFields).nullableColor;
                switch (value) {
                | Some(value) => Js.Nullable.return(Color.serialize(value))
                | None => Js.Nullable.null
                };
              }
              and futureTime = {
                let value = (value: t_customFields).futureTime;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(DateTime.serialize(value))
                | None => Js.Nullable.null
                };
              }
              and favoriteColor = {
                let value = (value: t_customFields).favoriteColor;
                Color.serialize(value);
              }
              and currentTime = {
                let value = (value: t_customFields).currentTime;
                DateTime.serialize(value);
              }
              and __typename = {
                let value = (value: t_customFields).__typename;
                value;
              };
              {
                __typename,
                currentTime,
                favoriteColor,
                futureTime,
                nullableColor,
              };
            }: Raw.t_customFields
          );
        };
        {customFields: customFields};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo defaultObjectValueOnScalar.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {defaultObjectValueOnScalar: string};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndefaultObjectValueOnScalar(filter: {some: {json: \\\\\\"value\\\\\\"}}, arg: {field: \\\\\\"otherValue\\\\\\"})  \\\\n}\\\\n\\";
  type t = {defaultObjectValueOnScalar: string};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        defaultObjectValueOnScalar: {
          let value = (value: Raw.t).defaultObjectValueOnScalar;
          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let defaultObjectValueOnScalar = {
          let value = (value: t).defaultObjectValueOnScalar;
          value;
        };
        {defaultObjectValueOnScalar: defaultObjectValueOnScalar};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type nonrec _graphql_filter_92;
    /**Argument **filter** on field **defaultObjectValueOnScalar** has the following graphql type:

\`\`\`
JsonScalar!
\`\`\`*/
    let _graphql_filter_92: _graphql_filter_92 = Obj.magic(0);
    type nonrec _graphql_arg_140;
    /**Argument **arg** on field **defaultObjectValueOnScalar** has the following graphql type:

\`\`\`
EmbeddedInput {
  field: String
}!
\`\`\`*/
    let _graphql_arg_140: _graphql_arg_140 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo enumInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {enumInput: string};
    type t_variables = {arg: string};
  };
  let query = \\"query ($arg: SampleField!)  {\\\\nenumInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {enumInput: string};
  type t_variables = {arg: [ | \`FIRST | \`SECOND | \`THIRD]};
  let parse: Raw.t => t =
    (value) => (
      {
        enumInput: {
          let value = (value: Raw.t).enumInput;
          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let enumInput = {
          let value = (value: t).enumInput;
          value;
        };
        {enumInput: enumInput};
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (
          a =>
            switch (a) {
            | \`FIRST => \\"FIRST\\"
            | \`SECOND => \\"SECOND\\"
            | \`THIRD => \\"THIRD\\"
            }
        )(
          (inp: t_variables).arg,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables);
  module Z__INTERNAL = {
    type nonrec _graphql_arg_82;
    /**Variable **$arg** has the following graphql type:

\`\`\`
SampleField {
  FIRST
  SECOND
  THIRD
}!
\`\`\`*/
    let _graphql_arg_82: _graphql_arg_82 = Obj.magic(0);
    type nonrec _graphql_arg_77;
    /**Argument **arg** on field **enumInput** has the following graphql type:

\`\`\`
SampleField {
  FIRST
  SECOND
  THIRD
}!
\`\`\`*/
    let _graphql_arg_77: _graphql_arg_77 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_SampleField_47;
    /**\`\`\`
SampleField {
  FIRST
  SECOND
  THIRD
}
\`\`\`*/
    let _graphql_SampleField_47: _graphql_SampleField_47 = Obj.magic(0);
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo explicit_object_record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module RecordsQuery = {
  module Raw = {
    type t_lists = {
      __typename: string,
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
    type t = {lists: t_lists};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nlists  {\\\\n__typename  \\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_lists = {
    __typename: string,
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  type t = {lists: t_lists};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        lists: {
          let value = (value: Raw.t).lists;
          (
            {
              __typename: {
                let value = (value: Raw.t_lists).__typename;
                value;
              },
              nullableOfNullable: {
                let value = (value: Raw.t_lists).nullableOfNullable;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              },
              nullableOfNonNullable: {
                let value = (value: Raw.t_lists).nullableOfNonNullable;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value |> Js.Array.map(value => value))
                | None => None
                };
              },
              nonNullableOfNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNullable;
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   );
              },
              nonNullableOfNonNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNonNullable;
                value |> Js.Array.map(value => value);
              },
            }: t_lists
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let lists = {
          let value = (value: t).lists;
          (
            {
              let nonNullableOfNonNullable = {
                let value = (value: t_lists).nonNullableOfNonNullable;
                value |> Js.Array.map(value => value);
              }
              and nonNullableOfNullable = {
                let value = (value: t_lists).nonNullableOfNullable;
                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   );
              }
              and nullableOfNonNullable = {
                let value = (value: t_lists).nullableOfNonNullable;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(value |> Js.Array.map(value => value))
                | None => Js.Nullable.null
                };
              }
              and nullableOfNullable = {
                let value = (value: t_lists).nullableOfNullable;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map(value =>
                         switch (value) {
                         | Some(value) => Js.Nullable.return(value)
                         | None => Js.Nullable.null
                         }
                       ),
                  )
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_lists).__typename;
                value;
              };
              {
                __typename,
                nullableOfNullable,
                nullableOfNonNullable,
                nonNullableOfNullable,
                nonNullableOfNonNullable,
              };
            }: Raw.t_lists
          );
        };
        {lists: lists};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module RecordsQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ObjectsQuery = {
  module Raw = {
    type t_lists = {
      .
      \\"__typename\\": string,
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
    type t = {. \\"lists\\": t_lists};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nlists  {\\\\n__typename  \\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_lists = {
    .
    \\"__typename\\": string,
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  type t = {. \\"lists\\": t_lists};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;
          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;
          value
          |> Js.Array.map(value =>
               switch (Js.toOption(value)) {
               | Some(value) => Some(value)
               | None => None
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value |> Js.Array.map(value => value))
          | None => None
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 ),
            )
          | None => None
          };
        }
        and __typename = {
          let value = value##__typename;
          value;
        };
        {
          \\"__typename\\": __typename,
          \\"nullableOfNullable\\": nullableOfNullable,
          \\"nullableOfNonNullable\\": nullableOfNonNullable,
          \\"nonNullableOfNullable\\": nonNullableOfNullable,
          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {\\"lists\\": lists};
    };
  let serialize: t => Raw.t =
    value => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;
          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;
          value
          |> Js.Array.map(value =>
               switch (value) {
               | Some(value) => Js.Nullable.return(value)
               | None => Js.Nullable.null
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(value |> Js.Array.map(value => value))
          | None => Js.Nullable.null
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 ),
            )
          | None => Js.Nullable.null
          };
        }
        and __typename = {
          let value = value##__typename;
          value;
        };
        {
          \\"__typename\\": __typename,
          \\"nullableOfNullable\\": nullableOfNullable,
          \\"nullableOfNonNullable\\": nullableOfNonNullable,
          \\"nonNullableOfNullable\\": nonNullableOfNullable,
          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {\\"lists\\": lists};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ObjectsQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo extensions.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module type GraphQLQuery = {
  module Raw: {
    type t;
    type t_variables;
  };
  type t;
  type t_variables;

  let query: string;
  let parse: Raw.t => t;
  let serialize: t => Raw.t;
};

module ExtendQuery = (M: GraphQLQuery) => {
  let use = () => ();
};
module Bla' = {
  module Raw = {
    type t_lists = {
      __typename: string,
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
    type t = {lists: t_lists};
    type t_variables = Js.Json.t;
  };
  let query = \\"query Bla  {\\\\nlists  {\\\\n__typename  \\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_lists = {
    __typename: string,
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  type t = {lists: t_lists};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        lists: {
          let value = (value: Raw.t).lists;
          (
            {
              __typename: {
                let value = (value: Raw.t_lists).__typename;
                value;
              },
              nullableOfNullable: {
                let value = (value: Raw.t_lists).nullableOfNullable;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              },
              nullableOfNonNullable: {
                let value = (value: Raw.t_lists).nullableOfNonNullable;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value |> Js.Array.map(value => value))
                | None => None
                };
              },
              nonNullableOfNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNullable;
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   );
              },
              nonNullableOfNonNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNonNullable;
                value |> Js.Array.map(value => value);
              },
            }: t_lists
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let lists = {
          let value = (value: t).lists;
          (
            {
              let nonNullableOfNonNullable = {
                let value = (value: t_lists).nonNullableOfNonNullable;
                value |> Js.Array.map(value => value);
              }
              and nonNullableOfNullable = {
                let value = (value: t_lists).nonNullableOfNullable;
                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   );
              }
              and nullableOfNonNullable = {
                let value = (value: t_lists).nullableOfNonNullable;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(value |> Js.Array.map(value => value))
                | None => Js.Nullable.null
                };
              }
              and nullableOfNullable = {
                let value = (value: t_lists).nullableOfNullable;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map(value =>
                         switch (value) {
                         | Some(value) => Js.Nullable.return(value)
                         | None => Js.Nullable.null
                         }
                       ),
                  )
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_lists).__typename;
                value;
              };
              {
                __typename,
                nullableOfNullable,
                nullableOfNonNullable,
                nonNullableOfNullable,
                nonNullableOfNonNullable,
              };
            }: Raw.t_lists
          );
        };
        {lists: lists};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module Bla = {
  include Bla';
  include ExtendQuery(Bla');
};
"
`;

exports[`Apollo fragmentDefinition.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Fragments = {
  module ListFragment = {
    let query = \\"fragment ListFragment on Lists   {\\\\n__typename  \\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        __typename: string,
        nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
        nullableOfNonNullable: Js.Nullable.t(array(string)),
      };
      type nonrec t_Lists = t;
    };
    type t = {
      __typename: string,
      nullableOfNullable: option(array(option(string))),
      nullableOfNonNullable: option(array(string)),
    };
    type nonrec t_Lists = t;
    let parse = (value: Raw.t): t => {
      __typename: {
        let value = (value: Raw.t).__typename;
        value;
      },
      nullableOfNullable: {
        let value = (value: Raw.t).nullableOfNullable;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      },
      nullableOfNonNullable: {
        let value = (value: Raw.t).nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      },
    };
    let serialize: t => Raw.t =
      (value) => (
        {
          let nullableOfNonNullable = {
            let value = (value: t).nullableOfNonNullable;
            switch (value) {
            | Some(value) =>
              Js.Nullable.return(value |> Js.Array.map(value => value))
            | None => Js.Nullable.null
            };
          }
          and nullableOfNullable = {
            let value = (value: t).nullableOfNullable;
            switch (value) {
            | Some(value) =>
              Js.Nullable.return(
                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   ),
              )
            | None => Js.Nullable.null
            };
          }
          and __typename = {
            let value = (value: t).__typename;
            value;
          };
          {__typename, nullableOfNullable, nullableOfNonNullable};
        }: Raw.t
      );
    let name = \\"ListFragment\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql;
      /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}
\`\`\`*/
      let graphql: graphql = Obj.magic(0);
      type nonrec graphql_module;
      /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module Fragments {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  module Another = {
    let query = \\"fragment Another on Lists   {\\\\n__typename  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        __typename: string,
        nullableOfNonNullable: Js.Nullable.t(array(string)),
      };
      type nonrec t_Lists = t;
    };
    type t = {
      __typename: string,
      nullableOfNonNullable: option(array(string)),
    };
    type nonrec t_Lists = t;
    let parse = (value: Raw.t): t => {
      __typename: {
        let value = (value: Raw.t).__typename;
        value;
      },
      nullableOfNonNullable: {
        let value = (value: Raw.t).nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      },
    };
    let serialize: t => Raw.t =
      (value) => (
        {
          let nullableOfNonNullable = {
            let value = (value: t).nullableOfNonNullable;
            switch (value) {
            | Some(value) =>
              Js.Nullable.return(value |> Js.Array.map(value => value))
            | None => Js.Nullable.null
            };
          }
          and __typename = {
            let value = (value: t).__typename;
            value;
          };
          {__typename, nullableOfNonNullable};
        }: Raw.t
      );
    let name = \\"Another\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql;
      /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}
\`\`\`*/
      let graphql: graphql = Obj.magic(0);
      type nonrec graphql_module;
      /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module Fragments {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
};
module MyQuery = {
  module Raw = {
    type t_l2;
    type t_l3;
    type t_l4;
    type t = {
      l1: Fragments.ListFragment.Raw.t,
      l2: t_l2,
      l3: t_l3,
      l4: t_l4,
    };
    type t_variables = Js.Json.t;
  };
  let query =
    (
      (
        (
          (
            (
              (
                (
                  (
                    (
                      (
                        (
                          (
                            \\"query   {\\\\nl1: lists  {\\\\n...\\"
                            ++ Fragments.ListFragment.name
                          )
                          ++ \\"   \\\\n}\\\\n\\\\nl2: lists  {\\\\n__typename  \\\\n...\\"
                        )
                        ++ Fragments.ListFragment.name
                      )
                      ++ \\"   \\\\n...\\"
                    )
                    ++ Fragments.ListFragment.name
                  )
                  ++ \\"   \\\\n}\\\\n\\\\nl3: lists  {\\\\n__typename  \\\\nnullableOfNullable  \\\\n...\\"
                )
                ++ Fragments.ListFragment.name
              )
              ++ \\"   \\\\n...\\"
            )
            ++ Fragments.ListFragment.name
          )
          ++ \\"   \\\\n}\\\\n\\\\nl4: lists  {\\\\n__typename  \\\\nnullableOfNullable  \\\\n...\\"
        )
        ++ Fragments.ListFragment.name
      )
      ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
    )
    ++ Fragments.ListFragment.query;
  type t_l2 = {
    __typename: string,
    frag1: Fragments.ListFragment.t_Lists,
    frag2: Fragments.ListFragment.t_Lists,
  };
  type t_l3 = {
    __typename: string,
    nullableOfNullable: option(array(option(string))),
    frag1: Fragments.ListFragment.t_Lists,
    frag2: Fragments.ListFragment.t_Lists,
  };
  type t_l4 = {
    __typename: string,
    nullableOfNullable: option(array(option(string))),
    listFragment: Fragments.ListFragment.t_Lists,
  };
  type t = {
    l1: Fragments.ListFragment.t,
    l2: t_l2,
    l3: t_l3,
    l4: t_l4,
  };
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        l1: {
          let value = (value: Raw.t).l1;
          Fragments.ListFragment.parse(value);
        },
        l2: {
          let value = (value: Raw.t).l2;
          (
            {
              __typename: {
                let value =
                  Obj.magic(
                    Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"),
                  );
                value;
              },
              frag1: {
                let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
                Fragments.ListFragment.parse(value);
              },
              frag2: {
                let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
                Fragments.ListFragment.parse(value);
              },
            }: t_l2
          );
        },
        l3: {
          let value = (value: Raw.t).l3;
          (
            {
              __typename: {
                let value =
                  Obj.magic(
                    Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"),
                  );
                value;
              },
              nullableOfNullable: {
                let value =
                  Obj.magic(
                    Js.Dict.unsafeGet(
                      Obj.magic(value),
                      \\"nullableOfNullable\\",
                    ),
                  );
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              },
              frag1: {
                let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
                Fragments.ListFragment.parse(value);
              },
              frag2: {
                let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
                Fragments.ListFragment.parse(value);
              },
            }: t_l3
          );
        },
        l4: {
          let value = (value: Raw.t).l4;
          (
            {
              __typename: {
                let value =
                  Obj.magic(
                    Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"),
                  );
                value;
              },
              nullableOfNullable: {
                let value =
                  Obj.magic(
                    Js.Dict.unsafeGet(
                      Obj.magic(value),
                      \\"nullableOfNullable\\",
                    ),
                  );
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              },
              listFragment: {
                let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
                Fragments.ListFragment.parse(value);
              },
            }: t_l4
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let l4 = {
          let value = (value: t).l4;
          (
            Obj.magic(
              Js.Array.reduce(
                GraphQL_PPX.deepMerge,
                Obj.magic(
                  {
                    let nullableOfNullable = {
                      let value = (value: t_l4).nullableOfNullable;
                      switch (value) {
                      | Some(value) =>
                        Js.Nullable.return(
                          value
                          |> Js.Array.map(value =>
                               switch (value) {
                               | Some(value) => Js.Nullable.return(value)
                               | None => Js.Nullable.null
                               }
                             ),
                        )
                      | None => Js.Nullable.null
                      };
                    }
                    and __typename = {
                      let value = (value: t_l4).__typename;
                      value;
                    };
                    {
                      \\"__typename\\": __typename,
                      \\"nullableOfNullable\\": nullableOfNullable,
                    };
                  },
                ): Js.Json.t,
                [|
                  (
                    Obj.magic(
                      Fragments.ListFragment.serialize(
                        (value: t_l4).listFragment,
                      ),
                    ): Js.Json.t
                  ),
                |],
              ),
            ): Raw.t_l4
          );
        }
        and l3 = {
          let value = (value: t).l3;
          (
            Obj.magic(
              Js.Array.reduce(
                GraphQL_PPX.deepMerge,
                Obj.magic(
                  {
                    let nullableOfNullable = {
                      let value = (value: t_l3).nullableOfNullable;
                      switch (value) {
                      | Some(value) =>
                        Js.Nullable.return(
                          value
                          |> Js.Array.map(value =>
                               switch (value) {
                               | Some(value) => Js.Nullable.return(value)
                               | None => Js.Nullable.null
                               }
                             ),
                        )
                      | None => Js.Nullable.null
                      };
                    }
                    and __typename = {
                      let value = (value: t_l3).__typename;
                      value;
                    };
                    {
                      \\"__typename\\": __typename,
                      \\"nullableOfNullable\\": nullableOfNullable,
                    };
                  },
                ): Js.Json.t,
                [|
                  (
                    Obj.magic(
                      Fragments.ListFragment.serialize((value: t_l3).frag1),
                    ): Js.Json.t
                  ),
                  (
                    Obj.magic(
                      Fragments.ListFragment.serialize((value: t_l3).frag2),
                    ): Js.Json.t
                  ),
                |],
              ),
            ): Raw.t_l3
          );
        }
        and l2 = {
          let value = (value: t).l2;
          (
            Obj.magic(
              Js.Array.reduce(
                GraphQL_PPX.deepMerge,
                Obj.magic(
                  {
                    let __typename = {
                      let value = (value: t_l2).__typename;
                      value;
                    };
                    {\\"__typename\\": __typename};
                  },
                ): Js.Json.t,
                [|
                  (
                    Obj.magic(
                      Fragments.ListFragment.serialize((value: t_l2).frag1),
                    ): Js.Json.t
                  ),
                  (
                    Obj.magic(
                      Fragments.ListFragment.serialize((value: t_l2).frag2),
                    ): Js.Json.t
                  ),
                |],
              ),
            ): Raw.t_l2
          );
        }
        and l1 = {
          let value = (value: t).l1;
          Fragments.ListFragment.serialize(value);
        };
        {l1, l2, l3, l4};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery2 = {
  module Raw = {
    type t = {lists: Fragments.ListFragment.Raw.t};
    type t_variables = Js.Json.t;
  };
  let query =
    (
      (\\"query   {\\\\nlists  {\\\\n...\\" ++ Fragments.ListFragment.name)
      ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
    )
    ++ Fragments.ListFragment.query;
  type t = {lists: Fragments.ListFragment.t};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        lists: {
          let value = (value: Raw.t).lists;
          Fragments.ListFragment.parse(value);
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let lists = {
          let value = (value: t).lists;
          Fragments.ListFragment.serialize(value);
        };
        {lists: lists};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery2 {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo interface.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
"
`;

exports[`Apollo lists.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_lists = {
      __typename: string,
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
    type t = {lists: t_lists};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nlists  {\\\\n__typename  \\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_lists = {
    __typename: string,
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  type t = {lists: t_lists};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        lists: {
          let value = (value: Raw.t).lists;
          (
            {
              __typename: {
                let value = (value: Raw.t_lists).__typename;
                value;
              },
              nullableOfNullable: {
                let value = (value: Raw.t_lists).nullableOfNullable;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              },
              nullableOfNonNullable: {
                let value = (value: Raw.t_lists).nullableOfNonNullable;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value |> Js.Array.map(value => value))
                | None => None
                };
              },
              nonNullableOfNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNullable;
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   );
              },
              nonNullableOfNonNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNonNullable;
                value |> Js.Array.map(value => value);
              },
            }: t_lists
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let lists = {
          let value = (value: t).lists;
          (
            {
              let nonNullableOfNonNullable = {
                let value = (value: t_lists).nonNullableOfNonNullable;
                value |> Js.Array.map(value => value);
              }
              and nonNullableOfNullable = {
                let value = (value: t_lists).nonNullableOfNullable;
                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   );
              }
              and nullableOfNonNullable = {
                let value = (value: t_lists).nullableOfNonNullable;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(value |> Js.Array.map(value => value))
                | None => Js.Nullable.null
                };
              }
              and nullableOfNullable = {
                let value = (value: t_lists).nullableOfNullable;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map(value =>
                         switch (value) {
                         | Some(value) => Js.Nullable.return(value)
                         | None => Js.Nullable.null
                         }
                       ),
                  )
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_lists).__typename;
                value;
              };
              {
                __typename,
                nullableOfNullable,
                nullableOfNonNullable,
                nonNullableOfNullable,
                nonNullableOfNonNullable,
              };
            }: Raw.t_lists
          );
        };
        {lists: lists};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo listsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {listsInput: string};
    type t_variables = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
  };
  let query = \\"query ($nullableOfNullable: [String], $nullableOfNonNullable: [String!], $nonNullableOfNullable: [String]!, $nonNullableOfNonNullable: [String!]!)  {\\\\nlistsInput(arg: {nullableOfNullable: $nullableOfNullable, nullableOfNonNullable: $nullableOfNonNullable, nonNullableOfNullable: $nonNullableOfNullable, nonNullableOfNonNullable: $nonNullableOfNonNullable})  \\\\n}\\\\n\\";
  type t = {listsInput: string};
  type t_variables = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  let parse: Raw.t => t =
    (value) => (
      {
        listsInput: {
          let value = (value: Raw.t).listsInput;
          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let listsInput = {
          let value = (value: t).listsInput;
          value;
        };
        {listsInput: listsInput};
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      nullableOfNullable:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables).nullableOfNullable,
        ),
      nullableOfNonNullable:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return((a => Array.map(b => (a => a)(b), a))(b))
            }
        )(
          (inp: t_variables).nullableOfNonNullable,
        ),
      nonNullableOfNullable:
        (
          a =>
            Array.map(
              b =>
                (
                  a =>
                    switch (a) {
                    | None => Js.Nullable.undefined
                    | Some(b) => Js.Nullable.return((a => a)(b))
                    }
                )(
                  b,
                ),
              a,
            )
        )(
          (inp: t_variables).nonNullableOfNullable,
        ),
      nonNullableOfNonNullable:
        (a => Array.map(b => (a => a)(b), a))(
          (inp: t_variables).nonNullableOfNonNullable,
        ),
    };
  let makeVariables =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      ) =>
    serializeVariables(
      {
        nullableOfNullable,
        nullableOfNonNullable,
        nonNullableOfNullable,
        nonNullableOfNonNullable,
      }: t_variables,
    );
  module Z__INTERNAL = {
    type nonrec _graphql_arg_219;
    /**Argument **arg** on field **listsInput** has the following graphql type:

\`\`\`
ListsInput {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}!
\`\`\`*/
    let _graphql_arg_219: _graphql_arg_219 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo listsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {listsInput: string};
    type t_variables = {arg: t_variables_ListsInput}
    and t_variables_ListsInput = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
  };
  let query = \\"query ($arg: ListsInput!)  {\\\\nlistsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {listsInput: string};
  type t_variables = {arg: t_variables_ListsInput}
  and t_variables_ListsInput = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  let parse: Raw.t => t =
    (value) => (
      {
        listsInput: {
          let value = (value: Raw.t).listsInput;
          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let listsInput = {
          let value = (value: t).listsInput;
          value;
        };
        {listsInput: listsInput};
      }: Raw.t
    );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg: (a => serializeInputObjectListsInput(a))((inp: t_variables).arg),
    }
  and serializeInputObjectListsInput:
    t_variables_ListsInput => Raw.t_variables_ListsInput =
    inp => {
      nullableOfNullable:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_ListsInput).nullableOfNullable,
        ),
      nullableOfNonNullable:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return((a => Array.map(b => (a => a)(b), a))(b))
            }
        )(
          (inp: t_variables_ListsInput).nullableOfNonNullable,
        ),
      nonNullableOfNullable:
        (
          a =>
            Array.map(
              b =>
                (
                  a =>
                    switch (a) {
                    | None => Js.Nullable.undefined
                    | Some(b) => Js.Nullable.return((a => a)(b))
                    }
                )(
                  b,
                ),
              a,
            )
        )(
          (inp: t_variables_ListsInput).nonNullableOfNullable,
        ),
      nonNullableOfNonNullable:
        (a => Array.map(b => (a => a)(b), a))(
          (inp: t_variables_ListsInput).nonNullableOfNonNullable,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables)
  and makeInputObjectListsInput =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      )
      : t_variables_ListsInput => {
    nullableOfNullable,
    nullableOfNonNullable,
    nonNullableOfNullable,
    nonNullableOfNonNullable,
  };
  module Z__INTERNAL = {
    type nonrec _graphql_arg_82;
    /**Variable **$arg** has the following graphql type:

\`\`\`
ListsInput {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}!
\`\`\`*/
    let _graphql_arg_82: _graphql_arg_82 = Obj.magic(0);
    type nonrec _graphql_arg_77;
    /**Argument **arg** on field **listsInput** has the following graphql type:

\`\`\`
ListsInput {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}!
\`\`\`*/
    let _graphql_arg_77: _graphql_arg_77 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_ListsInput_47;
    /**\`\`\`
ListsInput {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}
\`\`\`*/
    let _graphql_ListsInput_47: _graphql_ListsInput_47 = Obj.magic(0);
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo mutation.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_mutationWithError_value = {
      __typename: string,
      stringField: string,
    };
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      __typename: string,
      field: t_mutationWithError_errors_field,
      message: string,
    };
    type t_mutationWithError = {
      __typename: string,
      value: Js.Nullable.t(t_mutationWithError_value),
      errors: Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {mutationWithError: t_mutationWithError};
    type t_variables = Js.Json.t;
  };
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\n__typename  \\\\nvalue  {\\\\n__typename  \\\\nstringField  \\\\n}\\\\n\\\\nerrors  {\\\\n__typename  \\\\nfield  \\\\nmessage  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_mutationWithError_value = {
    __typename: string,
    stringField: string,
  };
  type t_mutationWithError_errors_field = [
    | \`FutureAddedValue(string)
    | \`FIRST
    | \`SECOND
    | \`THIRD
  ];
  type t_mutationWithError_errors = {
    __typename: string,
    field: t_mutationWithError_errors_field,
    message: string,
  };
  type t_mutationWithError = {
    __typename: string,
    value: option(t_mutationWithError_value),
    errors: option(array(t_mutationWithError_errors)),
  };
  type t = {mutationWithError: t_mutationWithError};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        mutationWithError: {
          let value = (value: Raw.t).mutationWithError;
          (
            {
              __typename: {
                let value = (value: Raw.t_mutationWithError).__typename;
                value;
              },
              value: {
                let value = (value: Raw.t_mutationWithError).value;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {
                      __typename: {
                        let value =
                          (value: Raw.t_mutationWithError_value).__typename;
                        value;
                      },
                      stringField: {
                        let value =
                          (value: Raw.t_mutationWithError_value).stringField;
                        value;
                      },
                    }: t_mutationWithError_value,
                  )
                | None => None
                };
              },
              errors: {
                let value = (value: Raw.t_mutationWithError).errors;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map((value) =>
                         (
                           {
                             __typename: {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).
                                   __typename;
                               value;
                             },
                             field: {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).field;
                               switch (Obj.magic(value: string)) {
                               | \\"FIRST\\" => \`FIRST
                               | \\"SECOND\\" => \`SECOND
                               | \\"THIRD\\" => \`THIRD
                               | other => \`FutureAddedValue(other)
                               };
                             },
                             message: {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).
                                   message;
                               value;
                             },
                           }: t_mutationWithError_errors
                         )
                       ),
                  )
                | None => None
                };
              },
            }: t_mutationWithError
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let mutationWithError = {
          let value = (value: t).mutationWithError;
          (
            {
              let errors = {
                let value = (value: t_mutationWithError).errors;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map((value) =>
                         (
                           {
                             let message = {
                               let value =
                                 (value: t_mutationWithError_errors).message;
                               value;
                             }
                             and field = {
                               let value =
                                 (value: t_mutationWithError_errors).field;
                               switch (value) {
                               | \`FIRST => \\"FIRST\\"
                               | \`SECOND => \\"SECOND\\"
                               | \`THIRD => \\"THIRD\\"
                               | \`FutureAddedValue(other) => other
                               };
                             }
                             and __typename = {
                               let value =
                                 (value: t_mutationWithError_errors).
                                   __typename;
                               value;
                             };
                             {__typename, field, message};
                           }: Raw.t_mutationWithError_errors
                         )
                       ),
                  )
                | None => Js.Nullable.null
                };
              }
              and value = {
                let value = (value: t_mutationWithError).value;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {
                      let stringField = {
                        let value =
                          (value: t_mutationWithError_value).stringField;
                        value;
                      }
                      and __typename = {
                        let value =
                          (value: t_mutationWithError_value).__typename;
                        value;
                      };
                      {__typename, stringField};
                    }: Raw.t_mutationWithError_value,
                  )
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_mutationWithError).__typename;
                value;
              };
              {__typename, value, errors};
            }: Raw.t_mutationWithError
          );
        };
        {mutationWithError: mutationWithError};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo mutationWithArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {optionalInputArgs: string};
    type t_variables = {required: string};
  };
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t = {optionalInputArgs: string};
  type t_variables = {required: string};
  let parse: Raw.t => t =
    (value) => (
      {
        optionalInputArgs: {
          let value = (value: Raw.t).optionalInputArgs;
          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let optionalInputArgs = {
          let value = (value: t).optionalInputArgs;
          value;
        };
        {optionalInputArgs: optionalInputArgs};
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {required: (a => a)((inp: t_variables).required)};
  let makeVariables = (~required, ()) =>
    serializeVariables({required: required}: t_variables);
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo mutationWithArgsAndNoRecords.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"optionalInputArgs\\": string};
    type t_variables = {. \\"required\\": string};
  };
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t = {. \\"optionalInputArgs\\": string};
  type t_variables = {. \\"required\\": string};
  let parse: Raw.t => t =
    value => {
      let optionalInputArgs = {
        let value = value##optionalInputArgs;
        value;
      };
      {\\"optionalInputArgs\\": optionalInputArgs};
    };
  let serialize: t => Raw.t =
    value => {
      let optionalInputArgs = {
        let value = value##optionalInputArgs;
        value;
      };
      {\\"optionalInputArgs\\": optionalInputArgs};
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"required\\": (a => a)(inp##required)};
  let makeVariables = (~required, ()) =>
    serializeVariables({\\"required\\": required}: t_variables);
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo nested.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type record = {
  f1: string,
  f2: string,
};
module MyQuery = {
  module Raw = {
    type t_first_inner_inner = {
      __typename: string,
      field: string,
    };
    type t_first_inner = {
      __typename: string,
      inner: Js.Nullable.t(t_first_inner_inner),
    };
    type t_first = {
      __typename: string,
      inner: Js.Nullable.t(t_first_inner),
    };
    type t_second_inner_inner = {
      __typename: string,
      f1: string,
      f2: string,
    };
    type t_second_inner = {
      __typename: string,
      inner: Js.Nullable.t(t_second_inner_inner),
    };
    type t_second = {
      __typename: string,
      inner: Js.Nullable.t(t_second_inner),
    };
    type t_let_inner_inner = {
      __typename: string,
      field: string,
    };
    type t_let_inner = {
      __typename: string,
      inner: Js.Nullable.t(t_let_inner_inner),
    };
    type t_let = {
      __typename: string,
      inner: Js.Nullable.t(t_let_inner),
    };
    type t = {
      first: t_first,
      second: t_second,
      let_: t_let,
    };
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nsecond: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nf1: field  \\\\nf2: field  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nlet: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_first_inner_inner = {
    __typename: string,
    field: string,
  };
  type t_first_inner = {
    __typename: string,
    inner: option(t_first_inner_inner),
  };
  type t_first = {
    __typename: string,
    inner: option(t_first_inner),
  };
  type t_second_inner_inner = {
    __typename: string,
    f1: string,
    f2: string,
  };
  type t_second_inner = {
    __typename: string,
    inner: option(t_second_inner_inner),
  };
  type t_second = {
    __typename: string,
    inner: option(t_second_inner),
  };
  type t_let_inner_inner = {
    __typename: string,
    field: string,
  };
  type t_let_inner = {
    __typename: string,
    inner: option(t_let_inner_inner),
  };
  type t_let = {
    __typename: string,
    inner: option(t_let_inner),
  };
  type t = {
    first: t_first,
    second: t_second,
    let_: t_let,
  };
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        first: {
          let value = (value: Raw.t).first;
          (
            {
              __typename: {
                let value = (value: Raw.t_first).__typename;
                value;
              },
              inner: {
                let value = (value: Raw.t_first).inner;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {
                      __typename: {
                        let value = (value: Raw.t_first_inner).__typename;
                        value;
                      },
                      inner: {
                        let value = (value: Raw.t_first_inner).inner;
                        switch (Js.toOption(value)) {
                        | Some(value) =>
                          Some(
                            {
                              __typename: {
                                let value =
                                  (value: Raw.t_first_inner_inner).__typename;
                                value;
                              },
                              field: {
                                let value =
                                  (value: Raw.t_first_inner_inner).field;
                                value;
                              },
                            }: t_first_inner_inner,
                          )
                        | None => None
                        };
                      },
                    }: t_first_inner,
                  )
                | None => None
                };
              },
            }: t_first
          );
        },
        second: {
          let value = (value: Raw.t).second;
          (
            {
              __typename: {
                let value = (value: Raw.t_second).__typename;
                value;
              },
              inner: {
                let value = (value: Raw.t_second).inner;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {
                      __typename: {
                        let value = (value: Raw.t_second_inner).__typename;
                        value;
                      },
                      inner: {
                        let value = (value: Raw.t_second_inner).inner;
                        switch (Js.toOption(value)) {
                        | Some(value) =>
                          Some(
                            {
                              __typename: {
                                let value =
                                  (value: Raw.t_second_inner_inner).__typename;
                                value;
                              },
                              f1: {
                                let value =
                                  (value: Raw.t_second_inner_inner).f1;
                                value;
                              },
                              f2: {
                                let value =
                                  (value: Raw.t_second_inner_inner).f2;
                                value;
                              },
                            }: t_second_inner_inner,
                          )
                        | None => None
                        };
                      },
                    }: t_second_inner,
                  )
                | None => None
                };
              },
            }: t_second
          );
        },
        let_: {
          let value = (value: Raw.t).let_;
          (
            {
              __typename: {
                let value = (value: Raw.t_let).__typename;
                value;
              },
              inner: {
                let value = (value: Raw.t_let).inner;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {
                      __typename: {
                        let value = (value: Raw.t_let_inner).__typename;
                        value;
                      },
                      inner: {
                        let value = (value: Raw.t_let_inner).inner;
                        switch (Js.toOption(value)) {
                        | Some(value) =>
                          Some(
                            {
                              __typename: {
                                let value =
                                  (value: Raw.t_let_inner_inner).__typename;
                                value;
                              },
                              field: {
                                let value =
                                  (value: Raw.t_let_inner_inner).field;
                                value;
                              },
                            }: t_let_inner_inner,
                          )
                        | None => None
                        };
                      },
                    }: t_let_inner,
                  )
                | None => None
                };
              },
            }: t_let
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let let_ = {
          let value = (value: t).let_;
          (
            {
              let inner = {
                let value = (value: t_let).inner;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {
                      let inner = {
                        let value = (value: t_let_inner).inner;
                        switch (value) {
                        | Some(value) =>
                          Js.Nullable.return(
                            {
                              let field = {
                                let value = (value: t_let_inner_inner).field;
                                value;
                              }
                              and __typename = {
                                let value =
                                  (value: t_let_inner_inner).__typename;
                                value;
                              };
                              {__typename, field};
                            }: Raw.t_let_inner_inner,
                          )
                        | None => Js.Nullable.null
                        };
                      }
                      and __typename = {
                        let value = (value: t_let_inner).__typename;
                        value;
                      };
                      {__typename, inner};
                    }: Raw.t_let_inner,
                  )
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_let).__typename;
                value;
              };
              {__typename, inner};
            }: Raw.t_let
          );
        }
        and second = {
          let value = (value: t).second;
          (
            {
              let inner = {
                let value = (value: t_second).inner;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {
                      let inner = {
                        let value = (value: t_second_inner).inner;
                        switch (value) {
                        | Some(value) =>
                          Js.Nullable.return(
                            {
                              let f2 = {
                                let value = (value: t_second_inner_inner).f2;
                                value;
                              }
                              and f1 = {
                                let value = (value: t_second_inner_inner).f1;
                                value;
                              }
                              and __typename = {
                                let value =
                                  (value: t_second_inner_inner).__typename;
                                value;
                              };
                              {__typename, f1, f2};
                            }: Raw.t_second_inner_inner,
                          )
                        | None => Js.Nullable.null
                        };
                      }
                      and __typename = {
                        let value = (value: t_second_inner).__typename;
                        value;
                      };
                      {__typename, inner};
                    }: Raw.t_second_inner,
                  )
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_second).__typename;
                value;
              };
              {__typename, inner};
            }: Raw.t_second
          );
        }
        and first = {
          let value = (value: t).first;
          (
            {
              let inner = {
                let value = (value: t_first).inner;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {
                      let inner = {
                        let value = (value: t_first_inner).inner;
                        switch (value) {
                        | Some(value) =>
                          Js.Nullable.return(
                            {
                              let field = {
                                let value = (value: t_first_inner_inner).field;
                                value;
                              }
                              and __typename = {
                                let value =
                                  (value: t_first_inner_inner).__typename;
                                value;
                              };
                              {__typename, field};
                            }: Raw.t_first_inner_inner,
                          )
                        | None => Js.Nullable.null
                        };
                      }
                      and __typename = {
                        let value = (value: t_first_inner).__typename;
                        value;
                      };
                      {__typename, inner};
                    }: Raw.t_first_inner,
                  )
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_first).__typename;
                value;
              };
              {__typename, inner};
            }: Raw.t_first
          );
        };
        {first, second, let_};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo nonrecursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {nonrecursiveInput: string};
    type t_variables = {arg: t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      nonNullableField: string,
      nullableArray: Js.Nullable.t(array(Js.Nullable.t(string))),
      field: Js.Nullable.t(string),
      enum: Js.Nullable.t(string),
      embeddedInput:
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
      custom: Js.Nullable.t(Js.Json.t),
    }
    and t_variables_EmbeddedInput = {field: Js.Nullable.t(string)};
  };
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {nonrecursiveInput: string};
  type t_variables = {arg: t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    nonNullableField: string,
    nullableArray: option(array(option(string))),
    field: option(string),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
    embeddedInput: option(array(option(t_variables_EmbeddedInput))),
    custom: option(Js.Json.t),
  }
  and t_variables_EmbeddedInput = {field: option(string)};
  let parse: Raw.t => t =
    (value) => (
      {
        nonrecursiveInput: {
          let value = (value: Raw.t).nonrecursiveInput;
          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let nonrecursiveInput = {
          let value = (value: t).nonrecursiveInput;
          value;
        };
        {nonrecursiveInput: nonrecursiveInput};
      }: Raw.t
    );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (a => serializeInputObjectNonrecursiveInput(a))(
          (inp: t_variables).arg,
        ),
    }
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {
      nonNullableField:
        (a => a)((inp: t_variables_NonrecursiveInput).nonNullableField),
      nullableArray:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).nullableArray,
        ),
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).field,
        ),
      enum:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).enum,
        ),
      embeddedInput:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).embeddedInput,
        ),
      custom:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).custom,
        ),
    }
  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_EmbeddedInput).field,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables)
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        ~custom=?,
        (),
      )
      : t_variables_NonrecursiveInput => {
    nonNullableField,
    nullableArray,
    field,
    enum,
    embeddedInput,
    custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {
    field: field,
  };
  module Z__INTERNAL = {
    type nonrec _graphql_arg_100;
    /**Variable **$arg** has the following graphql type:

\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}!
\`\`\`*/
    let _graphql_arg_100: _graphql_arg_100 = Obj.magic(0);
    type nonrec _graphql_arg_95;
    /**Argument **arg** on field **nonrecursiveInput** has the following graphql type:

\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}!
\`\`\`*/
    let _graphql_arg_95: _graphql_arg_95 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_NonrecursiveInput_49;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_49: _graphql_NonrecursiveInput_49 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery2 = {
  module Raw = {
    type t = {
      scalarsInput: string,
      more: string,
    };
    type t_variables = {
      arg: t_variables_NonrecursiveInput,
      arg2: t_variables_NonrecursiveInput,
    }
    and t_variables_NonrecursiveInput = {
      nonNullableField: string,
      nullableArray: Js.Nullable.t(array(Js.Nullable.t(string))),
      field: Js.Nullable.t(string),
      enum: Js.Nullable.t(string),
      embeddedInput:
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
      custom: Js.Nullable.t(Js.Json.t),
    }
    and t_variables_EmbeddedInput = {field: Js.Nullable.t(string)};
  };
  let query = \\"query ($arg: NonrecursiveInput!, $arg2: NonrecursiveInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\nmore: scalarsInput(arg: $arg2)  \\\\n}\\\\n\\";
  type t = {
    scalarsInput: string,
    more: string,
  };
  type t_variables = {
    arg: t_variables_NonrecursiveInput,
    arg2: t_variables_NonrecursiveInput,
  }
  and t_variables_NonrecursiveInput = {
    nonNullableField: string,
    nullableArray: option(array(option(string))),
    field: option(string),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
    embeddedInput: option(array(option(t_variables_EmbeddedInput))),
    custom: option(Js.Json.t),
  }
  and t_variables_EmbeddedInput = {field: option(string)};
  let parse: Raw.t => t =
    (value) => (
      {
        scalarsInput: {
          let value = (value: Raw.t).scalarsInput;
          value;
        },
        more: {
          let value = (value: Raw.t).more;
          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let more = {
          let value = (value: t).more;
          value;
        }
        and scalarsInput = {
          let value = (value: t).scalarsInput;
          value;
        };
        {scalarsInput, more};
      }: Raw.t
    );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (a => serializeInputObjectNonrecursiveInput(a))(
          (inp: t_variables).arg,
        ),
      arg2:
        (a => serializeInputObjectNonrecursiveInput(a))(
          (inp: t_variables).arg2,
        ),
    }
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {
      nonNullableField:
        (a => a)((inp: t_variables_NonrecursiveInput).nonNullableField),
      nullableArray:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).nullableArray,
        ),
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).field,
        ),
      enum:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).enum,
        ),
      embeddedInput:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).embeddedInput,
        ),
      custom:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).custom,
        ),
    }
  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_EmbeddedInput).field,
        ),
    };
  let makeVariables = (~arg, ~arg2, ()) =>
    serializeVariables({arg, arg2}: t_variables)
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        ~custom=?,
        (),
      )
      : t_variables_NonrecursiveInput => {
    nonNullableField,
    nullableArray,
    field,
    enum,
    embeddedInput,
    custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {
    field: field,
  };
  module Z__INTERNAL = {
    type nonrec _graphql_arg_240;
    /**Variable **$arg** has the following graphql type:

\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}!
\`\`\`*/
    let _graphql_arg_240: _graphql_arg_240 = Obj.magic(0);
    type nonrec _graphql_arg_235;
    /**Argument **arg** on field **scalarsInput** has the following graphql type:

\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}!
\`\`\`*/
    let _graphql_arg_235: _graphql_arg_235 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_NonrecursiveInput_169;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_169: _graphql_NonrecursiveInput_169 =
      Obj.magic(0);
    type nonrec _graphql_NonrecursiveInput_196;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_196: _graphql_NonrecursiveInput_196 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery2 {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo omitFutureValueEnum.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Normal = {
  module Raw = {
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      __typename: string,
      message: string,
      field: t_mutationWithError_errors_field,
    };
    type t_mutationWithError = {
      __typename: string,
      errors: Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {mutationWithError: t_mutationWithError};
    type t_variables = Js.Json.t;
  };
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\n__typename  \\\\nerrors  {\\\\n__typename  \\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_mutationWithError_errors_field = [
    | \`FutureAddedValue(string)
    | \`FIRST
    | \`SECOND
    | \`THIRD
  ];
  type t_mutationWithError_errors = {
    __typename: string,
    message: string,
    field: t_mutationWithError_errors_field,
  };
  type t_mutationWithError = {
    __typename: string,
    errors: option(array(t_mutationWithError_errors)),
  };
  type t = {mutationWithError: t_mutationWithError};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        mutationWithError: {
          let value = (value: Raw.t).mutationWithError;
          (
            {
              __typename: {
                let value = (value: Raw.t_mutationWithError).__typename;
                value;
              },
              errors: {
                let value = (value: Raw.t_mutationWithError).errors;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map((value) =>
                         (
                           {
                             __typename: {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).
                                   __typename;
                               value;
                             },
                             message: {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).
                                   message;
                               value;
                             },
                             field: {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).field;
                               switch (Obj.magic(value: string)) {
                               | \\"FIRST\\" => \`FIRST
                               | \\"SECOND\\" => \`SECOND
                               | \\"THIRD\\" => \`THIRD
                               | other => \`FutureAddedValue(other)
                               };
                             },
                           }: t_mutationWithError_errors
                         )
                       ),
                  )
                | None => None
                };
              },
            }: t_mutationWithError
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let mutationWithError = {
          let value = (value: t).mutationWithError;
          (
            {
              let errors = {
                let value = (value: t_mutationWithError).errors;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map((value) =>
                         (
                           {
                             let field = {
                               let value =
                                 (value: t_mutationWithError_errors).field;
                               switch (value) {
                               | \`FIRST => \\"FIRST\\"
                               | \`SECOND => \\"SECOND\\"
                               | \`THIRD => \\"THIRD\\"
                               | \`FutureAddedValue(other) => other
                               };
                             }
                             and message = {
                               let value =
                                 (value: t_mutationWithError_errors).message;
                               value;
                             }
                             and __typename = {
                               let value =
                                 (value: t_mutationWithError_errors).
                                   __typename;
                               value;
                             };
                             {__typename, message, field};
                           }: Raw.t_mutationWithError_errors
                         )
                       ),
                  )
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_mutationWithError).__typename;
                value;
              };
              {__typename, errors};
            }: Raw.t_mutationWithError
          );
        };
        {mutationWithError: mutationWithError};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module Normal {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByConfig = {
  module Raw = {
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      __typename: string,
      message: string,
      field: t_mutationWithError_errors_field,
    };
    type t_mutationWithError = {
      __typename: string,
      errors: Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {mutationWithError: t_mutationWithError};
    type t_variables = Js.Json.t;
  };
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\n__typename  \\\\nerrors  {\\\\n__typename  \\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_mutationWithError_errors_field = [ | \`FIRST | \`SECOND | \`THIRD];
  type t_mutationWithError_errors = {
    __typename: string,
    message: string,
    field: t_mutationWithError_errors_field,
  };
  type t_mutationWithError = {
    __typename: string,
    errors: option(array(t_mutationWithError_errors)),
  };
  type t = {mutationWithError: t_mutationWithError};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        mutationWithError: {
          let value = (value: Raw.t).mutationWithError;
          (
            {
              __typename: {
                let value = (value: Raw.t_mutationWithError).__typename;
                value;
              },
              errors: {
                let value = (value: Raw.t_mutationWithError).errors;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map((value) =>
                         (
                           {
                             __typename: {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).
                                   __typename;
                               value;
                             },
                             message: {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).
                                   message;
                               value;
                             },
                             field: {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).field;
                               switch (Obj.magic(value: string)) {
                               | \\"FIRST\\" => \`FIRST
                               | \\"SECOND\\" => \`SECOND
                               | \\"THIRD\\" => \`THIRD
                               | _ => raise(Not_found)
                               };
                             },
                           }: t_mutationWithError_errors
                         )
                       ),
                  )
                | None => None
                };
              },
            }: t_mutationWithError
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let mutationWithError = {
          let value = (value: t).mutationWithError;
          (
            {
              let errors = {
                let value = (value: t_mutationWithError).errors;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map((value) =>
                         (
                           {
                             let field = {
                               let value =
                                 (value: t_mutationWithError_errors).field;
                               switch (value) {
                               | \`FIRST => \\"FIRST\\"
                               | \`SECOND => \\"SECOND\\"
                               | \`THIRD => \\"THIRD\\"
                               };
                             }
                             and message = {
                               let value =
                                 (value: t_mutationWithError_errors).message;
                               value;
                             }
                             and __typename = {
                               let value =
                                 (value: t_mutationWithError_errors).
                                   __typename;
                               value;
                             };
                             {__typename, message, field};
                           }: Raw.t_mutationWithError_errors
                         )
                       ),
                  )
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_mutationWithError).__typename;
                value;
              };
              {__typename, errors};
            }: Raw.t_mutationWithError
          );
        };
        {mutationWithError: mutationWithError};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByConfig {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByDirective = {
  module Raw = {
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      __typename: string,
      message: string,
      field: t_mutationWithError_errors_field,
    };
    type t_mutationWithError = {
      __typename: string,
      errors: Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {mutationWithError: t_mutationWithError};
    type t_variables = Js.Json.t;
  };
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\n__typename  \\\\nerrors  {\\\\n__typename  \\\\nmessage  \\\\nfield @ppxOmitFutureValue \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_mutationWithError_errors_field = [ | \`FIRST | \`SECOND | \`THIRD];
  type t_mutationWithError_errors = {
    __typename: string,
    message: string,
    field: t_mutationWithError_errors_field,
  };
  type t_mutationWithError = {
    __typename: string,
    errors: option(array(t_mutationWithError_errors)),
  };
  type t = {mutationWithError: t_mutationWithError};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        mutationWithError: {
          let value = (value: Raw.t).mutationWithError;
          (
            {
              __typename: {
                let value = (value: Raw.t_mutationWithError).__typename;
                value;
              },
              errors: {
                let value = (value: Raw.t_mutationWithError).errors;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map((value) =>
                         (
                           {
                             __typename: {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).
                                   __typename;
                               value;
                             },
                             message: {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).
                                   message;
                               value;
                             },
                             field: {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).field;
                               switch (Obj.magic(value: string)) {
                               | \\"FIRST\\" => \`FIRST
                               | \\"SECOND\\" => \`SECOND
                               | \\"THIRD\\" => \`THIRD
                               | _ => raise(Not_found)
                               };
                             },
                           }: t_mutationWithError_errors
                         )
                       ),
                  )
                | None => None
                };
              },
            }: t_mutationWithError
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let mutationWithError = {
          let value = (value: t).mutationWithError;
          (
            {
              let errors = {
                let value = (value: t_mutationWithError).errors;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map((value) =>
                         (
                           {
                             let field = {
                               let value =
                                 (value: t_mutationWithError_errors).field;
                               switch (value) {
                               | \`FIRST => \\"FIRST\\"
                               | \`SECOND => \\"SECOND\\"
                               | \`THIRD => \\"THIRD\\"
                               };
                             }
                             and message = {
                               let value =
                                 (value: t_mutationWithError_errors).message;
                               value;
                             }
                             and __typename = {
                               let value =
                                 (value: t_mutationWithError_errors).
                                   __typename;
                               value;
                             };
                             {__typename, message, field};
                           }: Raw.t_mutationWithError_errors
                         )
                       ),
                  )
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_mutationWithError).__typename;
                value;
              };
              {__typename, errors};
            }: Raw.t_mutationWithError
          );
        };
        {mutationWithError: mutationWithError};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByDirective {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo omitFutureValueUnion.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Normal = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n__typename  \\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\n__typename  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    __typename: string,
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {
    __typename: string,
    name: string,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        dogOrHuman: {
          let value = (value: Raw.t).dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                  (
                    {
                      __typename: {
                        let value = (value: Raw.t_dogOrHuman_Dog).__typename;
                        value;
                      },
                      name: {
                        let value = (value: Raw.t_dogOrHuman_Dog).name;
                        value;
                      },
                      barkVolume: {
                        let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                        value;
                      },
                    }: t_dogOrHuman_Dog
                  );
                },
              )
            | \\"Human\\" =>
              \`Human(
                {
                  let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                  (
                    {
                      __typename: {
                        let value = (value: Raw.t_dogOrHuman_Human).__typename;
                        value;
                      },
                      name: {
                        let value = (value: Raw.t_dogOrHuman_Human).name;
                        value;
                      },
                    }: t_dogOrHuman_Human
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: t).dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {
                  let barkVolume = {
                    let value = (value: t_dogOrHuman_Dog).barkVolume;
                    value;
                  }
                  and name = {
                    let value = (value: t_dogOrHuman_Dog).name;
                    value;
                  }
                  and __typename = {
                    let value = (value: t_dogOrHuman_Dog).__typename;
                    value;
                  };
                  {__typename: \\"Dog\\", name, barkVolume};
                }: Raw.t_dogOrHuman_Dog,
              ): Raw.t_dogOrHuman
            )
          | \`Human(value) => (
              Obj.magic(
                {
                  let name = {
                    let value = (value: t_dogOrHuman_Human).name;
                    value;
                  }
                  and __typename = {
                    let value = (value: t_dogOrHuman_Human).__typename;
                    value;
                  };
                  {__typename: \\"Human\\", name};
                }: Raw.t_dogOrHuman_Human,
              ): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        };
        {dogOrHuman: dogOrHuman};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module Normal {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByConfig = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n__typename  \\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\n__typename  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    __typename: string,
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {
    __typename: string,
    name: string,
  };
  type t_dogOrHuman = [
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        dogOrHuman: {
          let value = (value: Raw.t).dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                  (
                    {
                      __typename: {
                        let value = (value: Raw.t_dogOrHuman_Dog).__typename;
                        value;
                      },
                      name: {
                        let value = (value: Raw.t_dogOrHuman_Dog).name;
                        value;
                      },
                      barkVolume: {
                        let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                        value;
                      },
                    }: t_dogOrHuman_Dog
                  );
                },
              )
            | \\"Human\\" =>
              \`Human(
                {
                  let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                  (
                    {
                      __typename: {
                        let value = (value: Raw.t_dogOrHuman_Human).__typename;
                        value;
                      },
                      name: {
                        let value = (value: Raw.t_dogOrHuman_Human).name;
                        value;
                      },
                    }: t_dogOrHuman_Human
                  );
                },
              )
            | _ => raise(Not_found)
            }: t_dogOrHuman
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: t).dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {
                  let barkVolume = {
                    let value = (value: t_dogOrHuman_Dog).barkVolume;
                    value;
                  }
                  and name = {
                    let value = (value: t_dogOrHuman_Dog).name;
                    value;
                  }
                  and __typename = {
                    let value = (value: t_dogOrHuman_Dog).__typename;
                    value;
                  };
                  {__typename: \\"Dog\\", name, barkVolume};
                }: Raw.t_dogOrHuman_Dog,
              ): Raw.t_dogOrHuman
            )
          | \`Human(value) => (
              Obj.magic(
                {
                  let name = {
                    let value = (value: t_dogOrHuman_Human).name;
                    value;
                  }
                  and __typename = {
                    let value = (value: t_dogOrHuman_Human).__typename;
                    value;
                  };
                  {__typename: \\"Human\\", name};
                }: Raw.t_dogOrHuman_Human,
              ): Raw.t_dogOrHuman
            )
          };
        };
        {dogOrHuman: dogOrHuman};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByConfig {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByDirective = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndogOrHuman @ppxOmitFutureValue {\\\\n__typename\\\\n...on Dog   {\\\\n__typename  \\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\n__typename  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    __typename: string,
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {
    __typename: string,
    name: string,
  };
  type t_dogOrHuman = [
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        dogOrHuman: {
          let value = (value: Raw.t).dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                  (
                    {
                      __typename: {
                        let value = (value: Raw.t_dogOrHuman_Dog).__typename;
                        value;
                      },
                      name: {
                        let value = (value: Raw.t_dogOrHuman_Dog).name;
                        value;
                      },
                      barkVolume: {
                        let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                        value;
                      },
                    }: t_dogOrHuman_Dog
                  );
                },
              )
            | \\"Human\\" =>
              \`Human(
                {
                  let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                  (
                    {
                      __typename: {
                        let value = (value: Raw.t_dogOrHuman_Human).__typename;
                        value;
                      },
                      name: {
                        let value = (value: Raw.t_dogOrHuman_Human).name;
                        value;
                      },
                    }: t_dogOrHuman_Human
                  );
                },
              )
            | _ => raise(Not_found)
            }: t_dogOrHuman
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: t).dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {
                  let barkVolume = {
                    let value = (value: t_dogOrHuman_Dog).barkVolume;
                    value;
                  }
                  and name = {
                    let value = (value: t_dogOrHuman_Dog).name;
                    value;
                  }
                  and __typename = {
                    let value = (value: t_dogOrHuman_Dog).__typename;
                    value;
                  };
                  {__typename: \\"Dog\\", name, barkVolume};
                }: Raw.t_dogOrHuman_Dog,
              ): Raw.t_dogOrHuman
            )
          | \`Human(value) => (
              Obj.magic(
                {
                  let name = {
                    let value = (value: t_dogOrHuman_Human).name;
                    value;
                  }
                  and __typename = {
                    let value = (value: t_dogOrHuman_Human).__typename;
                    value;
                  };
                  {__typename: \\"Human\\", name};
                }: Raw.t_dogOrHuman_Human,
              ): Raw.t_dogOrHuman
            )
          };
        };
        {dogOrHuman: dogOrHuman};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByDirective {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo pokedexApolloMode.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_pokemon = {
      __typename: string,
      id: string,
      name: Js.Nullable.t(string),
    };
    type t = {pokemon: Js.Nullable.t(t_pokemon)};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\npokemon(name: \\\\\\"Pikachu\\\\\\")  {\\\\n__typename  \\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_pokemon = {
    __typename: string,
    id: string,
    name: option(string),
  };
  type t = {pokemon: option(t_pokemon)};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        pokemon: {
          let value = (value: Raw.t).pokemon;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {
                __typename: {
                  let value = (value: Raw.t_pokemon).__typename;
                  value;
                },
                id: {
                  let value = (value: Raw.t_pokemon).id;
                  value;
                },
                name: {
                  let value = (value: Raw.t_pokemon).name;
                  switch (Js.toOption(value)) {
                  | Some(value) => Some(value)
                  | None => None
                  };
                },
              }: t_pokemon,
            )
          | None => None
          };
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let pokemon = {
          let value = (value: t).pokemon;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {
                let name = {
                  let value = (value: t_pokemon).name;
                  switch (value) {
                  | Some(value) => Js.Nullable.return(value)
                  | None => Js.Nullable.null
                  };
                }
                and id = {
                  let value = (value: t_pokemon).id;
                  value;
                }
                and __typename = {
                  let value = (value: t_pokemon).__typename;
                  value;
                };
                {__typename, id, name};
              }: Raw.t_pokemon,
            )
          | None => Js.Nullable.null
          };
        };
        {pokemon: pokemon};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type nonrec _graphql_name_52;
    /**Argument **name** on field **pokemon** has the following graphql type:

\`\`\`
String
\`\`\`*/
    let _graphql_name_52: _graphql_name_52 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo pokedexScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_pokemon = {
      __typename: string,
      id: string,
      name: Js.Nullable.t(string),
    };
    type t = {pokemon: Js.Nullable.t(t_pokemon)};
    type t_variables = {
      id: Js.Nullable.t(string),
      name: Js.Nullable.t(string),
    };
  };
  let query = \\"query pokemon($id: String, $name: String)  {\\\\npokemon(name: $name, id: $id)  {\\\\n__typename  \\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_pokemon = {
    __typename: string,
    id: string,
    name: option(string),
  };
  type t = {pokemon: option(t_pokemon)};
  type t_variables = {
    id: option(string),
    name: option(string),
  };
  let parse: Raw.t => t =
    (value) => (
      {
        pokemon: {
          let value = (value: Raw.t).pokemon;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {
                __typename: {
                  let value = (value: Raw.t_pokemon).__typename;
                  value;
                },
                id: {
                  let value = (value: Raw.t_pokemon).id;
                  value;
                },
                name: {
                  let value = (value: Raw.t_pokemon).name;
                  switch (Js.toOption(value)) {
                  | Some(value) => Some(value)
                  | None => None
                  };
                },
              }: t_pokemon,
            )
          | None => None
          };
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let pokemon = {
          let value = (value: t).pokemon;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {
                let name = {
                  let value = (value: t_pokemon).name;
                  switch (value) {
                  | Some(value) => Js.Nullable.return(value)
                  | None => Js.Nullable.null
                  };
                }
                and id = {
                  let value = (value: t_pokemon).id;
                  value;
                }
                and __typename = {
                  let value = (value: t_pokemon).__typename;
                  value;
                };
                {__typename, id, name};
              }: Raw.t_pokemon,
            )
          | None => Js.Nullable.null
          };
        };
        {pokemon: pokemon};
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      id:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).id,
        ),
      name:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).name,
        ),
    };
  let makeVariables = (~id=?, ~name=?, ()) =>
    serializeVariables({id, name}: t_variables);
  module Z__INTERNAL = {
    type nonrec _graphql_name_100;
    /**Variable **$name** has the following graphql type:

\`\`\`
String
\`\`\`*/
    let _graphql_name_100: _graphql_name_100 = Obj.magic(0);
    type nonrec _graphql_name_94;
    /**Argument **name** on field **pokemon** has the following graphql type:

\`\`\`
String
\`\`\`*/
    let _graphql_name_94: _graphql_name_94 = Obj.magic(0);
    type nonrec _graphql_id_111;
    /**Variable **$id** has the following graphql type:

\`\`\`
String
\`\`\`*/
    let _graphql_id_111: _graphql_id_111 = Obj.magic(0);
    type nonrec _graphql_id_107;
    /**Argument **id** on field **pokemon** has the following graphql type:

\`\`\`
String
\`\`\`*/
    let _graphql_id_107: _graphql_id_107 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type scalars = {
  string,
  int,
};

type dog = {
  name: string,
  barkVolume: float,
};

type oneFieldQuery = {nullableString: option(string)};
module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      __typename: string,
      string,
      int,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\n__typename  \\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {variousScalars: scalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {
              __typename: {
                let value = (value: Raw.t_variousScalars).__typename;
                value;
              },
              string: {
                let value = (value: Raw.t_variousScalars).string;
                value;
              },
              int: {
                let value = (value: Raw.t_variousScalars).int;
                value;
              },
            }: scalars
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let int = {
                let value = (value: scalars).int;
                value;
              }
              and string = {
                let value = (value: scalars).string;
                value;
              }
              and __typename = {
                let value = (value: scalars).__typename;
                value;
              };
              {__typename, string, int};
            }: Raw.t_variousScalars
          );
        };
        {variousScalars: variousScalars};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module OneFieldQuery = {
  module Raw = {
    type t_variousScalars = {
      __typename: string,
      nullableString: Js.Nullable.t(string),
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\n__typename  \\\\nnullableString  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {
    __typename: string,
    nullableString: option(string),
  };
  type t = {variousScalars: t_variousScalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {
              __typename: {
                let value = (value: Raw.t_variousScalars).__typename;
                value;
              },
              nullableString: {
                let value = (value: Raw.t_variousScalars).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
            }: t_variousScalars
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let nullableString = {
                let value = (value: t_variousScalars).nullableString;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_variousScalars).__typename;
                value;
              };
              {__typename, nullableString};
            }: Raw.t_variousScalars
          );
        };
        {variousScalars: variousScalars};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module OneFieldQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ExternalFragmentQuery = {
  module Fragment = {
    let query = \\"fragment Fragment on VariousScalars   {\\\\n__typename  \\\\nstring  \\\\nint  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        __typename: string,
        string,
        int,
      };
      type nonrec t_VariousScalars = t;
    };
    type t = {
      __typename: string,
      string,
      int,
    };
    type nonrec t_VariousScalars = t;
    let parse = (value: Raw.t): t => {
      __typename: {
        let value = (value: Raw.t).__typename;
        value;
      },
      string: {
        let value = (value: Raw.t).string;
        value;
      },
      int: {
        let value = (value: Raw.t).int;
        value;
      },
    };
    let serialize: t => Raw.t =
      (value) => (
        {
          let int = {
            let value = (value: t).int;
            value;
          }
          and string = {
            let value = (value: t).string;
            value;
          }
          and __typename = {
            let value = (value: t).__typename;
            value;
          };
          {__typename, string, int};
        }: Raw.t
      );
    let name = \\"Fragment\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql;
      /**\`\`\`
VariousScalars {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}
\`\`\`*/
      let graphql: graphql = Obj.magic(0);
      type nonrec graphql_module;
      /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ExternalFragmentQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  module Untitled1 = {
    module Raw = {
      type t = {variousScalars: Fragment.Raw.t};
      type t_variables = Js.Json.t;
    };
    let query =
      (
        (\\"query   {\\\\nvariousScalars  {\\\\n...\\" ++ Fragment.name)
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ Fragment.query;
    type t = {variousScalars: Fragment.t};
    type t_variables = Js.Json.t;
    let parse: Raw.t => t =
      (value) => (
        {
          variousScalars: {
            let value = (value: Raw.t).variousScalars;
            Fragment.parse(value);
          },
        }: t
      );
    let serialize: t => Raw.t =
      (value) => (
        {
          let variousScalars = {
            let value = (value: t).variousScalars;
            Fragment.serialize(value);
          };
          {variousScalars: variousScalars};
        }: Raw.t
      );
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql_module;
      /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ExternalFragmentQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
};
module InlineFragmentQuery = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n__typename  \\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    __typename: string,
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        dogOrHuman: {
          let value = (value: Raw.t).dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                  (
                    {
                      __typename: {
                        let value = (value: Raw.t_dogOrHuman_Dog).__typename;
                        value;
                      },
                      name: {
                        let value = (value: Raw.t_dogOrHuman_Dog).name;
                        value;
                      },
                      barkVolume: {
                        let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                        value;
                      },
                    }: t_dogOrHuman_Dog
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: t).dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {
                  let barkVolume = {
                    let value = (value: t_dogOrHuman_Dog).barkVolume;
                    value;
                  }
                  and name = {
                    let value = (value: t_dogOrHuman_Dog).name;
                    value;
                  }
                  and __typename = {
                    let value = (value: t_dogOrHuman_Dog).__typename;
                    value;
                  };
                  {__typename: \\"Dog\\", name, barkVolume};
                }: Raw.t_dogOrHuman_Dog,
              ): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        };
        {dogOrHuman: dogOrHuman};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module InlineFragmentQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module UnionExternalFragmentQuery = {
  module DogFragment = {
    let query = \\"fragment DogFragment on Dog   {\\\\n__typename  \\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        __typename: string,
        name: string,
        barkVolume: float,
      };
      type nonrec t_Dog = t;
    };
    type t = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type nonrec t_Dog = t;
    let parse = (value: Raw.t): t => {
      __typename: {
        let value = (value: Raw.t).__typename;
        value;
      },
      name: {
        let value = (value: Raw.t).name;
        value;
      },
      barkVolume: {
        let value = (value: Raw.t).barkVolume;
        value;
      },
    };
    let serialize: t => Raw.t =
      (value) => (
        {
          let barkVolume = {
            let value = (value: t).barkVolume;
            value;
          }
          and name = {
            let value = (value: t).name;
            value;
          }
          and __typename = {
            let value = (value: t).__typename;
            value;
          };
          {__typename, name, barkVolume};
        }: Raw.t
      );
    let name = \\"DogFragment\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql;
      /**\`\`\`
Dog {
  name: String!
  barkVolume: Float!
}
\`\`\`*/
      let graphql: graphql = Obj.magic(0);
      type nonrec graphql_module;
      /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module UnionExternalFragmentQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  module Untitled1 = {
    module Raw = {
      type t_dogOrHuman;
      type t = {dogOrHuman: t_dogOrHuman};
      type t_variables = Js.Json.t;
    };
    let query =
      (
        (
          \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n...\\"
          ++ DogFragment.name
        )
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ DogFragment.query;
    type t_dogOrHuman = [
      | \`FutureAddedValue(Js.Json.t)
      | \`Dog(DogFragment.t)
    ];
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = Js.Json.t;
    let parse: Raw.t => t =
      (value) => (
        {
          dogOrHuman: {
            let value = (value: Raw.t).dogOrHuman;
            let typename: string =
              Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
            (
              switch (typename) {
              | \\"Dog\\" =>
                \`Dog(
                  {
                    let value: DogFragment.Raw.t = Obj.magic(value);
                    DogFragment.parse(value);
                  },
                )
              | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
              }: t_dogOrHuman
            );
          },
        }: t
      );
    let serialize: t => Raw.t =
      (value) => (
        {
          let dogOrHuman = {
            let value = (value: t).dogOrHuman;
            switch (value) {
            | \`Dog(value) => (
                Obj.magic(DogFragment.serialize(value)): Raw.t_dogOrHuman
              )
            | \`FutureAddedValue(value) => (
                Obj.magic(value): Raw.t_dogOrHuman
              )
            };
          };
          {dogOrHuman: dogOrHuman};
        }: Raw.t
      );
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql_module;
      /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module UnionExternalFragmentQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
};
"
`;

exports[`Apollo recursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {recursiveInput: string};
    type t_variables = {arg: t_variables_RecursiveInput}
    and t_variables_RecursiveInput = {
      otherField: Js.Nullable.t(string),
      inner: Js.Nullable.t(t_variables_RecursiveInput),
      enum: Js.Nullable.t(string),
    };
  };
  let query = \\"query ($arg: RecursiveInput!)  {\\\\nrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {recursiveInput: string};
  type t_variables = {arg: t_variables_RecursiveInput}
  and t_variables_RecursiveInput = {
    otherField: option(string),
    inner: option(t_variables_RecursiveInput),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  let parse: Raw.t => t =
    (value) => (
      {
        recursiveInput: {
          let value = (value: Raw.t).recursiveInput;
          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let recursiveInput = {
          let value = (value: t).recursiveInput;
          value;
        };
        {recursiveInput: recursiveInput};
      }: Raw.t
    );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (a => serializeInputObjectRecursiveInput(a))((inp: t_variables).arg),
    }
  and serializeInputObjectRecursiveInput:
    t_variables_RecursiveInput => Raw.t_variables_RecursiveInput =
    inp => {
      otherField:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_RecursiveInput).otherField,
        ),
      inner:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (a => serializeInputObjectRecursiveInput(a))(b),
              )
            }
        )(
          (inp: t_variables_RecursiveInput).inner,
        ),
      enum:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_RecursiveInput).enum,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables)
  and makeInputObjectRecursiveInput =
      (~otherField=?, ~inner=?, ~enum=?, ()): t_variables_RecursiveInput => {
    otherField,
    inner,
    enum,
  };
  module Z__INTERNAL = {
    type nonrec _graphql_arg_90;
    /**Variable **$arg** has the following graphql type:

\`\`\`
RecursiveInput {
  otherField: String
  inner: RecursiveInput
  enum: SampleField
}!
\`\`\`*/
    let _graphql_arg_90: _graphql_arg_90 = Obj.magic(0);
    type nonrec _graphql_arg_85;
    /**Argument **arg** on field **recursiveInput** has the following graphql type:

\`\`\`
RecursiveInput {
  otherField: String
  inner: RecursiveInput
  enum: SampleField
}!
\`\`\`*/
    let _graphql_arg_85: _graphql_arg_85 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_RecursiveInput_47;
    /**\`\`\`
RecursiveInput {
  otherField: String
  inner: RecursiveInput
  enum: SampleField
}
\`\`\`*/
    let _graphql_RecursiveInput_47: _graphql_RecursiveInput_47 = Obj.magic(0);
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo scalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      __typename: string,
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\n__typename  \\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {
    __typename: string,
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {
              __typename: {
                let value = (value: Raw.t_variousScalars).__typename;
                value;
              },
              nullableString: {
                let value = (value: Raw.t_variousScalars).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              string: {
                let value = (value: Raw.t_variousScalars).string;
                value;
              },
              nullableInt: {
                let value = (value: Raw.t_variousScalars).nullableInt;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              int: {
                let value = (value: Raw.t_variousScalars).int;
                value;
              },
              nullableFloat: {
                let value = (value: Raw.t_variousScalars).nullableFloat;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              float: {
                let value = (value: Raw.t_variousScalars).float;
                value;
              },
              nullableBoolean: {
                let value = (value: Raw.t_variousScalars).nullableBoolean;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              boolean: {
                let value = (value: Raw.t_variousScalars).boolean;
                value;
              },
              nullableID: {
                let value = (value: Raw.t_variousScalars).nullableID;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              id: {
                let value = (value: Raw.t_variousScalars).id;
                value;
              },
            }: t_variousScalars
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let id = {
                let value = (value: t_variousScalars).id;
                value;
              }
              and nullableID = {
                let value = (value: t_variousScalars).nullableID;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and boolean = {
                let value = (value: t_variousScalars).boolean;
                value;
              }
              and nullableBoolean = {
                let value = (value: t_variousScalars).nullableBoolean;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and float = {
                let value = (value: t_variousScalars).float;
                value;
              }
              and nullableFloat = {
                let value = (value: t_variousScalars).nullableFloat;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and int = {
                let value = (value: t_variousScalars).int;
                value;
              }
              and nullableInt = {
                let value = (value: t_variousScalars).nullableInt;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and string = {
                let value = (value: t_variousScalars).string;
                value;
              }
              and nullableString = {
                let value = (value: t_variousScalars).nullableString;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_variousScalars).__typename;
                value;
              };
              {
                __typename,
                nullableString,
                string,
                nullableInt,
                int,
                nullableFloat,
                float,
                nullableBoolean,
                boolean,
                nullableID,
                id,
              };
            }: Raw.t_variousScalars
          );
        };
        {variousScalars: variousScalars};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo scalarsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {scalarsInput: string};
    type t_variables = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
  };
  let query = \\"query ($nullableString: String, $string: String!, $nullableInt: Int, $int: Int!, $nullableFloat: Float, $float: Float!, $nullableBoolean: Boolean, $boolean: Boolean!, $nullableID: ID, $id: ID!)  {\\\\nscalarsInput(arg: {nullableString: $nullableString, string: $string, nullableInt: $nullableInt, int: $int, nullableFloat: $nullableFloat, float: $float, nullableBoolean: $nullableBoolean, boolean: $boolean, nullableID: $nullableID, id: $id})  \\\\n}\\\\n\\";
  type t = {scalarsInput: string};
  type t_variables = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  let parse: Raw.t => t =
    (value) => (
      {
        scalarsInput: {
          let value = (value: Raw.t).scalarsInput;
          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let scalarsInput = {
          let value = (value: t).scalarsInput;
          value;
        };
        {scalarsInput: scalarsInput};
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      nullableString:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableString,
        ),
      string: (a => a)((inp: t_variables).string),
      nullableInt:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableInt,
        ),
      int: (a => a)((inp: t_variables).int),
      nullableFloat:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableFloat,
        ),
      float: (a => a)((inp: t_variables).float),
      nullableBoolean:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableBoolean,
        ),
      boolean: (a => a)((inp: t_variables).boolean),
      nullableID:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableID,
        ),
      id: (a => a)((inp: t_variables).id),
    };
  let makeVariables =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      ) =>
    serializeVariables(
      {
        nullableString,
        string,
        nullableInt,
        int,
        nullableFloat,
        float,
        nullableBoolean,
        boolean,
        nullableID,
        id,
      }: t_variables,
    );
  module Z__INTERNAL = {
    type nonrec _graphql_arg_292;
    /**Argument **arg** on field **scalarsInput** has the following graphql type:

\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}!
\`\`\`*/
    let _graphql_arg_292: _graphql_arg_292 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo scalarsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {scalarsInput: string};
    type t_variables = {arg: t_variables_VariousScalarsInput}
    and t_variables_VariousScalarsInput = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
  };
  let query = \\"query ($arg: VariousScalarsInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {scalarsInput: string};
  type t_variables = {arg: t_variables_VariousScalarsInput}
  and t_variables_VariousScalarsInput = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  let parse: Raw.t => t =
    (value) => (
      {
        scalarsInput: {
          let value = (value: Raw.t).scalarsInput;
          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let scalarsInput = {
          let value = (value: t).scalarsInput;
          value;
        };
        {scalarsInput: scalarsInput};
      }: Raw.t
    );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (a => serializeInputObjectVariousScalarsInput(a))(
          (inp: t_variables).arg,
        ),
    }
  and serializeInputObjectVariousScalarsInput:
    t_variables_VariousScalarsInput => Raw.t_variables_VariousScalarsInput =
    inp => {
      nullableString:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableString,
        ),
      string: (a => a)((inp: t_variables_VariousScalarsInput).string),
      nullableInt:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableInt,
        ),
      int: (a => a)((inp: t_variables_VariousScalarsInput).int),
      nullableFloat:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableFloat,
        ),
      float: (a => a)((inp: t_variables_VariousScalarsInput).float),
      nullableBoolean:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableBoolean,
        ),
      boolean: (a => a)((inp: t_variables_VariousScalarsInput).boolean),
      nullableID:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableID,
        ),
      id: (a => a)((inp: t_variables_VariousScalarsInput).id),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables)
  and makeInputObjectVariousScalarsInput =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      )
      : t_variables_VariousScalarsInput => {
    nullableString,
    string,
    nullableInt,
    int,
    nullableFloat,
    float,
    nullableBoolean,
    boolean,
    nullableID,
    id,
  };
  module Z__INTERNAL = {
    type nonrec _graphql_arg_93;
    /**Variable **$arg** has the following graphql type:

\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}!
\`\`\`*/
    let _graphql_arg_93: _graphql_arg_93 = Obj.magic(0);
    type nonrec _graphql_arg_88;
    /**Argument **arg** on field **scalarsInput** has the following graphql type:

\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}!
\`\`\`*/
    let _graphql_arg_88: _graphql_arg_88 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_VariousScalarsInput_47;
    /**\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}
\`\`\`*/
    let _graphql_VariousScalarsInput_47: _graphql_VariousScalarsInput_47 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo skipDirectives.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_v1 = {
      __typename: string,
      nullableString: Js.Nullable.t(string),
      string: Js.Nullable.t(string),
    };
    type t_v2 = {
      __typename: string,
      nullableString: Js.Nullable.t(string),
      string: Js.Nullable.t(string),
    };
    type t = {
      v1: t_v1,
      v2: t_v2,
    };
    type t_variables = {var: bool};
  };
  let query = \\"query ($var: Boolean!)  {\\\\nv1: variousScalars  {\\\\n__typename  \\\\nnullableString @skip(if: $var) \\\\nstring @skip(if: $var) \\\\n}\\\\n\\\\nv2: variousScalars  {\\\\n__typename  \\\\nnullableString @include(if: $var) \\\\nstring @include(if: $var) \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_v1 = {
    __typename: string,
    nullableString: option(string),
    string: option(string),
  };
  type t_v2 = {
    __typename: string,
    nullableString: option(string),
    string: option(string),
  };
  type t = {
    v1: t_v1,
    v2: t_v2,
  };
  type t_variables = {var: bool};
  let parse: Raw.t => t =
    (value) => (
      {
        v1: {
          let value = (value: Raw.t).v1;
          (
            {
              __typename: {
                let value = (value: Raw.t_v1).__typename;
                value;
              },
              nullableString: {
                let value = (value: Raw.t_v1).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              string: {
                let value = (value: Raw.t_v1).string;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
            }: t_v1
          );
        },
        v2: {
          let value = (value: Raw.t).v2;
          (
            {
              __typename: {
                let value = (value: Raw.t_v2).__typename;
                value;
              },
              nullableString: {
                let value = (value: Raw.t_v2).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              string: {
                let value = (value: Raw.t_v2).string;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
            }: t_v2
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let v2 = {
          let value = (value: t).v2;
          (
            {
              let string = {
                let value = (value: t_v2).string;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and nullableString = {
                let value = (value: t_v2).nullableString;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_v2).__typename;
                value;
              };
              {__typename, nullableString, string};
            }: Raw.t_v2
          );
        }
        and v1 = {
          let value = (value: t).v1;
          (
            {
              let string = {
                let value = (value: t_v1).string;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and nullableString = {
                let value = (value: t_v1).nullableString;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_v1).__typename;
                value;
              };
              {__typename, nullableString, string};
            }: Raw.t_v1
          );
        };
        {v1, v2};
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {var: (a => a)((inp: t_variables).var)};
  let makeVariables = (~var, ()) =>
    serializeVariables({var: var}: t_variables);
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo subscription.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_simpleSubscription_Dog = {
      __typename: string,
      name: string,
    };
    type t_simpleSubscription_Human = {
      __typename: string,
      name: string,
    };
    type t_simpleSubscription;
    type t = {simpleSubscription: t_simpleSubscription};
    type t_variables = Js.Json.t;
  };
  let query = \\"subscription   {\\\\nsimpleSubscription  {\\\\n__typename\\\\n...on Dog   {\\\\n__typename  \\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\n__typename  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_simpleSubscription_Dog = {
    __typename: string,
    name: string,
  };
  type t_simpleSubscription_Human = {
    __typename: string,
    name: string,
  };
  type t_simpleSubscription = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_simpleSubscription_Dog)
    | \`Human(t_simpleSubscription_Human)
  ];
  type t = {simpleSubscription: t_simpleSubscription};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        simpleSubscription: {
          let value = (value: Raw.t).simpleSubscription;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_simpleSubscription_Dog = Obj.magic(value);
                  (
                    {
                      __typename: {
                        let value =
                          (value: Raw.t_simpleSubscription_Dog).__typename;
                        value;
                      },
                      name: {
                        let value = (value: Raw.t_simpleSubscription_Dog).name;
                        value;
                      },
                    }: t_simpleSubscription_Dog
                  );
                },
              )
            | \\"Human\\" =>
              \`Human(
                {
                  let value: Raw.t_simpleSubscription_Human = Obj.magic(value);
                  (
                    {
                      __typename: {
                        let value =
                          (value: Raw.t_simpleSubscription_Human).__typename;
                        value;
                      },
                      name: {
                        let value =
                          (value: Raw.t_simpleSubscription_Human).name;
                        value;
                      },
                    }: t_simpleSubscription_Human
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_simpleSubscription
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let simpleSubscription = {
          let value = (value: t).simpleSubscription;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {
                  let name = {
                    let value = (value: t_simpleSubscription_Dog).name;
                    value;
                  }
                  and __typename = {
                    let value = (value: t_simpleSubscription_Dog).__typename;
                    value;
                  };
                  {__typename: \\"Dog\\", name};
                }: Raw.t_simpleSubscription_Dog,
              ): Raw.t_simpleSubscription
            )
          | \`Human(value) => (
              Obj.magic(
                {
                  let name = {
                    let value = (value: t_simpleSubscription_Human).name;
                    value;
                  }
                  and __typename = {
                    let value = (value: t_simpleSubscription_Human).__typename;
                    value;
                  };
                  {__typename: \\"Human\\", name};
                }: Raw.t_simpleSubscription_Human,
              ): Raw.t_simpleSubscription
            )
          | \`FutureAddedValue(value) => (
              Obj.magic(value): Raw.t_simpleSubscription
            )
          };
        };
        {simpleSubscription: simpleSubscription};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo tagged_template.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      __typename: string,
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\n__typename  \\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {
    __typename: string,
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {
              __typename: {
                let value = (value: Raw.t_variousScalars).__typename;
                value;
              },
              nullableString: {
                let value = (value: Raw.t_variousScalars).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              string: {
                let value = (value: Raw.t_variousScalars).string;
                value;
              },
              nullableInt: {
                let value = (value: Raw.t_variousScalars).nullableInt;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              int: {
                let value = (value: Raw.t_variousScalars).int;
                value;
              },
              nullableFloat: {
                let value = (value: Raw.t_variousScalars).nullableFloat;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              float: {
                let value = (value: Raw.t_variousScalars).float;
                value;
              },
              nullableBoolean: {
                let value = (value: Raw.t_variousScalars).nullableBoolean;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              boolean: {
                let value = (value: Raw.t_variousScalars).boolean;
                value;
              },
              nullableID: {
                let value = (value: Raw.t_variousScalars).nullableID;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              id: {
                let value = (value: Raw.t_variousScalars).id;
                value;
              },
            }: t_variousScalars
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let id = {
                let value = (value: t_variousScalars).id;
                value;
              }
              and nullableID = {
                let value = (value: t_variousScalars).nullableID;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and boolean = {
                let value = (value: t_variousScalars).boolean;
                value;
              }
              and nullableBoolean = {
                let value = (value: t_variousScalars).nullableBoolean;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and float = {
                let value = (value: t_variousScalars).float;
                value;
              }
              and nullableFloat = {
                let value = (value: t_variousScalars).nullableFloat;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and int = {
                let value = (value: t_variousScalars).int;
                value;
              }
              and nullableInt = {
                let value = (value: t_variousScalars).nullableInt;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and string = {
                let value = (value: t_variousScalars).string;
                value;
              }
              and nullableString = {
                let value = (value: t_variousScalars).nullableString;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_variousScalars).__typename;
                value;
              };
              {
                __typename,
                nullableString,
                string,
                nullableInt,
                int,
                nullableFloat,
                float,
                nullableBoolean,
                boolean,
                nullableID,
                id,
              };
            }: Raw.t_variousScalars
          );
        };
        {variousScalars: variousScalars};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery2 = {
  module Raw = {
    type t_variousScalars = {
      __typename: string,
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = Js.Json.t;
  };
  %raw
  \\"let { graphql } = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      __typename\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variousScalars = {
    __typename: string,
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {
              __typename: {
                let value = (value: Raw.t_variousScalars).__typename;
                value;
              },
              nullableString: {
                let value = (value: Raw.t_variousScalars).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              string: {
                let value = (value: Raw.t_variousScalars).string;
                value;
              },
              nullableInt: {
                let value = (value: Raw.t_variousScalars).nullableInt;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              int: {
                let value = (value: Raw.t_variousScalars).int;
                value;
              },
              nullableFloat: {
                let value = (value: Raw.t_variousScalars).nullableFloat;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              float: {
                let value = (value: Raw.t_variousScalars).float;
                value;
              },
              nullableBoolean: {
                let value = (value: Raw.t_variousScalars).nullableBoolean;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              boolean: {
                let value = (value: Raw.t_variousScalars).boolean;
                value;
              },
              nullableID: {
                let value = (value: Raw.t_variousScalars).nullableID;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              id: {
                let value = (value: Raw.t_variousScalars).id;
                value;
              },
            }: t_variousScalars
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let id = {
                let value = (value: t_variousScalars).id;
                value;
              }
              and nullableID = {
                let value = (value: t_variousScalars).nullableID;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and boolean = {
                let value = (value: t_variousScalars).boolean;
                value;
              }
              and nullableBoolean = {
                let value = (value: t_variousScalars).nullableBoolean;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and float = {
                let value = (value: t_variousScalars).float;
                value;
              }
              and nullableFloat = {
                let value = (value: t_variousScalars).nullableFloat;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and int = {
                let value = (value: t_variousScalars).int;
                value;
              }
              and nullableInt = {
                let value = (value: t_variousScalars).nullableInt;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and string = {
                let value = (value: t_variousScalars).string;
                value;
              }
              and nullableString = {
                let value = (value: t_variousScalars).nullableString;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_variousScalars).__typename;
                value;
              };
              {
                __typename,
                nullableString,
                string,
                nullableInt,
                int,
                nullableFloat,
                float,
                nullableBoolean,
                boolean,
                nullableID,
                id,
              };
            }: Raw.t_variousScalars
          );
        };
        {variousScalars: variousScalars};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery2 {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery3 = {
  module Raw = {
    type t_variousScalars = {
      __typename: string,
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = Js.Json.t;
  };
  %raw
  \\"let { graphql } = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      __typename\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variousScalars = {
    __typename: string,
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {
              __typename: {
                let value = (value: Raw.t_variousScalars).__typename;
                value;
              },
              nullableString: {
                let value = (value: Raw.t_variousScalars).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              string: {
                let value = (value: Raw.t_variousScalars).string;
                value;
              },
              nullableInt: {
                let value = (value: Raw.t_variousScalars).nullableInt;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              int: {
                let value = (value: Raw.t_variousScalars).int;
                value;
              },
              nullableFloat: {
                let value = (value: Raw.t_variousScalars).nullableFloat;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              float: {
                let value = (value: Raw.t_variousScalars).float;
                value;
              },
              nullableBoolean: {
                let value = (value: Raw.t_variousScalars).nullableBoolean;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              boolean: {
                let value = (value: Raw.t_variousScalars).boolean;
                value;
              },
              nullableID: {
                let value = (value: Raw.t_variousScalars).nullableID;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              id: {
                let value = (value: Raw.t_variousScalars).id;
                value;
              },
            }: t_variousScalars
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let id = {
                let value = (value: t_variousScalars).id;
                value;
              }
              and nullableID = {
                let value = (value: t_variousScalars).nullableID;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and boolean = {
                let value = (value: t_variousScalars).boolean;
                value;
              }
              and nullableBoolean = {
                let value = (value: t_variousScalars).nullableBoolean;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and float = {
                let value = (value: t_variousScalars).float;
                value;
              }
              and nullableFloat = {
                let value = (value: t_variousScalars).nullableFloat;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and int = {
                let value = (value: t_variousScalars).int;
                value;
              }
              and nullableInt = {
                let value = (value: t_variousScalars).nullableInt;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and string = {
                let value = (value: t_variousScalars).string;
                value;
              }
              and nullableString = {
                let value = (value: t_variousScalars).nullableString;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_variousScalars).__typename;
                value;
              };
              {
                __typename,
                nullableString,
                string,
                nullableInt,
                int,
                nullableFloat,
                float,
                nullableBoolean,
                boolean,
                nullableID,
                id,
              };
            }: Raw.t_variousScalars
          );
        };
        {variousScalars: variousScalars};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery3 {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery4 = {
  module Raw = {
    type t_variousScalars = {
      __typename: string,
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = Js.Json.t;
  };
  %raw
  \\"let graphql = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      __typename\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variousScalars = {
    __typename: string,
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {
              __typename: {
                let value = (value: Raw.t_variousScalars).__typename;
                value;
              },
              nullableString: {
                let value = (value: Raw.t_variousScalars).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              string: {
                let value = (value: Raw.t_variousScalars).string;
                value;
              },
              nullableInt: {
                let value = (value: Raw.t_variousScalars).nullableInt;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              int: {
                let value = (value: Raw.t_variousScalars).int;
                value;
              },
              nullableFloat: {
                let value = (value: Raw.t_variousScalars).nullableFloat;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              float: {
                let value = (value: Raw.t_variousScalars).float;
                value;
              },
              nullableBoolean: {
                let value = (value: Raw.t_variousScalars).nullableBoolean;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              boolean: {
                let value = (value: Raw.t_variousScalars).boolean;
                value;
              },
              nullableID: {
                let value = (value: Raw.t_variousScalars).nullableID;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              id: {
                let value = (value: Raw.t_variousScalars).id;
                value;
              },
            }: t_variousScalars
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let id = {
                let value = (value: t_variousScalars).id;
                value;
              }
              and nullableID = {
                let value = (value: t_variousScalars).nullableID;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and boolean = {
                let value = (value: t_variousScalars).boolean;
                value;
              }
              and nullableBoolean = {
                let value = (value: t_variousScalars).nullableBoolean;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and float = {
                let value = (value: t_variousScalars).float;
                value;
              }
              and nullableFloat = {
                let value = (value: t_variousScalars).nullableFloat;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and int = {
                let value = (value: t_variousScalars).int;
                value;
              }
              and nullableInt = {
                let value = (value: t_variousScalars).nullableInt;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and string = {
                let value = (value: t_variousScalars).string;
                value;
              }
              and nullableString = {
                let value = (value: t_variousScalars).nullableString;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_variousScalars).__typename;
                value;
              };
              {
                __typename,
                nullableString,
                string,
                nullableInt,
                int,
                nullableFloat,
                float,
                nullableBoolean,
                boolean,
                nullableID,
                id,
              };
            }: Raw.t_variousScalars
          );
        };
        {variousScalars: variousScalars};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery4 {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo typename.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_first_inner_inner = {
      __typename: string,
      field: string,
    };
    type t_first_inner = {
      __typename: string,
      inner: Js.Nullable.t(t_first_inner_inner),
    };
    type t_first = {
      __typename: string,
      inner: Js.Nullable.t(t_first_inner),
    };
    type t = {first: t_first};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_first_inner_inner = {
    __typename: string,
    field: string,
  };
  type t_first_inner = {
    __typename: string,
    inner: option(t_first_inner_inner),
  };
  type t_first = {
    __typename: string,
    inner: option(t_first_inner),
  };
  type t = {first: t_first};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        first: {
          let value = (value: Raw.t).first;
          (
            {
              __typename: {
                let value = (value: Raw.t_first).__typename;
                value;
              },
              inner: {
                let value = (value: Raw.t_first).inner;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {
                      __typename: {
                        let value = (value: Raw.t_first_inner).__typename;
                        value;
                      },
                      inner: {
                        let value = (value: Raw.t_first_inner).inner;
                        switch (Js.toOption(value)) {
                        | Some(value) =>
                          Some(
                            {
                              __typename: {
                                let value =
                                  (value: Raw.t_first_inner_inner).__typename;
                                value;
                              },
                              field: {
                                let value =
                                  (value: Raw.t_first_inner_inner).field;
                                value;
                              },
                            }: t_first_inner_inner,
                          )
                        | None => None
                        };
                      },
                    }: t_first_inner,
                  )
                | None => None
                };
              },
            }: t_first
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let first = {
          let value = (value: t).first;
          (
            {
              let inner = {
                let value = (value: t_first).inner;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {
                      let inner = {
                        let value = (value: t_first_inner).inner;
                        switch (value) {
                        | Some(value) =>
                          Js.Nullable.return(
                            {
                              let field = {
                                let value = (value: t_first_inner_inner).field;
                                value;
                              }
                              and __typename = {
                                let value =
                                  (value: t_first_inner_inner).__typename;
                                value;
                              };
                              {__typename, field};
                            }: Raw.t_first_inner_inner,
                          )
                        | None => Js.Nullable.null
                        };
                      }
                      and __typename = {
                        let value = (value: t_first_inner).__typename;
                        value;
                      };
                      {__typename, inner};
                    }: Raw.t_first_inner,
                  )
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_first).__typename;
                value;
              };
              {__typename, inner};
            }: Raw.t_first
          );
        };
        {first: first};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo union.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n__typename  \\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\n__typename  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    __typename: string,
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {
    __typename: string,
    name: string,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        dogOrHuman: {
          let value = (value: Raw.t).dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                  (
                    {
                      __typename: {
                        let value = (value: Raw.t_dogOrHuman_Dog).__typename;
                        value;
                      },
                      name: {
                        let value = (value: Raw.t_dogOrHuman_Dog).name;
                        value;
                      },
                      barkVolume: {
                        let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                        value;
                      },
                    }: t_dogOrHuman_Dog
                  );
                },
              )
            | \\"Human\\" =>
              \`Human(
                {
                  let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                  (
                    {
                      __typename: {
                        let value = (value: Raw.t_dogOrHuman_Human).__typename;
                        value;
                      },
                      name: {
                        let value = (value: Raw.t_dogOrHuman_Human).name;
                        value;
                      },
                    }: t_dogOrHuman_Human
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: t).dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {
                  let barkVolume = {
                    let value = (value: t_dogOrHuman_Dog).barkVolume;
                    value;
                  }
                  and name = {
                    let value = (value: t_dogOrHuman_Dog).name;
                    value;
                  }
                  and __typename = {
                    let value = (value: t_dogOrHuman_Dog).__typename;
                    value;
                  };
                  {__typename: \\"Dog\\", name, barkVolume};
                }: Raw.t_dogOrHuman_Dog,
              ): Raw.t_dogOrHuman
            )
          | \`Human(value) => (
              Obj.magic(
                {
                  let name = {
                    let value = (value: t_dogOrHuman_Human).name;
                    value;
                  }
                  and __typename = {
                    let value = (value: t_dogOrHuman_Human).__typename;
                    value;
                  };
                  {__typename: \\"Human\\", name};
                }: Raw.t_dogOrHuman_Human,
              ): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        };
        {dogOrHuman: dogOrHuman};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQueryNoError = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n__typename  \\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\n__typename  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    __typename: string,
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {
    __typename: string,
    name: string,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        dogOrHuman: {
          let value = (value: Raw.t).dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                  (
                    {
                      __typename: {
                        let value = (value: Raw.t_dogOrHuman_Dog).__typename;
                        value;
                      },
                      name: {
                        let value = (value: Raw.t_dogOrHuman_Dog).name;
                        value;
                      },
                      barkVolume: {
                        let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                        value;
                      },
                    }: t_dogOrHuman_Dog
                  );
                },
              )
            | \\"Human\\" =>
              \`Human(
                {
                  let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                  (
                    {
                      __typename: {
                        let value = (value: Raw.t_dogOrHuman_Human).__typename;
                        value;
                      },
                      name: {
                        let value = (value: Raw.t_dogOrHuman_Human).name;
                        value;
                      },
                    }: t_dogOrHuman_Human
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: t).dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {
                  let barkVolume = {
                    let value = (value: t_dogOrHuman_Dog).barkVolume;
                    value;
                  }
                  and name = {
                    let value = (value: t_dogOrHuman_Dog).name;
                    value;
                  }
                  and __typename = {
                    let value = (value: t_dogOrHuman_Dog).__typename;
                    value;
                  };
                  {__typename: \\"Dog\\", name, barkVolume};
                }: Raw.t_dogOrHuman_Dog,
              ): Raw.t_dogOrHuman
            )
          | \`Human(value) => (
              Obj.magic(
                {
                  let name = {
                    let value = (value: t_dogOrHuman_Human).name;
                    value;
                  }
                  and __typename = {
                    let value = (value: t_dogOrHuman_Human).__typename;
                    value;
                  };
                  {__typename: \\"Human\\", name};
                }: Raw.t_dogOrHuman_Human,
              ): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        };
        {dogOrHuman: dogOrHuman};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQueryNoError {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo unionPartial.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n__typename  \\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    __typename: string,
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        dogOrHuman: {
          let value = (value: Raw.t).dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                  (
                    {
                      __typename: {
                        let value = (value: Raw.t_dogOrHuman_Dog).__typename;
                        value;
                      },
                      name: {
                        let value = (value: Raw.t_dogOrHuman_Dog).name;
                        value;
                      },
                      barkVolume: {
                        let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                        value;
                      },
                    }: t_dogOrHuman_Dog
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: t).dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {
                  let barkVolume = {
                    let value = (value: t_dogOrHuman_Dog).barkVolume;
                    value;
                  }
                  and name = {
                    let value = (value: t_dogOrHuman_Dog).name;
                    value;
                  }
                  and __typename = {
                    let value = (value: t_dogOrHuman_Dog).__typename;
                    value;
                  };
                  {__typename: \\"Dog\\", name, barkVolume};
                }: Raw.t_dogOrHuman_Dog,
              ): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        };
        {dogOrHuman: dogOrHuman};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo variant.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_mutationForVariant_dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_mutationForVariant_human = {
      __typename: string,
      name: string,
    };
    type t_mutationForVariant_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_mutationForVariant_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_mutationForVariant_dogOrHuman;
    type t_mutationForVariant;
    type t = {mutationForVariant: t_mutationForVariant};
    type t_variables = Js.Json.t;
  };
  let query = \\"mutation   {\\\\nmutationForVariant  {\\\\nbaseType  \\\\nbaseTypeList  \\\\ndog  {\\\\n__typename  \\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\nhuman  {\\\\n__typename  \\\\nname  \\\\n}\\\\n\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n__typename  \\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\n__typename  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_mutationForVariant_dog = {
    __typename: string,
    name: string,
    barkVolume: float,
  };
  type t_mutationForVariant_human = {
    __typename: string,
    name: string,
  };
  type t_mutationForVariant_dogOrHuman_Dog = {
    __typename: string,
    name: string,
    barkVolume: float,
  };
  type t_mutationForVariant_dogOrHuman_Human = {
    __typename: string,
    name: string,
  };
  type t_mutationForVariant_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_mutationForVariant_dogOrHuman_Dog)
    | \`Human(t_mutationForVariant_dogOrHuman_Human)
  ];
  type t_mutationForVariant = [
    | \`BaseType(string)
    | \`BaseTypeList(array(string))
    | \`Dog(t_mutationForVariant_dog)
    | \`Human(t_mutationForVariant_human)
    | \`DogOrHuman(t_mutationForVariant_dogOrHuman)
  ];
  type t = {mutationForVariant: t_mutationForVariant};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        mutationForVariant: {
          let value = (value: Raw.t).mutationForVariant;
          switch (Js.Json.decodeObject(Obj.magic(value): Js.Json.t)) {
          | None =>
            Js.Exn.raiseError(
              \\"graphql_ppx: \\"
              ++ \\"Expected type \\"
              ++ \\"VariantTestResult\\"
              ++ \\" to be an object\\",
            )
          | Some(value) =>
            let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"baseType\\");
            switch (Js.Json.decodeNull(temp)) {
            | None =>
              let value = temp;
              \`BaseType(value);
            | Some(_) =>
              let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"baseTypeList\\");
              switch (Js.Json.decodeNull(temp)) {
              | None =>
                let value = temp;
                \`BaseTypeList(value |> Js.Array.map(value => value));
              | Some(_) =>
                let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"dog\\");
                switch (Js.Json.decodeNull(temp)) {
                | None =>
                  let value = temp;
                  \`Dog(
                    {
                      __typename: {
                        let value =
                          (value: Raw.t_mutationForVariant_dog).__typename;
                        value;
                      },
                      name: {
                        let value = (value: Raw.t_mutationForVariant_dog).name;
                        value;
                      },
                      barkVolume: {
                        let value =
                          (value: Raw.t_mutationForVariant_dog).barkVolume;
                        value;
                      },
                    }: t_mutationForVariant_dog,
                  );
                | Some(_) =>
                  let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"human\\");
                  switch (Js.Json.decodeNull(temp)) {
                  | None =>
                    let value = temp;
                    \`Human(
                      {
                        __typename: {
                          let value =
                            (value: Raw.t_mutationForVariant_human).__typename;
                          value;
                        },
                        name: {
                          let value =
                            (value: Raw.t_mutationForVariant_human).name;
                          value;
                        },
                      }: t_mutationForVariant_human,
                    );
                  | Some(_) =>
                    let temp =
                      Js.Dict.unsafeGet(Obj.magic(value), \\"dogOrHuman\\");
                    switch (Js.Json.decodeNull(temp)) {
                    | None =>
                      let value = temp;
                      \`DogOrHuman(
                        {
                          let typename: string =
                            Obj.magic(
                              Js.Dict.unsafeGet(
                                Obj.magic(value),
                                \\"__typename\\",
                              ),
                            );
                          (
                            switch (typename) {
                            | \\"Dog\\" =>
                              \`Dog(
                                {
                                  let value: Raw.t_mutationForVariant_dogOrHuman_Dog =
                                    Obj.magic(value);
                                  (
                                    {
                                      __typename: {
                                        let value =
                                          (
                                            value: Raw.t_mutationForVariant_dogOrHuman_Dog
                                          ).
                                            __typename;
                                        value;
                                      },
                                      name: {
                                        let value =
                                          (
                                            value: Raw.t_mutationForVariant_dogOrHuman_Dog
                                          ).
                                            name;
                                        value;
                                      },
                                      barkVolume: {
                                        let value =
                                          (
                                            value: Raw.t_mutationForVariant_dogOrHuman_Dog
                                          ).
                                            barkVolume;
                                        value;
                                      },
                                    }: t_mutationForVariant_dogOrHuman_Dog
                                  );
                                },
                              )
                            | \\"Human\\" =>
                              \`Human(
                                {
                                  let value: Raw.t_mutationForVariant_dogOrHuman_Human =
                                    Obj.magic(value);
                                  (
                                    {
                                      __typename: {
                                        let value =
                                          (
                                            value: Raw.t_mutationForVariant_dogOrHuman_Human
                                          ).
                                            __typename;
                                        value;
                                      },
                                      name: {
                                        let value =
                                          (
                                            value: Raw.t_mutationForVariant_dogOrHuman_Human
                                          ).
                                            name;
                                        value;
                                      },
                                    }: t_mutationForVariant_dogOrHuman_Human
                                  );
                                },
                              )
                            | _ =>
                              \`FutureAddedValue(Obj.magic(value): Js.Json.t)
                            }: t_mutationForVariant_dogOrHuman
                          );
                        },
                      );
                    | Some(_) =>
                      Js.Exn.raiseError(
                        \\"graphql_ppx: \\"
                        ++ \\"All fields on variant selection set on type \\"
                        ++ \\"VariantTestResult\\"
                        ++ \\" were null\\",
                      )
                    };
                  };
                };
              };
            };
          };
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let mutationForVariant = {
          let value = (value: t).mutationForVariant;
          Obj.magic(Js.Json.null);
        };
        {mutationForVariant: mutationForVariant};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Compilation (Objects) argNamedQuery.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          argNamedQuery: value.argNamedQuery
        };
}

function serialize(value) {
  return {
          argNamedQuery: value.argNamedQuery
        };
}

function serializeVariables(inp) {
  return {
          query: inp.query
        };
}

function makeVariables(query, param) {
  return serializeVariables({
              query: query
            });
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($query: Int!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) comment.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require(\\"bs-platform/lib/js/array.js\\");
var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

function parse(value) {
  return {
          nonrecursiveInput: value.nonrecursiveInput
        };
}

function serialize(value) {
  return {
          nonrecursiveInput: value.nonrecursiveInput
        };
}

function serializeInputObjectEmbeddedInput(inp) {
  var a = inp.field;
  return {
          field: a !== undefined ? a : undefined
        };
}

function serializeInputObjectNonrecursiveInput(inp) {
  var a = inp.nullableArray;
  var tmp;
  if (a !== undefined) {
    var a$1 = a;
    tmp = $$Array.map((function (b) {
            if (b !== undefined) {
              return b;
            }
            
          }), a$1);
  } else {
    tmp = undefined;
  }
  var a$2 = inp.field;
  var a$3 = inp.enum;
  var tmp$1;
  if (a$3 !== undefined) {
    var a$4 = a$3;
    tmp$1 = a$4 !== 225952583 ? (
        a$4 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
      ) : \\"THIRD\\";
  } else {
    tmp$1 = undefined;
  }
  var a$5 = inp.embeddedInput;
  var tmp$2;
  if (a$5 !== undefined) {
    var a$6 = a$5;
    tmp$2 = $$Array.map((function (b) {
            if (b !== undefined) {
              return serializeInputObjectEmbeddedInput(Caml_option.valFromOption(b));
            }
            
          }), a$6);
  } else {
    tmp$2 = undefined;
  }
  var a$7 = inp.custom;
  return {
          nonNullableField: inp.nonNullableField,
          nullableArray: tmp,
          field: a$2 !== undefined ? a$2 : undefined,
          enum: tmp$1,
          embeddedInput: tmp$2,
          custom: a$7 !== undefined ? Caml_option.valFromOption(a$7) : undefined
        };
}

function serializeVariables(inp) {
  return {
          arg: serializeInputObjectNonrecursiveInput(inp.arg)
        };
}

function makeVariables(arg, param) {
  return serializeVariables({
              arg: arg
            });
}

function makeInputObjectNonrecursiveInput(nonNullableField, nullableArray, field, $$enum, embeddedInput, custom, param) {
  return {
          nonNullableField: nonNullableField,
          nullableArray: nullableArray,
          field: field,
          enum: $$enum,
          embeddedInput: embeddedInput,
          custom: custom
        };
}

function makeInputObjectEmbeddedInput(field, param) {
  return {
          field: field
        };
}

var Z__INTERNAL = {
  _graphql_NonrecursiveInput_49: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  serializeInputObjectNonrecursiveInput: serializeInputObjectNonrecursiveInput,
  serializeInputObjectEmbeddedInput: serializeInputObjectEmbeddedInput,
  makeVariables: makeVariables,
  makeInputObjectNonrecursiveInput: makeInputObjectNonrecursiveInput,
  makeInputObjectEmbeddedInput: makeInputObjectEmbeddedInput,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) customDecoder.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_format = require(\\"bs-platform/lib/js/caml_format.js\\");

function parse(prim) {
  return String(prim);
}

var serialize = Caml_format.caml_int_of_string;

var StringOfInt = {
  parse: parse,
  serialize: serialize
};

var parse$1 = Caml_format.caml_int_of_string;

function serialize$1(prim) {
  return String(prim);
}

var IntOfString = {
  parse: parse$1,
  serialize: serialize$1
};

var Raw = { };

function parse$2(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.int;
  var $$int = String(value$2);
  var value$3 = value$1.string;
  var string = Caml_format.caml_int_of_string(value$3);
  return {
          variousScalars: {
            string: string,
            int: $$int
          }
        };
}

function serialize$2(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.int;
  var $$int = Caml_format.caml_int_of_string(value$2);
  var value$3 = value$1.string;
  var string = String(value$3);
  return {
          variousScalars: {
            string: string,
            int: $$int
          }
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$2,
  serialize: serialize$2,
  Z__INTERNAL: Z__INTERNAL
};

exports.StringOfInt = StringOfInt;
exports.IntOfString = IntOfString;
exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) customScalars.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

function parse(value) {
  var value$1 = value.customScalarField;
  var value$2 = value$1.nonNullable;
  var value$3 = value$1.nullable;
  var nullable = (value$3 == null) ? undefined : Caml_option.some(value$3);
  return {
          customScalarField: {
            nullable: nullable,
            nonNullable: value$2
          }
        };
}

function serialize(value) {
  var value$1 = value.customScalarField;
  var value$2 = value$1.nonNullable;
  var value$3 = value$1.nullable;
  var nullable = value$3 !== undefined ? Caml_option.valFromOption(value$3) : null;
  return {
          customScalarField: {
            nullable: nullable,
            nonNullable: value$2
          }
        };
}

function serializeVariables(inp) {
  var a = inp.opt;
  return {
          opt: a !== undefined ? Caml_option.valFromOption(a) : undefined,
          req: inp.req
        };
}

function makeVariables(opt, req, param) {
  return serializeVariables({
              opt: opt,
              req: req
            });
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($opt: CustomScalar, $req: CustomScalar!)  {\\\\ncustomScalarField(argOptional: $opt, argRequired: $req)  {\\\\nnullable  \\\\nnonNullable  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) customTypes.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Js_json = require(\\"bs-platform/lib/js/js_json.js\\");
var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

function parse(json) {
  var match = Js_json.decodeString(json);
  if (match !== undefined) {
    switch (match) {
      case \\"blue\\" :
          return /* Blue */2;
      case \\"green\\" :
          return /* Green */1;
      case \\"red\\" :
          return /* Red */0;
      default:
        return /* Red */0;
    }
  } else {
    return /* Red */0;
  }
}

function serialize(color) {
  switch (color) {
    case /* Red */0 :
        return \\"red\\";
    case /* Green */1 :
        return \\"green\\";
    case /* Blue */2 :
        return \\"blue\\";
    
  }
}

var Color = {
  parse: parse,
  serialize: serialize
};

function parse$1(json) {
  var match = Js_json.decodeString(json);
  if (match !== undefined) {
    return new Date(match);
  } else {
    return new Date();
  }
}

function serialize$1(date) {
  return date.toISOString();
}

var DateTime = {
  parse: parse$1,
  serialize: serialize$1
};

var Raw = { };

function parse$2(value) {
  var value$1 = value.customFields;
  var value$2 = value$1.nullableColor;
  var nullableColor = (value$2 == null) ? undefined : parse(value$2);
  var value$3 = value$1.futureTime;
  var futureTime = (value$3 == null) ? undefined : Caml_option.some(parse$1(value$3));
  var value$4 = value$1.favoriteColor;
  var favoriteColor = parse(value$4);
  var value$5 = value$1.currentTime;
  var currentTime = parse$1(value$5);
  return {
          customFields: {
            currentTime: currentTime,
            favoriteColor: favoriteColor,
            futureTime: futureTime,
            nullableColor: nullableColor
          }
        };
}

function serialize$2(value) {
  var value$1 = value.customFields;
  var value$2 = value$1.nullableColor;
  var nullableColor = value$2 !== undefined ? serialize(value$2) : null;
  var value$3 = value$1.futureTime;
  var futureTime = value$3 !== undefined ? Caml_option.valFromOption(value$3).toISOString() : null;
  var value$4 = value$1.favoriteColor;
  var favoriteColor = serialize(value$4);
  var value$5 = value$1.currentTime;
  var currentTime = value$5.toISOString();
  return {
          customFields: {
            currentTime: currentTime,
            favoriteColor: favoriteColor,
            futureTime: futureTime,
            nullableColor: nullableColor
          }
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\ncustomFields  {\\\\ncurrentTime  \\\\nfavoriteColor  \\\\nfutureTime  \\\\nnullableColor  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$2,
  serialize: serialize$2,
  Z__INTERNAL: Z__INTERNAL
};

exports.Color = Color;
exports.DateTime = DateTime;
exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) defaultObjectValueOnScalar.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          defaultObjectValueOnScalar: value.defaultObjectValueOnScalar
        };
}

function serialize(value) {
  return {
          defaultObjectValueOnScalar: value.defaultObjectValueOnScalar
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\ndefaultObjectValueOnScalar(filter: {some: {json: \\\\\\"value\\\\\\"}}, arg: {field: \\\\\\"otherValue\\\\\\"})  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) enumInput.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          enumInput: value.enumInput
        };
}

function serialize(value) {
  return {
          enumInput: value.enumInput
        };
}

function serializeVariables(inp) {
  var a = inp.arg;
  return {
          arg: a !== 225952583 ? (
              a >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
            ) : \\"THIRD\\"
        };
}

function makeVariables(arg, param) {
  return serializeVariables({
              arg: arg
            });
}

var Z__INTERNAL = {
  _graphql_SampleField_47: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($arg: SampleField!)  {\\\\nenumInput(arg: $arg)  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) explicit_object_record.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nullableOfNullable;
  var value$3 = value$1.nullableOfNonNullable;
  var value$4 = value$1.nonNullableOfNullable;
  var value$5 = value$1.nonNullableOfNonNullable;
  return {
          lists: {
            nullableOfNullable: (value$2 == null) ? undefined : value$2.map((function (value) {
                      if (value == null) {
                        return ;
                      } else {
                        return value;
                      }
                    })),
            nullableOfNonNullable: (value$3 == null) ? undefined : value$3.map((function (value) {
                      return value;
                    })),
            nonNullableOfNullable: value$4.map((function (value) {
                    if (value == null) {
                      return ;
                    } else {
                      return value;
                    }
                  })),
            nonNullableOfNonNullable: value$5.map((function (value) {
                    return value;
                  }))
          }
        };
}

function serialize(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (value !== undefined) {
            return value;
          } else {
            return null;
          }
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = value$4 !== undefined ? value$4.map((function (value) {
            return value;
          })) : null;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = value$5 !== undefined ? value$5.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  var lists = {
    nullableOfNullable: nullableOfNullable,
    nullableOfNonNullable: nullableOfNonNullable,
    nonNullableOfNullable: nonNullableOfNullable,
    nonNullableOfNonNullable: nonNullableOfNonNullable
  };
  return {
          lists: lists
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var RecordsQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (value == null) {
            return ;
          } else {
            return value;
          }
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = (value$4 == null) ? undefined : value$4.map((function (value) {
            return value;
          }));
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = (value$5 == null) ? undefined : value$5.map((function (value) {
            if (value == null) {
              return ;
            } else {
              return value;
            }
          }));
  return {
          lists: {
            nullableOfNullable: nullableOfNullable,
            nullableOfNonNullable: nullableOfNonNullable,
            nonNullableOfNullable: nonNullableOfNullable,
            nonNullableOfNonNullable: nonNullableOfNonNullable
          }
        };
}

function serialize$1(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (value !== undefined) {
            return value;
          } else {
            return null;
          }
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = value$4 !== undefined ? value$4.map((function (value) {
            return value;
          })) : null;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = value$5 !== undefined ? value$5.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  return {
          lists: {
            nullableOfNullable: nullableOfNullable,
            nullableOfNonNullable: nullableOfNonNullable,
            nonNullableOfNullable: nonNullableOfNullable,
            nonNullableOfNonNullable: nonNullableOfNonNullable
          }
        };
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var ObjectsQuery = {
  Raw: Raw$1,
  query: \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$1,
  serialize: serialize$1,
  Z__INTERNAL: Z__INTERNAL$1
};

exports.RecordsQuery = RecordsQuery;
exports.ObjectsQuery = ObjectsQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) extensions.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


function ExtendQuery(M) {
  var use = function (param) {
    return /* () */0;
  };
  return {
          use: use
        };
}

var Raw = { };

var query = \\"query Bla  {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";

function parse(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (value == null) {
            return ;
          } else {
            return value;
          }
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = (value$4 == null) ? undefined : value$4.map((function (value) {
            return value;
          }));
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = (value$5 == null) ? undefined : value$5.map((function (value) {
            if (value == null) {
              return ;
            } else {
              return value;
            }
          }));
  return {
          lists: {
            nullableOfNullable: nullableOfNullable,
            nullableOfNonNullable: nullableOfNonNullable,
            nonNullableOfNullable: nonNullableOfNullable,
            nonNullableOfNonNullable: nonNullableOfNonNullable
          }
        };
}

function serialize(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (value !== undefined) {
            return value;
          } else {
            return null;
          }
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = value$4 !== undefined ? value$4.map((function (value) {
            return value;
          })) : null;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = value$5 !== undefined ? value$5.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  return {
          lists: {
            nullableOfNullable: nullableOfNullable,
            nullableOfNonNullable: nullableOfNonNullable,
            nonNullableOfNullable: nonNullableOfNullable,
            nonNullableOfNonNullable: nonNullableOfNonNullable
          }
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var Bla$prime = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

function use(param) {
  return /* () */0;
}

var Bla = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL,
  use: use
};

exports.ExtendQuery = ExtendQuery;
exports.Bla$prime = Bla$prime;
exports.Bla = Bla;
/* No side effect */
"
`;

exports[`Compilation (Objects) fragmentDefinition.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var GraphQL_PPX = require(\\"../utilities/GraphQL_PPX.bs.js\\");

var query = \\"fragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";

var Raw = { };

function parse(value) {
  var value$1 = value.nullableOfNonNullable;
  var nullableOfNonNullable = (value$1 == null) ? undefined : value$1.map((function (value) {
            return value;
          }));
  var value$2 = value.nullableOfNullable;
  var nullableOfNullable = (value$2 == null) ? undefined : value$2.map((function (value) {
            if (value == null) {
              return ;
            } else {
              return value;
            }
          }));
  return {
          nullableOfNullable: nullableOfNullable,
          nullableOfNonNullable: nullableOfNonNullable
        };
}

function serialize(value) {
  var value$1 = value.nullableOfNonNullable;
  var nullableOfNonNullable = value$1 !== undefined ? value$1.map((function (value) {
            return value;
          })) : null;
  var value$2 = value.nullableOfNullable;
  var nullableOfNullable = value$2 !== undefined ? value$2.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  return {
          nullableOfNullable: nullableOfNullable,
          nullableOfNonNullable: nullableOfNonNullable
        };
}

var name = \\"ListFragment\\";

var Z__INTERNAL = {
  graphql: 0,
  graphql_module: 0
};

var ListFragment = {
  query: query,
  Raw: Raw,
  parse: parse,
  serialize: serialize,
  name: name,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  var value$1 = value.nullableOfNonNullable;
  return {
          nullableOfNonNullable: (value$1 == null) ? undefined : value$1.map((function (value) {
                    return value;
                  }))
        };
}

function serialize$1(value) {
  var value$1 = value.nullableOfNonNullable;
  return {
          nullableOfNonNullable: value$1 !== undefined ? value$1.map((function (value) {
                    return value;
                  })) : null
        };
}

var Z__INTERNAL$1 = {
  graphql: 0,
  graphql_module: 0
};

var Another = {
  query: \\"fragment Another on Lists   {\\\\nnullableOfNonNullable  \\\\n}\\\\n\\",
  Raw: Raw$1,
  parse: parse$1,
  serialize: serialize$1,
  name: \\"Another\\",
  Z__INTERNAL: Z__INTERNAL$1
};

var Fragments = {
  ListFragment: ListFragment,
  Another: Another
};

var Raw$2 = { };

var query$1 = \\"query   {\\\\nl1: lists  {\\\\n...ListFragment   \\\\n}\\\\n\\\\nl2: lists  {\\\\n...ListFragment   \\\\n...ListFragment   \\\\n}\\\\n\\\\nl3: lists  {\\\\nnullableOfNullable  \\\\n...ListFragment   \\\\n...ListFragment   \\\\n}\\\\n\\\\nl4: lists  {\\\\nnullableOfNullable  \\\\n...ListFragment   \\\\n}\\\\n\\\\n}\\\\nfragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";

function parse$2(value) {
  var value$1 = value.l4;
  var listFragment = parse(value$1);
  var value$2 = value$1[\\"nullableOfNullable\\"];
  var nullableOfNullable = (value$2 == null) ? undefined : value$2.map((function (value) {
            if (value == null) {
              return ;
            } else {
              return value;
            }
          }));
  var l4 = {
    nullableOfNullable: nullableOfNullable,
    listFragment: listFragment
  };
  var value$3 = value.l3;
  var frag2 = parse(value$3);
  var frag1 = parse(value$3);
  var value$4 = value$3[\\"nullableOfNullable\\"];
  var nullableOfNullable$1 = (value$4 == null) ? undefined : value$4.map((function (value) {
            if (value == null) {
              return ;
            } else {
              return value;
            }
          }));
  var l3 = {
    nullableOfNullable: nullableOfNullable$1,
    frag1: frag1,
    frag2: frag2
  };
  var value$5 = value.l2;
  var frag2$1 = parse(value$5);
  var frag1$1 = parse(value$5);
  var l2 = {
    frag1: frag1$1,
    frag2: frag2$1
  };
  var value$6 = value.l1;
  var l1 = parse(value$6);
  return {
          l1: l1,
          l2: l2,
          l3: l3,
          l4: l4
        };
}

function serialize$2(value) {
  var value$1 = value.l4;
  var value$2 = value$1.nullableOfNullable;
  var l4 = [serialize(value$1.listFragment)].reduce(GraphQL_PPX.deepMerge, {
        nullableOfNullable: value$2 !== undefined ? value$2.map((function (value) {
                  if (value !== undefined) {
                    return value;
                  } else {
                    return null;
                  }
                })) : null
      });
  var value$3 = value.l3;
  var value$4 = value$3.nullableOfNullable;
  var l3 = [
      serialize(value$3.frag1),
      serialize(value$3.frag2)
    ].reduce(GraphQL_PPX.deepMerge, {
        nullableOfNullable: value$4 !== undefined ? value$4.map((function (value) {
                  if (value !== undefined) {
                    return value;
                  } else {
                    return null;
                  }
                })) : null
      });
  var value$5 = value.l2;
  var l2 = [
      serialize(value$5.frag1),
      serialize(value$5.frag2)
    ].reduce(GraphQL_PPX.deepMerge, (function (prim) {
          return { };
        }));
  var value$6 = value.l1;
  var l1 = serialize(value$6);
  return {
          l1: l1,
          l2: l2,
          l3: l3,
          l4: l4
        };
}

var Z__INTERNAL$2 = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw$2,
  query: query$1,
  parse: parse$2,
  serialize: serialize$2,
  Z__INTERNAL: Z__INTERNAL$2
};

var Raw$3 = { };

var query$2 = \\"query   {\\\\nlists  {\\\\n...ListFragment   \\\\n}\\\\n\\\\n}\\\\nfragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";

function parse$3(value) {
  var value$1 = value.lists;
  return {
          lists: parse(value$1)
        };
}

function serialize$3(value) {
  var value$1 = value.lists;
  return {
          lists: serialize(value$1)
        };
}

var Z__INTERNAL$3 = {
  graphql_module: 0
};

var MyQuery2 = {
  Raw: Raw$3,
  query: query$2,
  parse: parse$3,
  serialize: serialize$3,
  Z__INTERNAL: Z__INTERNAL$3
};

exports.Fragments = Fragments;
exports.MyQuery = MyQuery;
exports.MyQuery2 = MyQuery2;
/* No side effect */
"
`;

exports[`Compilation (Objects) interface.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
"
`;

exports[`Compilation (Objects) lists.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (value == null) {
            return ;
          } else {
            return value;
          }
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = (value$4 == null) ? undefined : value$4.map((function (value) {
            return value;
          }));
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = (value$5 == null) ? undefined : value$5.map((function (value) {
            if (value == null) {
              return ;
            } else {
              return value;
            }
          }));
  return {
          lists: {
            nullableOfNullable: nullableOfNullable,
            nullableOfNonNullable: nullableOfNonNullable,
            nonNullableOfNullable: nonNullableOfNullable,
            nonNullableOfNonNullable: nonNullableOfNonNullable
          }
        };
}

function serialize(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (value !== undefined) {
            return value;
          } else {
            return null;
          }
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = value$4 !== undefined ? value$4.map((function (value) {
            return value;
          })) : null;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = value$5 !== undefined ? value$5.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  return {
          lists: {
            nullableOfNullable: nullableOfNullable,
            nullableOfNonNullable: nullableOfNonNullable,
            nonNullableOfNullable: nonNullableOfNullable,
            nonNullableOfNonNullable: nonNullableOfNonNullable
          }
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) listsArgs.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require(\\"bs-platform/lib/js/array.js\\");

var Raw = { };

function parse(value) {
  return {
          listsInput: value.listsInput
        };
}

function serialize(value) {
  return {
          listsInput: value.listsInput
        };
}

function serializeVariables(inp) {
  var a = inp.nullableOfNullable;
  var tmp;
  if (a !== undefined) {
    var a$1 = a;
    tmp = $$Array.map((function (b) {
            if (b !== undefined) {
              return b;
            }
            
          }), a$1);
  } else {
    tmp = undefined;
  }
  var a$2 = inp.nullableOfNonNullable;
  var tmp$1;
  if (a$2 !== undefined) {
    var a$3 = a$2;
    tmp$1 = $$Array.map((function (b) {
            return b;
          }), a$3);
  } else {
    tmp$1 = undefined;
  }
  var a$4 = inp.nonNullableOfNullable;
  var a$5 = inp.nonNullableOfNonNullable;
  return {
          nullableOfNullable: tmp,
          nullableOfNonNullable: tmp$1,
          nonNullableOfNullable: $$Array.map((function (b) {
                  if (b !== undefined) {
                    return b;
                  }
                  
                }), a$4),
          nonNullableOfNonNullable: $$Array.map((function (b) {
                  return b;
                }), a$5)
        };
}

function makeVariables(nullableOfNullable, nullableOfNonNullable, nonNullableOfNullable, nonNullableOfNonNullable, param) {
  return serializeVariables({
              nullableOfNullable: nullableOfNullable,
              nullableOfNonNullable: nullableOfNonNullable,
              nonNullableOfNullable: nonNullableOfNullable,
              nonNullableOfNonNullable: nonNullableOfNonNullable
            });
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($nullableOfNullable: [String], $nullableOfNonNullable: [String!], $nonNullableOfNullable: [String]!, $nonNullableOfNonNullable: [String!]!)  {\\\\nlistsInput(arg: {nullableOfNullable: $nullableOfNullable, nullableOfNonNullable: $nullableOfNonNullable, nonNullableOfNullable: $nonNullableOfNullable, nonNullableOfNonNullable: $nonNullableOfNonNullable})  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) listsInput.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require(\\"bs-platform/lib/js/array.js\\");

var Raw = { };

function parse(value) {
  return {
          listsInput: value.listsInput
        };
}

function serialize(value) {
  return {
          listsInput: value.listsInput
        };
}

function serializeInputObjectListsInput(inp) {
  var a = inp.nullableOfNullable;
  var tmp;
  if (a !== undefined) {
    var a$1 = a;
    tmp = $$Array.map((function (b) {
            if (b !== undefined) {
              return b;
            }
            
          }), a$1);
  } else {
    tmp = undefined;
  }
  var a$2 = inp.nullableOfNonNullable;
  var tmp$1;
  if (a$2 !== undefined) {
    var a$3 = a$2;
    tmp$1 = $$Array.map((function (b) {
            return b;
          }), a$3);
  } else {
    tmp$1 = undefined;
  }
  var a$4 = inp.nonNullableOfNullable;
  var a$5 = inp.nonNullableOfNonNullable;
  return {
          nullableOfNullable: tmp,
          nullableOfNonNullable: tmp$1,
          nonNullableOfNullable: $$Array.map((function (b) {
                  if (b !== undefined) {
                    return b;
                  }
                  
                }), a$4),
          nonNullableOfNonNullable: $$Array.map((function (b) {
                  return b;
                }), a$5)
        };
}

function serializeVariables(inp) {
  return {
          arg: serializeInputObjectListsInput(inp.arg)
        };
}

function makeVariables(arg, param) {
  return serializeVariables({
              arg: arg
            });
}

function makeInputObjectListsInput(nullableOfNullable, nullableOfNonNullable, nonNullableOfNullable, nonNullableOfNonNullable, param) {
  return {
          nullableOfNullable: nullableOfNullable,
          nullableOfNonNullable: nullableOfNonNullable,
          nonNullableOfNullable: nonNullableOfNullable,
          nonNullableOfNonNullable: nonNullableOfNonNullable
        };
}

var Z__INTERNAL = {
  _graphql_ListsInput_47: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($arg: ListsInput!)  {\\\\nlistsInput(arg: $arg)  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  serializeInputObjectListsInput: serializeInputObjectListsInput,
  makeVariables: makeVariables,
  makeInputObjectListsInput: makeInputObjectListsInput,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) mutation.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

function parse(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  var errors = (value$2 == null) ? undefined : value$2.map((function (value) {
            var value$1 = value.message;
            var value$2 = value.field;
            var field;
            switch (value$2) {
              case \\"FIRST\\" :
                  field = /* FIRST */-24399856;
                  break;
              case \\"SECOND\\" :
                  field = /* SECOND */382368628;
                  break;
              case \\"THIRD\\" :
                  field = /* THIRD */225952583;
                  break;
              default:
                field = /* \`FutureAddedValue */[
                  -31101740,
                  value$2
                ];
            }
            return {
                    field: field,
                    message: value$1
                  };
          }));
  var value$3 = value$1.value;
  var value$4 = (value$3 == null) ? undefined : ({
        stringField: value$3.stringField
      });
  return {
          mutationWithError: {
            value: value$4,
            errors: errors
          }
        };
}

function serialize(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  var errors = value$2 !== undefined ? value$2.map((function (value) {
            var value$1 = value.message;
            var value$2 = value.field;
            var field = typeof value$2 === \\"number\\" ? (
                value$2 !== 225952583 ? (
                    value$2 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
                  ) : \\"THIRD\\"
              ) : value$2[1];
            return {
                    field: field,
                    message: value$1
                  };
          })) : null;
  var value$3 = value$1.value;
  var value$4 = value$3 !== undefined ? ({
        stringField: Caml_option.valFromOption(value$3).stringField
      }) : null;
  return {
          mutationWithError: {
            value: value$4,
            errors: errors
          }
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"mutation   {\\\\nmutationWithError  {\\\\nvalue  {\\\\nstringField  \\\\n}\\\\n\\\\nerrors  {\\\\nfield  \\\\nmessage  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) mutationWithArgs.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          optionalInputArgs: value.optionalInputArgs
        };
}

function serialize(value) {
  return {
          optionalInputArgs: value.optionalInputArgs
        };
}

function serializeVariables(inp) {
  return {
          required: inp.required
        };
}

function makeVariables(required, param) {
  return serializeVariables({
              required: required
            });
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) mutationWithArgsAndNoRecords.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          optionalInputArgs: value.optionalInputArgs
        };
}

function serialize(value) {
  return {
          optionalInputArgs: value.optionalInputArgs
        };
}

function serializeVariables(inp) {
  return {
          required: inp.required
        };
}

function makeVariables(required, param) {
  return serializeVariables({
              required: required
            });
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) nested.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

function parse(value) {
  var value$1 = value.let_;
  var value$2 = value$1.inner;
  var inner;
  if (value$2 == null) {
    inner = undefined;
  } else {
    var value$3 = value$2.inner;
    inner = {
      inner: (value$3 == null) ? undefined : ({
            field: value$3.field
          })
    };
  }
  var let_ = {
    inner: inner
  };
  var value$4 = value.second;
  var value$5 = value$4.inner;
  var inner$1;
  if (value$5 == null) {
    inner$1 = undefined;
  } else {
    var value$6 = value$5.inner;
    var tmp;
    if (value$6 == null) {
      tmp = undefined;
    } else {
      var value$7 = value$6.f2;
      var value$8 = value$6.f1;
      tmp = {
        f1: value$8,
        f2: value$7
      };
    }
    inner$1 = {
      inner: tmp
    };
  }
  var second = {
    inner: inner$1
  };
  var value$9 = value.first;
  var value$10 = value$9.inner;
  var inner$2;
  if (value$10 == null) {
    inner$2 = undefined;
  } else {
    var value$11 = value$10.inner;
    inner$2 = {
      inner: (value$11 == null) ? undefined : ({
            field: value$11.field
          })
    };
  }
  var first = {
    inner: inner$2
  };
  return {
          first: first,
          second: second,
          let_: let_
        };
}

function serialize(value) {
  var value$1 = value.let_;
  var value$2 = value$1.inner;
  var inner;
  if (value$2 !== undefined) {
    var value$3 = Caml_option.valFromOption(value$2).inner;
    inner = {
      inner: value$3 !== undefined ? ({
            field: Caml_option.valFromOption(value$3).field
          }) : null
    };
  } else {
    inner = null;
  }
  var let_ = {
    inner: inner
  };
  var value$4 = value.second;
  var value$5 = value$4.inner;
  var inner$1;
  if (value$5 !== undefined) {
    var value$6 = Caml_option.valFromOption(value$5).inner;
    var tmp;
    if (value$6 !== undefined) {
      var value$7 = value$6;
      var value$8 = value$7.f2;
      var value$9 = value$7.f1;
      tmp = {
        f1: value$9,
        f2: value$8
      };
    } else {
      tmp = null;
    }
    inner$1 = {
      inner: tmp
    };
  } else {
    inner$1 = null;
  }
  var second = {
    inner: inner$1
  };
  var value$10 = value.first;
  var value$11 = value$10.inner;
  var inner$2;
  if (value$11 !== undefined) {
    var value$12 = Caml_option.valFromOption(value$11).inner;
    inner$2 = {
      inner: value$12 !== undefined ? ({
            field: Caml_option.valFromOption(value$12).field
          }) : null
    };
  } else {
    inner$2 = null;
  }
  var first = {
    inner: inner$2
  };
  return {
          first: first,
          second: second,
          let_: let_
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nfirst: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nsecond: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nf1: field  \\\\nf2: field  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nlet: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) nonrecursiveInput.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require(\\"bs-platform/lib/js/array.js\\");
var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

function parse(value) {
  return {
          nonrecursiveInput: value.nonrecursiveInput
        };
}

function serialize(value) {
  return {
          nonrecursiveInput: value.nonrecursiveInput
        };
}

function serializeInputObjectEmbeddedInput(inp) {
  var a = inp.field;
  return {
          field: a !== undefined ? a : undefined
        };
}

function serializeInputObjectNonrecursiveInput(inp) {
  var a = inp.nullableArray;
  var tmp;
  if (a !== undefined) {
    var a$1 = a;
    tmp = $$Array.map((function (b) {
            if (b !== undefined) {
              return b;
            }
            
          }), a$1);
  } else {
    tmp = undefined;
  }
  var a$2 = inp.field;
  var a$3 = inp.enum;
  var tmp$1;
  if (a$3 !== undefined) {
    var a$4 = a$3;
    tmp$1 = a$4 !== 225952583 ? (
        a$4 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
      ) : \\"THIRD\\";
  } else {
    tmp$1 = undefined;
  }
  var a$5 = inp.embeddedInput;
  var tmp$2;
  if (a$5 !== undefined) {
    var a$6 = a$5;
    tmp$2 = $$Array.map((function (b) {
            if (b !== undefined) {
              return serializeInputObjectEmbeddedInput(Caml_option.valFromOption(b));
            }
            
          }), a$6);
  } else {
    tmp$2 = undefined;
  }
  var a$7 = inp.custom;
  return {
          nonNullableField: inp.nonNullableField,
          nullableArray: tmp,
          field: a$2 !== undefined ? a$2 : undefined,
          enum: tmp$1,
          embeddedInput: tmp$2,
          custom: a$7 !== undefined ? Caml_option.valFromOption(a$7) : undefined
        };
}

function serializeVariables(inp) {
  return {
          arg: serializeInputObjectNonrecursiveInput(inp.arg)
        };
}

function makeVariables(arg, param) {
  return serializeVariables({
              arg: arg
            });
}

function makeInputObjectNonrecursiveInput(nonNullableField, nullableArray, field, $$enum, embeddedInput, custom, param) {
  return {
          nonNullableField: nonNullableField,
          nullableArray: nullableArray,
          field: field,
          enum: $$enum,
          embeddedInput: embeddedInput,
          custom: custom
        };
}

function makeInputObjectEmbeddedInput(field, param) {
  return {
          field: field
        };
}

var Z__INTERNAL = {
  _graphql_NonrecursiveInput_49: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  serializeInputObjectNonrecursiveInput: serializeInputObjectNonrecursiveInput,
  serializeInputObjectEmbeddedInput: serializeInputObjectEmbeddedInput,
  makeVariables: makeVariables,
  makeInputObjectNonrecursiveInput: makeInputObjectNonrecursiveInput,
  makeInputObjectEmbeddedInput: makeInputObjectEmbeddedInput,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  var value$1 = value.more;
  var value$2 = value.scalarsInput;
  return {
          scalarsInput: value$2,
          more: value$1
        };
}

function serialize$1(value) {
  var value$1 = value.more;
  var value$2 = value.scalarsInput;
  return {
          scalarsInput: value$2,
          more: value$1
        };
}

function serializeInputObjectEmbeddedInput$1(inp) {
  var a = inp.field;
  return {
          field: a !== undefined ? a : undefined
        };
}

function serializeInputObjectNonrecursiveInput$1(inp) {
  var a = inp.nullableArray;
  var tmp;
  if (a !== undefined) {
    var a$1 = a;
    tmp = $$Array.map((function (b) {
            if (b !== undefined) {
              return b;
            }
            
          }), a$1);
  } else {
    tmp = undefined;
  }
  var a$2 = inp.field;
  var a$3 = inp.enum;
  var tmp$1;
  if (a$3 !== undefined) {
    var a$4 = a$3;
    tmp$1 = a$4 !== 225952583 ? (
        a$4 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
      ) : \\"THIRD\\";
  } else {
    tmp$1 = undefined;
  }
  var a$5 = inp.embeddedInput;
  var tmp$2;
  if (a$5 !== undefined) {
    var a$6 = a$5;
    tmp$2 = $$Array.map((function (b) {
            if (b !== undefined) {
              return serializeInputObjectEmbeddedInput$1(Caml_option.valFromOption(b));
            }
            
          }), a$6);
  } else {
    tmp$2 = undefined;
  }
  var a$7 = inp.custom;
  return {
          nonNullableField: inp.nonNullableField,
          nullableArray: tmp,
          field: a$2 !== undefined ? a$2 : undefined,
          enum: tmp$1,
          embeddedInput: tmp$2,
          custom: a$7 !== undefined ? Caml_option.valFromOption(a$7) : undefined
        };
}

function serializeVariables$1(inp) {
  return {
          arg: serializeInputObjectNonrecursiveInput$1(inp.arg),
          arg2: serializeInputObjectNonrecursiveInput$1(inp.arg2)
        };
}

function makeVariables$1(arg, arg2, param) {
  return serializeVariables$1({
              arg: arg,
              arg2: arg2
            });
}

function makeInputObjectNonrecursiveInput$1(nonNullableField, nullableArray, field, $$enum, embeddedInput, custom, param) {
  return {
          nonNullableField: nonNullableField,
          nullableArray: nullableArray,
          field: field,
          enum: $$enum,
          embeddedInput: embeddedInput,
          custom: custom
        };
}

function makeInputObjectEmbeddedInput$1(field, param) {
  return {
          field: field
        };
}

var Z__INTERNAL$1 = {
  _graphql_NonrecursiveInput_169: 0,
  _graphql_NonrecursiveInput_196: 0,
  graphql_module: 0
};

var MyQuery2 = {
  Raw: Raw$1,
  query: \\"query ($arg: NonrecursiveInput!, $arg2: NonrecursiveInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\nmore: scalarsInput(arg: $arg2)  \\\\n}\\\\n\\",
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  serializeInputObjectNonrecursiveInput: serializeInputObjectNonrecursiveInput$1,
  serializeInputObjectEmbeddedInput: serializeInputObjectEmbeddedInput$1,
  makeVariables: makeVariables$1,
  makeInputObjectNonrecursiveInput: makeInputObjectNonrecursiveInput$1,
  makeInputObjectEmbeddedInput: makeInputObjectEmbeddedInput$1,
  Z__INTERNAL: Z__INTERNAL$1
};

exports.MyQuery = MyQuery;
exports.MyQuery2 = MyQuery2;
/* No side effect */
"
`;

exports[`Compilation (Objects) omitFutureValueEnum.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_builtin_exceptions = require(\\"bs-platform/lib/js/caml_builtin_exceptions.js\\");

var Raw = { };

function parse(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  var errors = (value$2 == null) ? undefined : value$2.map((function (value) {
            var value$1 = value.field;
            var field;
            switch (value$1) {
              case \\"FIRST\\" :
                  field = /* FIRST */-24399856;
                  break;
              case \\"SECOND\\" :
                  field = /* SECOND */382368628;
                  break;
              case \\"THIRD\\" :
                  field = /* THIRD */225952583;
                  break;
              default:
                field = /* \`FutureAddedValue */[
                  -31101740,
                  value$1
                ];
            }
            var value$2 = value.message;
            return {
                    message: value$2,
                    field: field
                  };
          }));
  return {
          mutationWithError: {
            errors: errors
          }
        };
}

function serialize(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  var errors = value$2 !== undefined ? value$2.map((function (value) {
            var value$1 = value.field;
            var field = typeof value$1 === \\"number\\" ? (
                value$1 !== 225952583 ? (
                    value$1 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
                  ) : \\"THIRD\\"
              ) : value$1[1];
            var value$2 = value.message;
            return {
                    message: value$2,
                    field: field
                  };
          })) : null;
  return {
          mutationWithError: {
            errors: errors
          }
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var Normal = {
  Raw: Raw,
  query: \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  var errors = (value$2 == null) ? undefined : value$2.map((function (value) {
            var value$1 = value.field;
            var field;
            switch (value$1) {
              case \\"FIRST\\" :
                  field = /* FIRST */-24399856;
                  break;
              case \\"SECOND\\" :
                  field = /* SECOND */382368628;
                  break;
              case \\"THIRD\\" :
                  field = /* THIRD */225952583;
                  break;
              default:
                throw Caml_builtin_exceptions.not_found;
            }
            var value$2 = value.message;
            return {
                    message: value$2,
                    field: field
                  };
          }));
  return {
          mutationWithError: {
            errors: errors
          }
        };
}

function serialize$1(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  var errors = value$2 !== undefined ? value$2.map((function (value) {
            var value$1 = value.field;
            var field = value$1 !== 225952583 ? (
                value$1 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
              ) : \\"THIRD\\";
            var value$2 = value.message;
            return {
                    message: value$2,
                    field: field
                  };
          })) : null;
  return {
          mutationWithError: {
            errors: errors
          }
        };
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var ByConfig = {
  Raw: Raw$1,
  query: \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$1,
  serialize: serialize$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var Raw$2 = { };

function parse$2(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  var errors = (value$2 == null) ? undefined : value$2.map((function (value) {
            var value$1 = value.field;
            var field;
            switch (value$1) {
              case \\"FIRST\\" :
                  field = /* FIRST */-24399856;
                  break;
              case \\"SECOND\\" :
                  field = /* SECOND */382368628;
                  break;
              case \\"THIRD\\" :
                  field = /* THIRD */225952583;
                  break;
              default:
                throw Caml_builtin_exceptions.not_found;
            }
            var value$2 = value.message;
            return {
                    message: value$2,
                    field: field
                  };
          }));
  return {
          mutationWithError: {
            errors: errors
          }
        };
}

function serialize$2(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  var errors = value$2 !== undefined ? value$2.map((function (value) {
            var value$1 = value.field;
            var field = value$1 !== 225952583 ? (
                value$1 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
              ) : \\"THIRD\\";
            var value$2 = value.message;
            return {
                    message: value$2,
                    field: field
                  };
          })) : null;
  return {
          mutationWithError: {
            errors: errors
          }
        };
}

var Z__INTERNAL$2 = {
  graphql_module: 0
};

var ByDirective = {
  Raw: Raw$2,
  query: \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield @ppxOmitFutureValue \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$2,
  serialize: serialize$2,
  Z__INTERNAL: Z__INTERNAL$2
};

exports.Normal = Normal;
exports.ByConfig = ByConfig;
exports.ByDirective = ByDirective;
/* No side effect */
"
`;

exports[`Compilation (Objects) omitFutureValueUnion.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_builtin_exceptions = require(\\"bs-platform/lib/js/caml_builtin_exceptions.js\\");

var Raw = { };

function parse(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        var value$2 = value$1.barkVolume;
        var value$3 = value$1.name;
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$3,
            barkVolume: value$2
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      tmp = /* \`FutureAddedValue */[
        -31101740,
        value$1
      ];
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize(value) {
  var value$1 = value.dogOrHuman;
  var variant = value$1[0];
  var tmp;
  if (variant !== -31101740) {
    if (variant >= 3406428) {
      var value$2 = value$1[1];
      var value$3 = value$2.barkVolume;
      var value$4 = value$2.name;
      tmp = {
        __typename: \\"Dog\\",
        name: value$4,
        barkVolume: value$3
      };
    } else {
      var value$5 = value$1[1].name;
      tmp = {
        __typename: \\"Human\\",
        name: value$5
      };
    }
  } else {
    tmp = value$1[1];
  }
  return {
          dogOrHuman: tmp
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var Normal = {
  Raw: Raw,
  query: \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        var value$2 = value$1.barkVolume;
        var value$3 = value$1.name;
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$3,
            barkVolume: value$2
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      throw Caml_builtin_exceptions.not_found;
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize$1(value) {
  var value$1 = value.dogOrHuman;
  var tmp;
  if (value$1[0] >= 3406428) {
    var value$2 = value$1[1];
    var value$3 = value$2.barkVolume;
    var value$4 = value$2.name;
    tmp = {
      __typename: \\"Dog\\",
      name: value$4,
      barkVolume: value$3
    };
  } else {
    var value$5 = value$1[1].name;
    tmp = {
      __typename: \\"Human\\",
      name: value$5
    };
  }
  return {
          dogOrHuman: tmp
        };
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var ByConfig = {
  Raw: Raw$1,
  query: \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$1,
  serialize: serialize$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var Raw$2 = { };

function parse$2(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        var value$2 = value$1.barkVolume;
        var value$3 = value$1.name;
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$3,
            barkVolume: value$2
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      throw Caml_builtin_exceptions.not_found;
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize$2(value) {
  var value$1 = value.dogOrHuman;
  var tmp;
  if (value$1[0] >= 3406428) {
    var value$2 = value$1[1];
    var value$3 = value$2.barkVolume;
    var value$4 = value$2.name;
    tmp = {
      __typename: \\"Dog\\",
      name: value$4,
      barkVolume: value$3
    };
  } else {
    var value$5 = value$1[1].name;
    tmp = {
      __typename: \\"Human\\",
      name: value$5
    };
  }
  return {
          dogOrHuman: tmp
        };
}

var Z__INTERNAL$2 = {
  graphql_module: 0
};

var ByDirective = {
  Raw: Raw$2,
  query: \\"query   {\\\\ndogOrHuman @ppxOmitFutureValue {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$2,
  serialize: serialize$2,
  Z__INTERNAL: Z__INTERNAL$2
};

exports.Normal = Normal;
exports.ByConfig = ByConfig;
exports.ByDirective = ByDirective;
/* No side effect */
"
`;

exports[`Compilation (Objects) pokedexApolloMode.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

function parse(value) {
  var value$1 = value.pokemon;
  var tmp;
  if (value$1 == null) {
    tmp = undefined;
  } else {
    var value$2 = value$1.name;
    var name = (value$2 == null) ? undefined : value$2;
    var value$3 = value$1.id;
    tmp = {
      id: value$3,
      name: name
    };
  }
  return {
          pokemon: tmp
        };
}

function serialize(value) {
  var value$1 = value.pokemon;
  var tmp;
  if (value$1 !== undefined) {
    var value$2 = Caml_option.valFromOption(value$1);
    var value$3 = value$2.name;
    var name = value$3 !== undefined ? value$3 : null;
    var value$4 = value$2.id;
    tmp = {
      id: value$4,
      name: name
    };
  } else {
    tmp = null;
  }
  return {
          pokemon: tmp
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\npokemon(name: \\\\\\"Pikachu\\\\\\")  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) pokedexScalars.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

function parse(value) {
  var value$1 = value.pokemon;
  var tmp;
  if (value$1 == null) {
    tmp = undefined;
  } else {
    var value$2 = value$1.name;
    var name = (value$2 == null) ? undefined : value$2;
    var value$3 = value$1.id;
    tmp = {
      id: value$3,
      name: name
    };
  }
  return {
          pokemon: tmp
        };
}

function serialize(value) {
  var value$1 = value.pokemon;
  var tmp;
  if (value$1 !== undefined) {
    var value$2 = Caml_option.valFromOption(value$1);
    var value$3 = value$2.name;
    var name = value$3 !== undefined ? value$3 : null;
    var value$4 = value$2.id;
    tmp = {
      id: value$4,
      name: name
    };
  } else {
    tmp = null;
  }
  return {
          pokemon: tmp
        };
}

function serializeVariables(inp) {
  var a = inp.id;
  var a$1 = inp.name;
  return {
          id: a !== undefined ? a : undefined,
          name: a$1 !== undefined ? a$1 : undefined
        };
}

function makeVariables(id, name, param) {
  return serializeVariables({
              id: id,
              name: name
            });
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query pokemon($id: String, $name: String)  {\\\\npokemon(name: $name, id: $id)  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) record.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.int;
  var value$3 = value$1.string;
  return {
          variousScalars: {
            string: value$3,
            int: value$2
          }
        };
}

function serialize(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.int;
  var value$3 = value$1.string;
  return {
          variousScalars: {
            string: value$3,
            int: value$2
          }
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  var nullableString = (value$2 == null) ? undefined : value$2;
  return {
          variousScalars: {
            nullableString: nullableString
          }
        };
}

function serialize$1(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  var nullableString = value$2 !== undefined ? value$2 : null;
  return {
          variousScalars: {
            nullableString: nullableString
          }
        };
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var OneFieldQuery = {
  Raw: Raw$1,
  query: \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$1,
  serialize: serialize$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var query = \\"fragment Fragment on VariousScalars   {\\\\nstring  \\\\nint  \\\\n}\\\\n\\";

var Raw$2 = { };

function parse$2(value) {
  var value$1 = value.int;
  var value$2 = value.string;
  return {
          string: value$2,
          int: value$1
        };
}

function serialize$2(value) {
  var value$1 = value.int;
  var value$2 = value.string;
  return {
          string: value$2,
          int: value$1
        };
}

var name = \\"Fragment\\";

var Z__INTERNAL$2 = {
  graphql: 0,
  graphql_module: 0
};

var Fragment = {
  query: query,
  Raw: Raw$2,
  parse: parse$2,
  serialize: serialize$2,
  name: name,
  Z__INTERNAL: Z__INTERNAL$2
};

var Raw$3 = { };

var query$1 = \\"query   {\\\\nvariousScalars  {\\\\n...Fragment   \\\\n}\\\\n\\\\n}\\\\nfragment Fragment on VariousScalars   {\\\\nstring  \\\\nint  \\\\n}\\\\n\\";

function parse$3(value) {
  var value$1 = value.variousScalars;
  return {
          variousScalars: parse$2(value$1)
        };
}

function serialize$3(value) {
  var value$1 = value.variousScalars;
  return {
          variousScalars: serialize$2(value$1)
        };
}

var Z__INTERNAL$3 = {
  graphql_module: 0
};

var Untitled1 = {
  Raw: Raw$3,
  query: query$1,
  parse: parse$3,
  serialize: serialize$3,
  Z__INTERNAL: Z__INTERNAL$3
};

var ExternalFragmentQuery = {
  Fragment: Fragment,
  Untitled1: Untitled1
};

var Raw$4 = { };

function parse$4(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  if (typename === \\"Dog\\") {
    var value$2 = value$1.barkVolume;
    var value$3 = value$1.name;
    tmp = /* \`Dog */[
      3406428,
      {
        name: value$3,
        barkVolume: value$2
      }
    ];
  } else {
    tmp = /* \`FutureAddedValue */[
      -31101740,
      value$1
    ];
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize$4(value) {
  var value$1 = value.dogOrHuman;
  var tmp;
  if (value$1[0] >= 3406428) {
    var value$2 = value$1[1];
    var value$3 = value$2.barkVolume;
    var value$4 = value$2.name;
    tmp = {
      __typename: \\"Dog\\",
      name: value$4,
      barkVolume: value$3
    };
  } else {
    tmp = value$1[1];
  }
  return {
          dogOrHuman: tmp
        };
}

var Z__INTERNAL$4 = {
  graphql_module: 0
};

var InlineFragmentQuery = {
  Raw: Raw$4,
  query: \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$4,
  serialize: serialize$4,
  Z__INTERNAL: Z__INTERNAL$4
};

var query$2 = \\"fragment DogFragment on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\";

var Raw$5 = { };

function parse$5(value) {
  var value$1 = value.barkVolume;
  var value$2 = value.name;
  return {
          name: value$2,
          barkVolume: value$1
        };
}

function serialize$5(value) {
  var value$1 = value.barkVolume;
  var value$2 = value.name;
  return {
          name: value$2,
          barkVolume: value$1
        };
}

var name$1 = \\"DogFragment\\";

var Z__INTERNAL$5 = {
  graphql: 0,
  graphql_module: 0
};

var DogFragment = {
  query: query$2,
  Raw: Raw$5,
  parse: parse$5,
  serialize: serialize$5,
  name: name$1,
  Z__INTERNAL: Z__INTERNAL$5
};

var Raw$6 = { };

var query$3 = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n...DogFragment   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\nfragment DogFragment on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\";

function parse$6(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp = typename === \\"Dog\\" ? /* \`Dog */[
      3406428,
      parse$5(value$1)
    ] : /* \`FutureAddedValue */[
      -31101740,
      value$1
    ];
  return {
          dogOrHuman: tmp
        };
}

function serialize$6(value) {
  var value$1 = value.dogOrHuman;
  return {
          dogOrHuman: value$1[0] >= 3406428 ? serialize$5(value$1[1]) : value$1[1]
        };
}

var Z__INTERNAL$6 = {
  graphql_module: 0
};

var Untitled1$1 = {
  Raw: Raw$6,
  query: query$3,
  parse: parse$6,
  serialize: serialize$6,
  Z__INTERNAL: Z__INTERNAL$6
};

var UnionExternalFragmentQuery = {
  DogFragment: DogFragment,
  Untitled1: Untitled1$1
};

exports.MyQuery = MyQuery;
exports.OneFieldQuery = OneFieldQuery;
exports.ExternalFragmentQuery = ExternalFragmentQuery;
exports.InlineFragmentQuery = InlineFragmentQuery;
exports.UnionExternalFragmentQuery = UnionExternalFragmentQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) recursiveInput.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

function parse(value) {
  return {
          recursiveInput: value.recursiveInput
        };
}

function serialize(value) {
  return {
          recursiveInput: value.recursiveInput
        };
}

function serializeInputObjectRecursiveInput(inp) {
  var a = inp.otherField;
  var a$1 = inp.inner;
  var a$2 = inp.enum;
  var tmp;
  if (a$2 !== undefined) {
    var a$3 = a$2;
    tmp = a$3 !== 225952583 ? (
        a$3 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
      ) : \\"THIRD\\";
  } else {
    tmp = undefined;
  }
  return {
          otherField: a !== undefined ? a : undefined,
          inner: a$1 !== undefined ? serializeInputObjectRecursiveInput(Caml_option.valFromOption(a$1)) : undefined,
          enum: tmp
        };
}

function serializeVariables(inp) {
  return {
          arg: serializeInputObjectRecursiveInput(inp.arg)
        };
}

function makeVariables(arg, param) {
  return serializeVariables({
              arg: arg
            });
}

function makeInputObjectRecursiveInput(otherField, inner, $$enum, param) {
  return {
          otherField: otherField,
          inner: inner,
          enum: $$enum
        };
}

var Z__INTERNAL = {
  _graphql_RecursiveInput_47: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($arg: RecursiveInput!)  {\\\\nrecursiveInput(arg: $arg)  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  serializeInputObjectRecursiveInput: serializeInputObjectRecursiveInput,
  makeVariables: makeVariables,
  makeInputObjectRecursiveInput: makeInputObjectRecursiveInput,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) scalars.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = (value$3 == null) ? undefined : value$3;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = (value$5 == null) ? undefined : value$5;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = (value$7 == null) ? undefined : value$7;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = (value$9 == null) ? undefined : value$9;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = (value$11 == null) ? undefined : value$11;
  return {
          variousScalars: {
            nullableString: nullableString,
            string: value$10,
            nullableInt: nullableInt,
            int: value$8,
            nullableFloat: nullableFloat,
            float: value$6,
            nullableBoolean: nullableBoolean,
            boolean: value$4,
            nullableID: nullableID,
            id: value$2
          }
        };
}

function serialize(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  return {
          variousScalars: {
            nullableString: nullableString,
            string: value$10,
            nullableInt: nullableInt,
            int: value$8,
            nullableFloat: nullableFloat,
            float: value$6,
            nullableBoolean: nullableBoolean,
            boolean: value$4,
            nullableID: nullableID,
            id: value$2
          }
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) scalarsArgs.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          scalarsInput: value.scalarsInput
        };
}

function serialize(value) {
  return {
          scalarsInput: value.scalarsInput
        };
}

function serializeVariables(inp) {
  var a = inp.nullableString;
  var a$1 = inp.nullableInt;
  var a$2 = inp.nullableFloat;
  var a$3 = inp.nullableBoolean;
  var a$4 = inp.nullableID;
  return {
          nullableString: a !== undefined ? a : undefined,
          string: inp.string,
          nullableInt: a$1 !== undefined ? a$1 : undefined,
          int: inp.int,
          nullableFloat: a$2 !== undefined ? a$2 : undefined,
          float: inp.float,
          nullableBoolean: a$3 !== undefined ? a$3 : undefined,
          boolean: inp.boolean,
          nullableID: a$4 !== undefined ? a$4 : undefined,
          id: inp.id
        };
}

function makeVariables(nullableString, string, nullableInt, $$int, nullableFloat, $$float, nullableBoolean, $$boolean, nullableID, id, param) {
  return serializeVariables({
              nullableString: nullableString,
              string: string,
              nullableInt: nullableInt,
              int: $$int,
              nullableFloat: nullableFloat,
              float: $$float,
              nullableBoolean: nullableBoolean,
              boolean: $$boolean,
              nullableID: nullableID,
              id: id
            });
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($nullableString: String, $string: String!, $nullableInt: Int, $int: Int!, $nullableFloat: Float, $float: Float!, $nullableBoolean: Boolean, $boolean: Boolean!, $nullableID: ID, $id: ID!)  {\\\\nscalarsInput(arg: {nullableString: $nullableString, string: $string, nullableInt: $nullableInt, int: $int, nullableFloat: $nullableFloat, float: $float, nullableBoolean: $nullableBoolean, boolean: $boolean, nullableID: $nullableID, id: $id})  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) scalarsInput.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          scalarsInput: value.scalarsInput
        };
}

function serialize(value) {
  return {
          scalarsInput: value.scalarsInput
        };
}

function serializeInputObjectVariousScalarsInput(inp) {
  var a = inp.nullableString;
  var a$1 = inp.nullableInt;
  var a$2 = inp.nullableFloat;
  var a$3 = inp.nullableBoolean;
  var a$4 = inp.nullableID;
  return {
          nullableString: a !== undefined ? a : undefined,
          string: inp.string,
          nullableInt: a$1 !== undefined ? a$1 : undefined,
          int: inp.int,
          nullableFloat: a$2 !== undefined ? a$2 : undefined,
          float: inp.float,
          nullableBoolean: a$3 !== undefined ? a$3 : undefined,
          boolean: inp.boolean,
          nullableID: a$4 !== undefined ? a$4 : undefined,
          id: inp.id
        };
}

function serializeVariables(inp) {
  return {
          arg: serializeInputObjectVariousScalarsInput(inp.arg)
        };
}

function makeVariables(arg, param) {
  return serializeVariables({
              arg: arg
            });
}

function makeInputObjectVariousScalarsInput(nullableString, string, nullableInt, $$int, nullableFloat, $$float, nullableBoolean, $$boolean, nullableID, id, param) {
  return {
          nullableString: nullableString,
          string: string,
          nullableInt: nullableInt,
          int: $$int,
          nullableFloat: nullableFloat,
          float: $$float,
          nullableBoolean: nullableBoolean,
          boolean: $$boolean,
          nullableID: nullableID,
          id: id
        };
}

var Z__INTERNAL = {
  _graphql_VariousScalarsInput_47: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($arg: VariousScalarsInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  serializeInputObjectVariousScalarsInput: serializeInputObjectVariousScalarsInput,
  makeVariables: makeVariables,
  makeInputObjectVariousScalarsInput: makeInputObjectVariousScalarsInput,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) skipDirectives.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.v2;
  var value$2 = value$1.string;
  var string = (value$2 == null) ? undefined : value$2;
  var value$3 = value$1.nullableString;
  var nullableString = (value$3 == null) ? undefined : value$3;
  var v2 = {
    nullableString: nullableString,
    string: string
  };
  var value$4 = value.v1;
  var value$5 = value$4.string;
  var string$1 = (value$5 == null) ? undefined : value$5;
  var value$6 = value$4.nullableString;
  var nullableString$1 = (value$6 == null) ? undefined : value$6;
  var v1 = {
    nullableString: nullableString$1,
    string: string$1
  };
  return {
          v1: v1,
          v2: v2
        };
}

function serialize(value) {
  var value$1 = value.v2;
  var value$2 = value$1.string;
  var string = value$2 !== undefined ? value$2 : null;
  var value$3 = value$1.nullableString;
  var nullableString = value$3 !== undefined ? value$3 : null;
  var v2 = {
    nullableString: nullableString,
    string: string
  };
  var value$4 = value.v1;
  var value$5 = value$4.string;
  var string$1 = value$5 !== undefined ? value$5 : null;
  var value$6 = value$4.nullableString;
  var nullableString$1 = value$6 !== undefined ? value$6 : null;
  var v1 = {
    nullableString: nullableString$1,
    string: string$1
  };
  return {
          v1: v1,
          v2: v2
        };
}

function serializeVariables(inp) {
  return {
          var: inp.var
        };
}

function makeVariables($$var, param) {
  return serializeVariables({
              var: $$var
            });
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($var: Boolean!)  {\\\\nv1: variousScalars  {\\\\nnullableString @skip(if: $var) \\\\nstring @skip(if: $var) \\\\n}\\\\n\\\\nv2: variousScalars  {\\\\nnullableString @include(if: $var) \\\\nstring @include(if: $var) \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) subscription.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.simpleSubscription;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$1.name
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      tmp = /* \`FutureAddedValue */[
        -31101740,
        value$1
      ];
  }
  return {
          simpleSubscription: tmp
        };
}

function serialize(value) {
  var value$1 = value.simpleSubscription;
  var variant = value$1[0];
  var tmp;
  if (variant !== -31101740) {
    if (variant >= 3406428) {
      var value$2 = value$1[1].name;
      tmp = {
        __typename: \\"Dog\\",
        name: value$2
      };
    } else {
      var value$3 = value$1[1].name;
      tmp = {
        __typename: \\"Human\\",
        name: value$3
      };
    }
  } else {
    tmp = value$1[1];
  }
  return {
          simpleSubscription: tmp
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"subscription   {\\\\nsimpleSubscription  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) tagged_template.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = (value$3 == null) ? undefined : value$3;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = (value$5 == null) ? undefined : value$5;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = (value$7 == null) ? undefined : value$7;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = (value$9 == null) ? undefined : value$9;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = (value$11 == null) ? undefined : value$11;
  return {
          variousScalars: {
            nullableString: nullableString,
            string: value$10,
            nullableInt: nullableInt,
            int: value$8,
            nullableFloat: nullableFloat,
            float: value$6,
            nullableBoolean: nullableBoolean,
            boolean: value$4,
            nullableID: nullableID,
            id: value$2
          }
        };
}

function serialize(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  return {
          variousScalars: {
            nullableString: nullableString,
            string: value$10,
            nullableInt: nullableInt,
            int: value$8,
            nullableFloat: nullableFloat,
            float: value$6,
            nullableBoolean: nullableBoolean,
            boolean: value$4,
            nullableID: nullableID,
            id: value$2
          }
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

let { graphql } = require(\\"gatsby\\")
;

var query = (graphql\`
  query   {
    variousScalars  {
      nullableString
      string
      nullableInt
      int
      nullableFloat
      float
      nullableBoolean
      boolean
      nullableID
      id
    }
  }
\`);

function parse$1(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = (value$3 == null) ? undefined : value$3;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = (value$5 == null) ? undefined : value$5;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = (value$7 == null) ? undefined : value$7;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = (value$9 == null) ? undefined : value$9;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = (value$11 == null) ? undefined : value$11;
  return {
          variousScalars: {
            nullableString: nullableString,
            string: value$10,
            nullableInt: nullableInt,
            int: value$8,
            nullableFloat: nullableFloat,
            float: value$6,
            nullableBoolean: nullableBoolean,
            boolean: value$4,
            nullableID: nullableID,
            id: value$2
          }
        };
}

function serialize$1(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  return {
          variousScalars: {
            nullableString: nullableString,
            string: value$10,
            nullableInt: nullableInt,
            int: value$8,
            nullableFloat: nullableFloat,
            float: value$6,
            nullableBoolean: nullableBoolean,
            boolean: value$4,
            nullableID: nullableID,
            id: value$2
          }
        };
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var MyQuery2 = {
  Raw: Raw$1,
  query: query,
  parse: parse$1,
  serialize: serialize$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var Raw$2 = { };

let { graphql } = require(\\"gatsby\\")
;

var query$1 = (graphql\`
  query   {
    variousScalars  {
      nullableString
      string
      nullableInt
      int
      nullableFloat
      float
      nullableBoolean
      boolean
      nullableID
      id
    }
  }
\`);

function parse$2(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = (value$3 == null) ? undefined : value$3;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = (value$5 == null) ? undefined : value$5;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = (value$7 == null) ? undefined : value$7;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = (value$9 == null) ? undefined : value$9;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = (value$11 == null) ? undefined : value$11;
  return {
          variousScalars: {
            nullableString: nullableString,
            string: value$10,
            nullableInt: nullableInt,
            int: value$8,
            nullableFloat: nullableFloat,
            float: value$6,
            nullableBoolean: nullableBoolean,
            boolean: value$4,
            nullableID: nullableID,
            id: value$2
          }
        };
}

function serialize$2(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  return {
          variousScalars: {
            nullableString: nullableString,
            string: value$10,
            nullableInt: nullableInt,
            int: value$8,
            nullableFloat: nullableFloat,
            float: value$6,
            nullableBoolean: nullableBoolean,
            boolean: value$4,
            nullableID: nullableID,
            id: value$2
          }
        };
}

var Z__INTERNAL$2 = {
  graphql_module: 0
};

var MyQuery3 = {
  Raw: Raw$2,
  query: query$1,
  parse: parse$2,
  serialize: serialize$2,
  Z__INTERNAL: Z__INTERNAL$2
};

var Raw$3 = { };

let graphql = require(\\"gatsby\\")
;

var query$2 = (graphql\`
  query   {
    variousScalars  {
      nullableString
      string
      nullableInt
      int
      nullableFloat
      float
      nullableBoolean
      boolean
      nullableID
      id
    }
  }
\`);

function parse$3(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = (value$3 == null) ? undefined : value$3;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = (value$5 == null) ? undefined : value$5;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = (value$7 == null) ? undefined : value$7;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = (value$9 == null) ? undefined : value$9;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = (value$11 == null) ? undefined : value$11;
  return {
          variousScalars: {
            nullableString: nullableString,
            string: value$10,
            nullableInt: nullableInt,
            int: value$8,
            nullableFloat: nullableFloat,
            float: value$6,
            nullableBoolean: nullableBoolean,
            boolean: value$4,
            nullableID: nullableID,
            id: value$2
          }
        };
}

function serialize$3(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  return {
          variousScalars: {
            nullableString: nullableString,
            string: value$10,
            nullableInt: nullableInt,
            int: value$8,
            nullableFloat: nullableFloat,
            float: value$6,
            nullableBoolean: nullableBoolean,
            boolean: value$4,
            nullableID: nullableID,
            id: value$2
          }
        };
}

var Z__INTERNAL$3 = {
  graphql_module: 0
};

var MyQuery4 = {
  Raw: Raw$3,
  query: query$2,
  parse: parse$3,
  serialize: serialize$3,
  Z__INTERNAL: Z__INTERNAL$3
};

exports.MyQuery = MyQuery;
exports.MyQuery2 = MyQuery2;
exports.MyQuery3 = MyQuery3;
exports.MyQuery4 = MyQuery4;
/*  Not a pure module */
"
`;

exports[`Compilation (Objects) typename.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

function parse(value) {
  var value$1 = value.first;
  var value$2 = value$1.inner;
  var inner;
  if (value$2 == null) {
    inner = undefined;
  } else {
    var value$3 = value$2.inner;
    var inner$1;
    if (value$3 == null) {
      inner$1 = undefined;
    } else {
      var value$4 = value$3.field;
      var value$5 = value$3.__typename;
      inner$1 = {
        __typename: value$5,
        field: value$4
      };
    }
    var value$6 = value$2.__typename;
    inner = {
      __typename: value$6,
      inner: inner$1
    };
  }
  var value$7 = value$1.__typename;
  return {
          first: {
            __typename: value$7,
            inner: inner
          }
        };
}

function serialize(value) {
  var value$1 = value.first;
  var value$2 = value$1.inner;
  var inner;
  if (value$2 !== undefined) {
    var value$3 = Caml_option.valFromOption(value$2);
    var value$4 = value$3.inner;
    var inner$1;
    if (value$4 !== undefined) {
      var value$5 = Caml_option.valFromOption(value$4);
      var value$6 = value$5.field;
      var value$7 = value$5.__typename;
      inner$1 = {
        __typename: value$7,
        field: value$6
      };
    } else {
      inner$1 = null;
    }
    var value$8 = value$3.__typename;
    inner = {
      __typename: value$8,
      inner: inner$1
    };
  } else {
    inner = null;
  }
  var value$9 = value$1.__typename;
  return {
          first: {
            __typename: value$9,
            inner: inner
          }
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) union.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        var value$2 = value$1.barkVolume;
        var value$3 = value$1.name;
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$3,
            barkVolume: value$2
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      tmp = /* \`FutureAddedValue */[
        -31101740,
        value$1
      ];
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize(value) {
  var value$1 = value.dogOrHuman;
  var variant = value$1[0];
  var tmp;
  if (variant !== -31101740) {
    if (variant >= 3406428) {
      var value$2 = value$1[1];
      var value$3 = value$2.barkVolume;
      var value$4 = value$2.name;
      tmp = {
        __typename: \\"Dog\\",
        name: value$4,
        barkVolume: value$3
      };
    } else {
      var value$5 = value$1[1].name;
      tmp = {
        __typename: \\"Human\\",
        name: value$5
      };
    }
  } else {
    tmp = value$1[1];
  }
  return {
          dogOrHuman: tmp
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        var value$2 = value$1.barkVolume;
        var value$3 = value$1.name;
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$3,
            barkVolume: value$2
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      tmp = /* \`FutureAddedValue */[
        -31101740,
        value$1
      ];
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize$1(value) {
  var value$1 = value.dogOrHuman;
  var variant = value$1[0];
  var tmp;
  if (variant !== -31101740) {
    if (variant >= 3406428) {
      var value$2 = value$1[1];
      var value$3 = value$2.barkVolume;
      var value$4 = value$2.name;
      tmp = {
        __typename: \\"Dog\\",
        name: value$4,
        barkVolume: value$3
      };
    } else {
      var value$5 = value$1[1].name;
      tmp = {
        __typename: \\"Human\\",
        name: value$5
      };
    }
  } else {
    tmp = value$1[1];
  }
  return {
          dogOrHuman: tmp
        };
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var MyQueryNoError = {
  Raw: Raw$1,
  query: \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$1,
  serialize: serialize$1,
  Z__INTERNAL: Z__INTERNAL$1
};

exports.MyQuery = MyQuery;
exports.MyQueryNoError = MyQueryNoError;
/* No side effect */
"
`;

exports[`Compilation (Objects) unionPartial.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  if (typename === \\"Dog\\") {
    var value$2 = value$1.barkVolume;
    var value$3 = value$1.name;
    tmp = /* \`Dog */[
      3406428,
      {
        name: value$3,
        barkVolume: value$2
      }
    ];
  } else {
    tmp = /* \`FutureAddedValue */[
      -31101740,
      value$1
    ];
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize(value) {
  var value$1 = value.dogOrHuman;
  var tmp;
  if (value$1[0] >= 3406428) {
    var value$2 = value$1[1];
    var value$3 = value$2.barkVolume;
    var value$4 = value$2.name;
    tmp = {
      __typename: \\"Dog\\",
      name: value$4,
      barkVolume: value$3
    };
  } else {
    tmp = value$1[1];
  }
  return {
          dogOrHuman: tmp
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) variant.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Js_exn = require(\\"bs-platform/lib/js/js_exn.js\\");
var Js_json = require(\\"bs-platform/lib/js/js_json.js\\");
var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

function parse(value) {
  var value$1 = value.mutationForVariant;
  var match = Js_json.decodeObject(value$1);
  var tmp;
  if (match !== undefined) {
    var value$2 = Caml_option.valFromOption(match);
    var temp = value$2[\\"baseType\\"];
    var match$1 = Js_json.decodeNull(temp);
    if (match$1 !== undefined) {
      var temp$1 = value$2[\\"baseTypeList\\"];
      var match$2 = Js_json.decodeNull(temp$1);
      if (match$2 !== undefined) {
        var temp$2 = value$2[\\"dog\\"];
        var match$3 = Js_json.decodeNull(temp$2);
        if (match$3 !== undefined) {
          var temp$3 = value$2[\\"human\\"];
          var match$4 = Js_json.decodeNull(temp$3);
          if (match$4 !== undefined) {
            var temp$4 = value$2[\\"dogOrHuman\\"];
            var match$5 = Js_json.decodeNull(temp$4);
            if (match$5 !== undefined) {
              tmp = Js_exn.raiseError(\\"graphql_ppx: All fields on variant selection set on type VariantTestResult were null\\");
            } else {
              var typename = temp$4[\\"__typename\\"];
              var tmp$1;
              switch (typename) {
                case \\"Dog\\" :
                    var value$3 = temp$4.barkVolume;
                    var value$4 = temp$4.name;
                    tmp$1 = /* \`Dog */[
                      3406428,
                      {
                        name: value$4,
                        barkVolume: value$3
                      }
                    ];
                    break;
                case \\"Human\\" :
                    tmp$1 = /* \`Human */[
                      -1031617139,
                      {
                        name: temp$4.name
                      }
                    ];
                    break;
                default:
                  tmp$1 = /* \`FutureAddedValue */[
                    -31101740,
                    temp$4
                  ];
              }
              tmp = /* \`DogOrHuman */[
                974247566,
                tmp$1
              ];
            }
          } else {
            tmp = /* \`Human */[
              -1031617139,
              {
                name: temp$3.name
              }
            ];
          }
        } else {
          var value$5 = temp$2.barkVolume;
          var value$6 = temp$2.name;
          tmp = /* \`Dog */[
            3406428,
            {
              name: value$6,
              barkVolume: value$5
            }
          ];
        }
      } else {
        tmp = /* \`BaseTypeList */[
          -259847799,
          temp$1.map((function (value) {
                  return value;
                }))
        ];
      }
    } else {
      tmp = /* \`BaseType */[
        -620191861,
        temp
      ];
    }
  } else {
    tmp = Js_exn.raiseError(\\"graphql_ppx: Expected type VariantTestResult to be an object\\");
  }
  return {
          mutationForVariant: tmp
        };
}

function serialize(value) {
  value.mutationForVariant;
  return {
          mutationForVariant: null
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"mutation   {\\\\nmutationForVariant  {\\\\nbaseType  \\\\nbaseTypeList  \\\\ndog  {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\nhuman  {\\\\nname  \\\\n}\\\\n\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) argNamedQuery.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          argNamedQuery: value.argNamedQuery
        };
}

function serialize(value) {
  var value$1 = value.argNamedQuery;
  return {
          argNamedQuery: value$1
        };
}

function serializeVariables(inp) {
  return {
          query: inp.query
        };
}

function makeVariables(query, param) {
  return {
          query: query
        };
}

var Z__INTERNAL = {
  _graphql_query_82: 0,
  _graphql_query_75: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($query: Int!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) comment.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require(\\"bs-platform/lib/js/array.js\\");
var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

function parse(value) {
  return {
          nonrecursiveInput: value.nonrecursiveInput
        };
}

function serialize(value) {
  var value$1 = value.nonrecursiveInput;
  return {
          nonrecursiveInput: value$1
        };
}

function serializeInputObjectEmbeddedInput(inp) {
  var a = inp.field;
  return {
          field: a !== undefined ? a : undefined
        };
}

function serializeInputObjectNonrecursiveInput(inp) {
  var a = inp.nullableArray;
  var tmp;
  if (a !== undefined) {
    var a$1 = a;
    tmp = $$Array.map((function (b) {
            if (b !== undefined) {
              return b;
            }
            
          }), a$1);
  } else {
    tmp = undefined;
  }
  var a$2 = inp.field;
  var a$3 = inp.enum;
  var tmp$1;
  if (a$3 !== undefined) {
    var a$4 = a$3;
    tmp$1 = a$4 !== 225952583 ? (
        a$4 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
      ) : \\"THIRD\\";
  } else {
    tmp$1 = undefined;
  }
  var a$5 = inp.embeddedInput;
  var tmp$2;
  if (a$5 !== undefined) {
    var a$6 = a$5;
    tmp$2 = $$Array.map((function (b) {
            if (b !== undefined) {
              return serializeInputObjectEmbeddedInput(b);
            }
            
          }), a$6);
  } else {
    tmp$2 = undefined;
  }
  var a$7 = inp.custom;
  return {
          nonNullableField: inp.nonNullableField,
          nullableArray: tmp,
          field: a$2 !== undefined ? a$2 : undefined,
          enum: tmp$1,
          embeddedInput: tmp$2,
          custom: a$7 !== undefined ? Caml_option.valFromOption(a$7) : undefined
        };
}

function serializeVariables(inp) {
  return {
          arg: serializeInputObjectNonrecursiveInput(inp.arg)
        };
}

function makeVariables(arg, param) {
  return {
          arg: serializeInputObjectNonrecursiveInput(arg)
        };
}

function makeInputObjectNonrecursiveInput(nonNullableField, nullableArray, field, $$enum, embeddedInput, custom, param) {
  return {
          nonNullableField: nonNullableField,
          nullableArray: nullableArray,
          field: field,
          enum: $$enum,
          embeddedInput: embeddedInput,
          custom: custom
        };
}

function makeInputObjectEmbeddedInput(field, param) {
  return {
          field: field
        };
}

var Z__INTERNAL = {
  _graphql_arg_100: 0,
  _graphql_arg_95: 0,
  _graphql_NonrecursiveInput_49: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  serializeInputObjectNonrecursiveInput: serializeInputObjectNonrecursiveInput,
  serializeInputObjectEmbeddedInput: serializeInputObjectEmbeddedInput,
  makeVariables: makeVariables,
  makeInputObjectNonrecursiveInput: makeInputObjectNonrecursiveInput,
  makeInputObjectEmbeddedInput: makeInputObjectEmbeddedInput,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) customDecoder.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_format = require(\\"bs-platform/lib/js/caml_format.js\\");

function parse(prim) {
  return String(prim);
}

var serialize = Caml_format.caml_int_of_string;

var StringOfInt = {
  parse: parse,
  serialize: serialize
};

var parse$1 = Caml_format.caml_int_of_string;

function serialize$1(prim) {
  return String(prim);
}

var IntOfString = {
  parse: parse$1,
  serialize: serialize$1
};

var Raw = { };

function parse$2(value) {
  var value$1 = value.variousScalars;
  return {
          variousScalars: {
            string: Caml_format.caml_int_of_string(value$1.string),
            int: String(value$1.int)
          }
        };
}

function serialize$2(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.int;
  var $$int = Caml_format.caml_int_of_string(value$2);
  var value$3 = value$1.string;
  var string = String(value$3);
  var variousScalars = {
    string: string,
    int: $$int
  };
  return {
          variousScalars: variousScalars
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$2,
  serialize: serialize$2,
  Z__INTERNAL: Z__INTERNAL
};

exports.StringOfInt = StringOfInt;
exports.IntOfString = IntOfString;
exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) customScalars.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

function parse(value) {
  var value$1 = value.customScalarField;
  var value$2 = value$1.nullable;
  return {
          customScalarField: {
            nullable: (value$2 == null) ? undefined : Caml_option.some(value$2),
            nonNullable: value$1.nonNullable
          }
        };
}

function serialize(value) {
  var value$1 = value.customScalarField;
  var value$2 = value$1.nonNullable;
  var value$3 = value$1.nullable;
  var nullable = value$3 !== undefined ? Caml_option.valFromOption(value$3) : null;
  var customScalarField = {
    nullable: nullable,
    nonNullable: value$2
  };
  return {
          customScalarField: customScalarField
        };
}

function serializeVariables(inp) {
  var a = inp.opt;
  return {
          opt: a !== undefined ? Caml_option.valFromOption(a) : undefined,
          req: inp.req
        };
}

function makeVariables(opt, req, param) {
  return serializeVariables({
              opt: opt,
              req: req
            });
}

var Z__INTERNAL = {
  _graphql_opt_119: 0,
  _graphql_argOptional_106: 0,
  _graphql_req_138: 0,
  _graphql_argRequired_125: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($opt: CustomScalar, $req: CustomScalar!)  {\\\\ncustomScalarField(argOptional: $opt, argRequired: $req)  {\\\\nnullable  \\\\nnonNullable  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) customTypes.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Js_json = require(\\"bs-platform/lib/js/js_json.js\\");
var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

function parse(json) {
  var match = Js_json.decodeString(json);
  if (match !== undefined) {
    switch (match) {
      case \\"blue\\" :
          return /* Blue */2;
      case \\"green\\" :
          return /* Green */1;
      case \\"red\\" :
          return /* Red */0;
      default:
        return /* Red */0;
    }
  } else {
    return /* Red */0;
  }
}

function serialize(color) {
  switch (color) {
    case /* Red */0 :
        return \\"red\\";
    case /* Green */1 :
        return \\"green\\";
    case /* Blue */2 :
        return \\"blue\\";
    
  }
}

var Color = {
  parse: parse,
  serialize: serialize
};

function parse$1(json) {
  var match = Js_json.decodeString(json);
  if (match !== undefined) {
    return new Date(match);
  } else {
    return new Date();
  }
}

function serialize$1(date) {
  return date.toISOString();
}

var DateTime = {
  parse: parse$1,
  serialize: serialize$1
};

var Raw = { };

function parse$2(value) {
  var value$1 = value.customFields;
  var value$2 = value$1.futureTime;
  var value$3 = value$1.nullableColor;
  return {
          customFields: {
            currentTime: parse$1(value$1.currentTime),
            favoriteColor: parse(value$1.favoriteColor),
            futureTime: (value$2 == null) ? undefined : Caml_option.some(parse$1(value$2)),
            nullableColor: (value$3 == null) ? undefined : parse(value$3)
          }
        };
}

function serialize$2(value) {
  var value$1 = value.customFields;
  var value$2 = value$1.nullableColor;
  var nullableColor = value$2 !== undefined ? serialize(value$2) : null;
  var value$3 = value$1.futureTime;
  var futureTime = value$3 !== undefined ? Caml_option.valFromOption(value$3).toISOString() : null;
  var value$4 = value$1.favoriteColor;
  var favoriteColor = serialize(value$4);
  var value$5 = value$1.currentTime;
  var currentTime = value$5.toISOString();
  var customFields = {
    currentTime: currentTime,
    favoriteColor: favoriteColor,
    futureTime: futureTime,
    nullableColor: nullableColor
  };
  return {
          customFields: customFields
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\ncustomFields  {\\\\ncurrentTime  \\\\nfavoriteColor  \\\\nfutureTime  \\\\nnullableColor  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$2,
  serialize: serialize$2,
  Z__INTERNAL: Z__INTERNAL
};

exports.Color = Color;
exports.DateTime = DateTime;
exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) defaultObjectValueOnScalar.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          defaultObjectValueOnScalar: value.defaultObjectValueOnScalar
        };
}

function serialize(value) {
  var value$1 = value.defaultObjectValueOnScalar;
  return {
          defaultObjectValueOnScalar: value$1
        };
}

var Z__INTERNAL = {
  _graphql_filter_92: 0,
  _graphql_arg_140: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\ndefaultObjectValueOnScalar(filter: {some: {json: \\\\\\"value\\\\\\"}}, arg: {field: \\\\\\"otherValue\\\\\\"})  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) enumInput.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          enumInput: value.enumInput
        };
}

function serialize(value) {
  var value$1 = value.enumInput;
  return {
          enumInput: value$1
        };
}

function serializeVariables(inp) {
  var a = inp.arg;
  return {
          arg: a !== 225952583 ? (
              a >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
            ) : \\"THIRD\\"
        };
}

function makeVariables(arg, param) {
  return serializeVariables({
              arg: arg
            });
}

var Z__INTERNAL = {
  _graphql_arg_82: 0,
  _graphql_arg_77: 0,
  _graphql_SampleField_47: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($arg: SampleField!)  {\\\\nenumInput(arg: $arg)  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) explicit_object_record.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nullableOfNullable;
  var value$3 = value$1.nullableOfNonNullable;
  var value$4 = value$1.nonNullableOfNullable;
  var value$5 = value$1.nonNullableOfNonNullable;
  return {
          lists: {
            nullableOfNullable: (value$2 == null) ? undefined : value$2.map((function (value) {
                      if (value == null) {
                        return ;
                      } else {
                        return value;
                      }
                    })),
            nullableOfNonNullable: (value$3 == null) ? undefined : value$3.map((function (value) {
                      return value;
                    })),
            nonNullableOfNullable: value$4.map((function (value) {
                    if (value == null) {
                      return ;
                    } else {
                      return value;
                    }
                  })),
            nonNullableOfNonNullable: value$5.map((function (value) {
                    return value;
                  }))
          }
        };
}

function serialize(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (value !== undefined) {
            return value;
          } else {
            return null;
          }
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = value$4 !== undefined ? value$4.map((function (value) {
            return value;
          })) : null;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = value$5 !== undefined ? value$5.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  var lists = {
    nullableOfNullable: nullableOfNullable,
    nullableOfNonNullable: nullableOfNonNullable,
    nonNullableOfNullable: nonNullableOfNullable,
    nonNullableOfNonNullable: nonNullableOfNonNullable
  };
  return {
          lists: lists
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var RecordsQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (value == null) {
            return ;
          } else {
            return value;
          }
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = (value$4 == null) ? undefined : value$4.map((function (value) {
            return value;
          }));
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = (value$5 == null) ? undefined : value$5.map((function (value) {
            if (value == null) {
              return ;
            } else {
              return value;
            }
          }));
  return {
          lists: {
            nullableOfNullable: nullableOfNullable,
            nullableOfNonNullable: nullableOfNonNullable,
            nonNullableOfNullable: nonNullableOfNullable,
            nonNullableOfNonNullable: nonNullableOfNonNullable
          }
        };
}

function serialize$1(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (value !== undefined) {
            return value;
          } else {
            return null;
          }
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = value$4 !== undefined ? value$4.map((function (value) {
            return value;
          })) : null;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = value$5 !== undefined ? value$5.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  return {
          lists: {
            nullableOfNullable: nullableOfNullable,
            nullableOfNonNullable: nullableOfNonNullable,
            nonNullableOfNullable: nonNullableOfNullable,
            nonNullableOfNonNullable: nonNullableOfNonNullable
          }
        };
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var ObjectsQuery = {
  Raw: Raw$1,
  query: \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$1,
  serialize: serialize$1,
  Z__INTERNAL: Z__INTERNAL$1
};

exports.RecordsQuery = RecordsQuery;
exports.ObjectsQuery = ObjectsQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) extensions.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


function ExtendQuery(M) {
  var use = function (param) {
    return /* () */0;
  };
  return {
          use: use
        };
}

var Raw = { };

var query = \\"query Bla  {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";

function parse(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nullableOfNullable;
  var value$3 = value$1.nullableOfNonNullable;
  var value$4 = value$1.nonNullableOfNullable;
  var value$5 = value$1.nonNullableOfNonNullable;
  return {
          lists: {
            nullableOfNullable: (value$2 == null) ? undefined : value$2.map((function (value) {
                      if (value == null) {
                        return ;
                      } else {
                        return value;
                      }
                    })),
            nullableOfNonNullable: (value$3 == null) ? undefined : value$3.map((function (value) {
                      return value;
                    })),
            nonNullableOfNullable: value$4.map((function (value) {
                    if (value == null) {
                      return ;
                    } else {
                      return value;
                    }
                  })),
            nonNullableOfNonNullable: value$5.map((function (value) {
                    return value;
                  }))
          }
        };
}

function serialize(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (value !== undefined) {
            return value;
          } else {
            return null;
          }
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = value$4 !== undefined ? value$4.map((function (value) {
            return value;
          })) : null;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = value$5 !== undefined ? value$5.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  var lists = {
    nullableOfNullable: nullableOfNullable,
    nullableOfNonNullable: nullableOfNonNullable,
    nonNullableOfNullable: nonNullableOfNullable,
    nonNullableOfNonNullable: nonNullableOfNonNullable
  };
  return {
          lists: lists
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var Bla$prime = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

function use(param) {
  return /* () */0;
}

var Bla = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL,
  use: use
};

exports.ExtendQuery = ExtendQuery;
exports.Bla$prime = Bla$prime;
exports.Bla = Bla;
/* No side effect */
"
`;

exports[`Compilation (Records) fragmentDefinition.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var GraphQL_PPX = require(\\"../utilities/GraphQL_PPX.bs.js\\");

var query = \\"fragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";

var Raw = { };

function parse(value) {
  var value$1 = value.nullableOfNullable;
  var value$2 = value.nullableOfNonNullable;
  return {
          nullableOfNullable: (value$1 == null) ? undefined : value$1.map((function (value) {
                    if (value == null) {
                      return ;
                    } else {
                      return value;
                    }
                  })),
          nullableOfNonNullable: (value$2 == null) ? undefined : value$2.map((function (value) {
                    return value;
                  }))
        };
}

function serialize(value) {
  var value$1 = value.nullableOfNonNullable;
  var nullableOfNonNullable = value$1 !== undefined ? value$1.map((function (value) {
            return value;
          })) : null;
  var value$2 = value.nullableOfNullable;
  var nullableOfNullable = value$2 !== undefined ? value$2.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  return {
          nullableOfNullable: nullableOfNullable,
          nullableOfNonNullable: nullableOfNonNullable
        };
}

var name = \\"ListFragment\\";

var Z__INTERNAL = {
  graphql: 0,
  graphql_module: 0
};

var ListFragment = {
  query: query,
  Raw: Raw,
  parse: parse,
  serialize: serialize,
  name: name,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  var value$1 = value.nullableOfNonNullable;
  return {
          nullableOfNonNullable: (value$1 == null) ? undefined : value$1.map((function (value) {
                    return value;
                  }))
        };
}

function serialize$1(value) {
  var value$1 = value.nullableOfNonNullable;
  var nullableOfNonNullable = value$1 !== undefined ? value$1.map((function (value) {
            return value;
          })) : null;
  return {
          nullableOfNonNullable: nullableOfNonNullable
        };
}

var Z__INTERNAL$1 = {
  graphql: 0,
  graphql_module: 0
};

var Another = {
  query: \\"fragment Another on Lists   {\\\\nnullableOfNonNullable  \\\\n}\\\\n\\",
  Raw: Raw$1,
  parse: parse$1,
  serialize: serialize$1,
  name: \\"Another\\",
  Z__INTERNAL: Z__INTERNAL$1
};

var Fragments = {
  ListFragment: ListFragment,
  Another: Another
};

var Raw$2 = { };

var query$1 = \\"query   {\\\\nl1: lists  {\\\\n...ListFragment   \\\\n}\\\\n\\\\nl2: lists  {\\\\n...ListFragment   \\\\n...ListFragment   \\\\n}\\\\n\\\\nl3: lists  {\\\\nnullableOfNullable  \\\\n...ListFragment   \\\\n...ListFragment   \\\\n}\\\\n\\\\nl4: lists  {\\\\nnullableOfNullable  \\\\n...ListFragment   \\\\n}\\\\n\\\\n}\\\\nfragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";

function parse$2(value) {
  var value$1 = value.l2;
  var value$2 = value.l3;
  var value$3 = value$2[\\"nullableOfNullable\\"];
  var value$4 = value.l4;
  var value$5 = value$4[\\"nullableOfNullable\\"];
  return {
          l1: parse(value.l1),
          l2: {
            frag1: parse(value$1),
            frag2: parse(value$1)
          },
          l3: {
            nullableOfNullable: (value$3 == null) ? undefined : value$3.map((function (value) {
                      if (value == null) {
                        return ;
                      } else {
                        return value;
                      }
                    })),
            frag1: parse(value$2),
            frag2: parse(value$2)
          },
          l4: {
            nullableOfNullable: (value$5 == null) ? undefined : value$5.map((function (value) {
                      if (value == null) {
                        return ;
                      } else {
                        return value;
                      }
                    })),
            listFragment: parse(value$4)
          }
        };
}

function serialize$2(value) {
  var value$1 = value.l4;
  var value$2 = value$1.nullableOfNullable;
  var l4 = [serialize(value$1.listFragment)].reduce(GraphQL_PPX.deepMerge, {
        nullableOfNullable: value$2 !== undefined ? value$2.map((function (value) {
                  if (value !== undefined) {
                    return value;
                  } else {
                    return null;
                  }
                })) : null
      });
  var value$3 = value.l3;
  var value$4 = value$3.nullableOfNullable;
  var l3 = [
      serialize(value$3.frag1),
      serialize(value$3.frag2)
    ].reduce(GraphQL_PPX.deepMerge, {
        nullableOfNullable: value$4 !== undefined ? value$4.map((function (value) {
                  if (value !== undefined) {
                    return value;
                  } else {
                    return null;
                  }
                })) : null
      });
  var value$5 = value.l2;
  var l2 = [
      serialize(value$5.frag1),
      serialize(value$5.frag2)
    ].reduce(GraphQL_PPX.deepMerge, (function (prim) {
          return { };
        }));
  var value$6 = value.l1;
  var l1 = serialize(value$6);
  return {
          l1: l1,
          l2: l2,
          l3: l3,
          l4: l4
        };
}

var Z__INTERNAL$2 = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw$2,
  query: query$1,
  parse: parse$2,
  serialize: serialize$2,
  Z__INTERNAL: Z__INTERNAL$2
};

var Raw$3 = { };

var query$2 = \\"query   {\\\\nlists  {\\\\n...ListFragment   \\\\n}\\\\n\\\\n}\\\\nfragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";

function parse$3(value) {
  return {
          lists: parse(value.lists)
        };
}

function serialize$3(value) {
  var value$1 = value.lists;
  var lists = serialize(value$1);
  return {
          lists: lists
        };
}

var Z__INTERNAL$3 = {
  graphql_module: 0
};

var MyQuery2 = {
  Raw: Raw$3,
  query: query$2,
  parse: parse$3,
  serialize: serialize$3,
  Z__INTERNAL: Z__INTERNAL$3
};

exports.Fragments = Fragments;
exports.MyQuery = MyQuery;
exports.MyQuery2 = MyQuery2;
/* No side effect */
"
`;

exports[`Compilation (Records) interface.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
"
`;

exports[`Compilation (Records) lists.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nullableOfNullable;
  var value$3 = value$1.nullableOfNonNullable;
  var value$4 = value$1.nonNullableOfNullable;
  var value$5 = value$1.nonNullableOfNonNullable;
  return {
          lists: {
            nullableOfNullable: (value$2 == null) ? undefined : value$2.map((function (value) {
                      if (value == null) {
                        return ;
                      } else {
                        return value;
                      }
                    })),
            nullableOfNonNullable: (value$3 == null) ? undefined : value$3.map((function (value) {
                      return value;
                    })),
            nonNullableOfNullable: value$4.map((function (value) {
                    if (value == null) {
                      return ;
                    } else {
                      return value;
                    }
                  })),
            nonNullableOfNonNullable: value$5.map((function (value) {
                    return value;
                  }))
          }
        };
}

function serialize(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (value !== undefined) {
            return value;
          } else {
            return null;
          }
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = value$4 !== undefined ? value$4.map((function (value) {
            return value;
          })) : null;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = value$5 !== undefined ? value$5.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  var lists = {
    nullableOfNullable: nullableOfNullable,
    nullableOfNonNullable: nullableOfNonNullable,
    nonNullableOfNullable: nonNullableOfNullable,
    nonNullableOfNonNullable: nonNullableOfNonNullable
  };
  return {
          lists: lists
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) listsArgs.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require(\\"bs-platform/lib/js/array.js\\");

var Raw = { };

function parse(value) {
  return {
          listsInput: value.listsInput
        };
}

function serialize(value) {
  var value$1 = value.listsInput;
  return {
          listsInput: value$1
        };
}

function serializeVariables(inp) {
  var a = inp.nullableOfNullable;
  var tmp;
  if (a !== undefined) {
    var a$1 = a;
    tmp = $$Array.map((function (b) {
            if (b !== undefined) {
              return b;
            }
            
          }), a$1);
  } else {
    tmp = undefined;
  }
  var a$2 = inp.nullableOfNonNullable;
  var tmp$1;
  if (a$2 !== undefined) {
    var a$3 = a$2;
    tmp$1 = $$Array.map((function (b) {
            return b;
          }), a$3);
  } else {
    tmp$1 = undefined;
  }
  var a$4 = inp.nonNullableOfNullable;
  var a$5 = inp.nonNullableOfNonNullable;
  return {
          nullableOfNullable: tmp,
          nullableOfNonNullable: tmp$1,
          nonNullableOfNullable: $$Array.map((function (b) {
                  if (b !== undefined) {
                    return b;
                  }
                  
                }), a$4),
          nonNullableOfNonNullable: $$Array.map((function (b) {
                  return b;
                }), a$5)
        };
}

function makeVariables(nullableOfNullable, nullableOfNonNullable, nonNullableOfNullable, nonNullableOfNonNullable, param) {
  return serializeVariables({
              nullableOfNullable: nullableOfNullable,
              nullableOfNonNullable: nullableOfNonNullable,
              nonNullableOfNullable: nonNullableOfNullable,
              nonNullableOfNonNullable: nonNullableOfNonNullable
            });
}

var Z__INTERNAL = {
  _graphql_arg_219: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($nullableOfNullable: [String], $nullableOfNonNullable: [String!], $nonNullableOfNullable: [String]!, $nonNullableOfNonNullable: [String!]!)  {\\\\nlistsInput(arg: {nullableOfNullable: $nullableOfNullable, nullableOfNonNullable: $nullableOfNonNullable, nonNullableOfNullable: $nonNullableOfNullable, nonNullableOfNonNullable: $nonNullableOfNonNullable})  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) listsInput.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require(\\"bs-platform/lib/js/array.js\\");

var Raw = { };

function parse(value) {
  return {
          listsInput: value.listsInput
        };
}

function serialize(value) {
  var value$1 = value.listsInput;
  return {
          listsInput: value$1
        };
}

function serializeInputObjectListsInput(inp) {
  var a = inp.nullableOfNullable;
  var tmp;
  if (a !== undefined) {
    var a$1 = a;
    tmp = $$Array.map((function (b) {
            if (b !== undefined) {
              return b;
            }
            
          }), a$1);
  } else {
    tmp = undefined;
  }
  var a$2 = inp.nullableOfNonNullable;
  var tmp$1;
  if (a$2 !== undefined) {
    var a$3 = a$2;
    tmp$1 = $$Array.map((function (b) {
            return b;
          }), a$3);
  } else {
    tmp$1 = undefined;
  }
  var a$4 = inp.nonNullableOfNullable;
  var a$5 = inp.nonNullableOfNonNullable;
  return {
          nullableOfNullable: tmp,
          nullableOfNonNullable: tmp$1,
          nonNullableOfNullable: $$Array.map((function (b) {
                  if (b !== undefined) {
                    return b;
                  }
                  
                }), a$4),
          nonNullableOfNonNullable: $$Array.map((function (b) {
                  return b;
                }), a$5)
        };
}

function serializeVariables(inp) {
  return {
          arg: serializeInputObjectListsInput(inp.arg)
        };
}

function makeVariables(arg, param) {
  return {
          arg: serializeInputObjectListsInput(arg)
        };
}

function makeInputObjectListsInput(nullableOfNullable, nullableOfNonNullable, nonNullableOfNullable, nonNullableOfNonNullable, param) {
  return {
          nullableOfNullable: nullableOfNullable,
          nullableOfNonNullable: nullableOfNonNullable,
          nonNullableOfNullable: nonNullableOfNullable,
          nonNullableOfNonNullable: nonNullableOfNonNullable
        };
}

var Z__INTERNAL = {
  _graphql_arg_82: 0,
  _graphql_arg_77: 0,
  _graphql_ListsInput_47: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($arg: ListsInput!)  {\\\\nlistsInput(arg: $arg)  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  serializeInputObjectListsInput: serializeInputObjectListsInput,
  makeVariables: makeVariables,
  makeInputObjectListsInput: makeInputObjectListsInput,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) mutation.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.value;
  var value$3 = value$1.errors;
  return {
          mutationWithError: {
            value: (value$2 == null) ? undefined : ({
                  stringField: value$2.stringField
                }),
            errors: (value$3 == null) ? undefined : value$3.map((function (value) {
                      var value$1 = value.field;
                      var tmp;
                      switch (value$1) {
                        case \\"FIRST\\" :
                            tmp = /* FIRST */-24399856;
                            break;
                        case \\"SECOND\\" :
                            tmp = /* SECOND */382368628;
                            break;
                        case \\"THIRD\\" :
                            tmp = /* THIRD */225952583;
                            break;
                        default:
                          tmp = /* \`FutureAddedValue */[
                            -31101740,
                            value$1
                          ];
                      }
                      return {
                              field: tmp,
                              message: value.message
                            };
                    }))
          }
        };
}

function serialize(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  var errors = value$2 !== undefined ? value$2.map((function (value) {
            var value$1 = value.message;
            var value$2 = value.field;
            var field = typeof value$2 === \\"number\\" ? (
                value$2 !== 225952583 ? (
                    value$2 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
                  ) : \\"THIRD\\"
              ) : value$2[1];
            return {
                    field: field,
                    message: value$1
                  };
          })) : null;
  var value$3 = value$1.value;
  var value$4;
  if (value$3 !== undefined) {
    var value$5 = value$3.stringField;
    value$4 = {
      stringField: value$5
    };
  } else {
    value$4 = null;
  }
  var mutationWithError = {
    value: value$4,
    errors: errors
  };
  return {
          mutationWithError: mutationWithError
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"mutation   {\\\\nmutationWithError  {\\\\nvalue  {\\\\nstringField  \\\\n}\\\\n\\\\nerrors  {\\\\nfield  \\\\nmessage  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) mutationWithArgs.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          optionalInputArgs: value.optionalInputArgs
        };
}

function serialize(value) {
  var value$1 = value.optionalInputArgs;
  return {
          optionalInputArgs: value$1
        };
}

function serializeVariables(inp) {
  return {
          required: inp.required
        };
}

function makeVariables(required, param) {
  return {
          required: required
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) mutationWithArgsAndNoRecords.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          optionalInputArgs: value.optionalInputArgs
        };
}

function serialize(value) {
  return {
          optionalInputArgs: value.optionalInputArgs
        };
}

function serializeVariables(inp) {
  return {
          required: inp.required
        };
}

function makeVariables(required, param) {
  return serializeVariables({
              required: required
            });
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) nested.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.first;
  var value$2 = value$1.inner;
  var tmp;
  if (value$2 == null) {
    tmp = undefined;
  } else {
    var value$3 = value$2.inner;
    tmp = {
      inner: (value$3 == null) ? undefined : ({
            field: value$3.field
          })
    };
  }
  var value$4 = value.second;
  var value$5 = value$4.inner;
  var tmp$1;
  if (value$5 == null) {
    tmp$1 = undefined;
  } else {
    var value$6 = value$5.inner;
    tmp$1 = {
      inner: (value$6 == null) ? undefined : ({
            f1: value$6.f1,
            f2: value$6.f2
          })
    };
  }
  var value$7 = value.let_;
  var value$8 = value$7.inner;
  var tmp$2;
  if (value$8 == null) {
    tmp$2 = undefined;
  } else {
    var value$9 = value$8.inner;
    tmp$2 = {
      inner: (value$9 == null) ? undefined : ({
            field: value$9.field
          })
    };
  }
  return {
          first: {
            inner: tmp
          },
          second: {
            inner: tmp$1
          },
          let_: {
            inner: tmp$2
          }
        };
}

function serialize(value) {
  var value$1 = value.let_;
  var value$2 = value$1.inner;
  var inner;
  if (value$2 !== undefined) {
    var value$3 = value$2.inner;
    var inner$1;
    if (value$3 !== undefined) {
      var value$4 = value$3.field;
      inner$1 = {
        field: value$4
      };
    } else {
      inner$1 = null;
    }
    inner = {
      inner: inner$1
    };
  } else {
    inner = null;
  }
  var let_ = {
    inner: inner
  };
  var value$5 = value.second;
  var value$6 = value$5.inner;
  var inner$2;
  if (value$6 !== undefined) {
    var value$7 = value$6.inner;
    var inner$3;
    if (value$7 !== undefined) {
      var value$8 = value$7;
      var value$9 = value$8.f2;
      var value$10 = value$8.f1;
      inner$3 = {
        f1: value$10,
        f2: value$9
      };
    } else {
      inner$3 = null;
    }
    inner$2 = {
      inner: inner$3
    };
  } else {
    inner$2 = null;
  }
  var second = {
    inner: inner$2
  };
  var value$11 = value.first;
  var value$12 = value$11.inner;
  var inner$4;
  if (value$12 !== undefined) {
    var value$13 = value$12.inner;
    var inner$5;
    if (value$13 !== undefined) {
      var value$14 = value$13.field;
      inner$5 = {
        field: value$14
      };
    } else {
      inner$5 = null;
    }
    inner$4 = {
      inner: inner$5
    };
  } else {
    inner$4 = null;
  }
  var first = {
    inner: inner$4
  };
  return {
          first: first,
          second: second,
          let_: let_
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nfirst: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nsecond: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nf1: field  \\\\nf2: field  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nlet: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) nonrecursiveInput.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require(\\"bs-platform/lib/js/array.js\\");
var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

function parse(value) {
  return {
          nonrecursiveInput: value.nonrecursiveInput
        };
}

function serialize(value) {
  var value$1 = value.nonrecursiveInput;
  return {
          nonrecursiveInput: value$1
        };
}

function serializeInputObjectEmbeddedInput(inp) {
  var a = inp.field;
  return {
          field: a !== undefined ? a : undefined
        };
}

function serializeInputObjectNonrecursiveInput(inp) {
  var a = inp.nullableArray;
  var tmp;
  if (a !== undefined) {
    var a$1 = a;
    tmp = $$Array.map((function (b) {
            if (b !== undefined) {
              return b;
            }
            
          }), a$1);
  } else {
    tmp = undefined;
  }
  var a$2 = inp.field;
  var a$3 = inp.enum;
  var tmp$1;
  if (a$3 !== undefined) {
    var a$4 = a$3;
    tmp$1 = a$4 !== 225952583 ? (
        a$4 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
      ) : \\"THIRD\\";
  } else {
    tmp$1 = undefined;
  }
  var a$5 = inp.embeddedInput;
  var tmp$2;
  if (a$5 !== undefined) {
    var a$6 = a$5;
    tmp$2 = $$Array.map((function (b) {
            if (b !== undefined) {
              return serializeInputObjectEmbeddedInput(b);
            }
            
          }), a$6);
  } else {
    tmp$2 = undefined;
  }
  var a$7 = inp.custom;
  return {
          nonNullableField: inp.nonNullableField,
          nullableArray: tmp,
          field: a$2 !== undefined ? a$2 : undefined,
          enum: tmp$1,
          embeddedInput: tmp$2,
          custom: a$7 !== undefined ? Caml_option.valFromOption(a$7) : undefined
        };
}

function serializeVariables(inp) {
  return {
          arg: serializeInputObjectNonrecursiveInput(inp.arg)
        };
}

function makeVariables(arg, param) {
  return {
          arg: serializeInputObjectNonrecursiveInput(arg)
        };
}

function makeInputObjectNonrecursiveInput(nonNullableField, nullableArray, field, $$enum, embeddedInput, custom, param) {
  return {
          nonNullableField: nonNullableField,
          nullableArray: nullableArray,
          field: field,
          enum: $$enum,
          embeddedInput: embeddedInput,
          custom: custom
        };
}

function makeInputObjectEmbeddedInput(field, param) {
  return {
          field: field
        };
}

var Z__INTERNAL = {
  _graphql_arg_100: 0,
  _graphql_arg_95: 0,
  _graphql_NonrecursiveInput_49: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  serializeInputObjectNonrecursiveInput: serializeInputObjectNonrecursiveInput,
  serializeInputObjectEmbeddedInput: serializeInputObjectEmbeddedInput,
  makeVariables: makeVariables,
  makeInputObjectNonrecursiveInput: makeInputObjectNonrecursiveInput,
  makeInputObjectEmbeddedInput: makeInputObjectEmbeddedInput,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  return {
          scalarsInput: value.scalarsInput,
          more: value.more
        };
}

function serialize$1(value) {
  var value$1 = value.more;
  var value$2 = value.scalarsInput;
  return {
          scalarsInput: value$2,
          more: value$1
        };
}

function serializeInputObjectEmbeddedInput$1(inp) {
  var a = inp.field;
  return {
          field: a !== undefined ? a : undefined
        };
}

function serializeInputObjectNonrecursiveInput$1(inp) {
  var a = inp.nullableArray;
  var tmp;
  if (a !== undefined) {
    var a$1 = a;
    tmp = $$Array.map((function (b) {
            if (b !== undefined) {
              return b;
            }
            
          }), a$1);
  } else {
    tmp = undefined;
  }
  var a$2 = inp.field;
  var a$3 = inp.enum;
  var tmp$1;
  if (a$3 !== undefined) {
    var a$4 = a$3;
    tmp$1 = a$4 !== 225952583 ? (
        a$4 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
      ) : \\"THIRD\\";
  } else {
    tmp$1 = undefined;
  }
  var a$5 = inp.embeddedInput;
  var tmp$2;
  if (a$5 !== undefined) {
    var a$6 = a$5;
    tmp$2 = $$Array.map((function (b) {
            if (b !== undefined) {
              return serializeInputObjectEmbeddedInput$1(b);
            }
            
          }), a$6);
  } else {
    tmp$2 = undefined;
  }
  var a$7 = inp.custom;
  return {
          nonNullableField: inp.nonNullableField,
          nullableArray: tmp,
          field: a$2 !== undefined ? a$2 : undefined,
          enum: tmp$1,
          embeddedInput: tmp$2,
          custom: a$7 !== undefined ? Caml_option.valFromOption(a$7) : undefined
        };
}

function serializeVariables$1(inp) {
  return {
          arg: serializeInputObjectNonrecursiveInput$1(inp.arg),
          arg2: serializeInputObjectNonrecursiveInput$1(inp.arg2)
        };
}

function makeVariables$1(arg, arg2, param) {
  return serializeVariables$1({
              arg: arg,
              arg2: arg2
            });
}

function makeInputObjectNonrecursiveInput$1(nonNullableField, nullableArray, field, $$enum, embeddedInput, custom, param) {
  return {
          nonNullableField: nonNullableField,
          nullableArray: nullableArray,
          field: field,
          enum: $$enum,
          embeddedInput: embeddedInput,
          custom: custom
        };
}

function makeInputObjectEmbeddedInput$1(field, param) {
  return {
          field: field
        };
}

var Z__INTERNAL$1 = {
  _graphql_arg_240: 0,
  _graphql_arg_235: 0,
  _graphql_NonrecursiveInput_169: 0,
  _graphql_NonrecursiveInput_196: 0,
  graphql_module: 0
};

var MyQuery2 = {
  Raw: Raw$1,
  query: \\"query ($arg: NonrecursiveInput!, $arg2: NonrecursiveInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\nmore: scalarsInput(arg: $arg2)  \\\\n}\\\\n\\",
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  serializeInputObjectNonrecursiveInput: serializeInputObjectNonrecursiveInput$1,
  serializeInputObjectEmbeddedInput: serializeInputObjectEmbeddedInput$1,
  makeVariables: makeVariables$1,
  makeInputObjectNonrecursiveInput: makeInputObjectNonrecursiveInput$1,
  makeInputObjectEmbeddedInput: makeInputObjectEmbeddedInput$1,
  Z__INTERNAL: Z__INTERNAL$1
};

exports.MyQuery = MyQuery;
exports.MyQuery2 = MyQuery2;
/* No side effect */
"
`;

exports[`Compilation (Records) omitFutureValueEnum.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_builtin_exceptions = require(\\"bs-platform/lib/js/caml_builtin_exceptions.js\\");

var Raw = { };

function parse(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  return {
          mutationWithError: {
            errors: (value$2 == null) ? undefined : value$2.map((function (value) {
                      var value$1 = value.field;
                      var tmp;
                      switch (value$1) {
                        case \\"FIRST\\" :
                            tmp = /* FIRST */-24399856;
                            break;
                        case \\"SECOND\\" :
                            tmp = /* SECOND */382368628;
                            break;
                        case \\"THIRD\\" :
                            tmp = /* THIRD */225952583;
                            break;
                        default:
                          tmp = /* \`FutureAddedValue */[
                            -31101740,
                            value$1
                          ];
                      }
                      return {
                              message: value.message,
                              field: tmp
                            };
                    }))
          }
        };
}

function serialize(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  var errors = value$2 !== undefined ? value$2.map((function (value) {
            var value$1 = value.field;
            var field = typeof value$1 === \\"number\\" ? (
                value$1 !== 225952583 ? (
                    value$1 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
                  ) : \\"THIRD\\"
              ) : value$1[1];
            var value$2 = value.message;
            return {
                    message: value$2,
                    field: field
                  };
          })) : null;
  var mutationWithError = {
    errors: errors
  };
  return {
          mutationWithError: mutationWithError
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var Normal = {
  Raw: Raw,
  query: \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  return {
          mutationWithError: {
            errors: (value$2 == null) ? undefined : value$2.map((function (value) {
                      var value$1 = value.field;
                      var tmp;
                      switch (value$1) {
                        case \\"FIRST\\" :
                            tmp = /* FIRST */-24399856;
                            break;
                        case \\"SECOND\\" :
                            tmp = /* SECOND */382368628;
                            break;
                        case \\"THIRD\\" :
                            tmp = /* THIRD */225952583;
                            break;
                        default:
                          throw Caml_builtin_exceptions.not_found;
                      }
                      return {
                              message: value.message,
                              field: tmp
                            };
                    }))
          }
        };
}

function serialize$1(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  var errors = value$2 !== undefined ? value$2.map((function (value) {
            var value$1 = value.field;
            var field = value$1 !== 225952583 ? (
                value$1 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
              ) : \\"THIRD\\";
            var value$2 = value.message;
            return {
                    message: value$2,
                    field: field
                  };
          })) : null;
  var mutationWithError = {
    errors: errors
  };
  return {
          mutationWithError: mutationWithError
        };
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var ByConfig = {
  Raw: Raw$1,
  query: \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$1,
  serialize: serialize$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var Raw$2 = { };

function parse$2(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  return {
          mutationWithError: {
            errors: (value$2 == null) ? undefined : value$2.map((function (value) {
                      var value$1 = value.field;
                      var tmp;
                      switch (value$1) {
                        case \\"FIRST\\" :
                            tmp = /* FIRST */-24399856;
                            break;
                        case \\"SECOND\\" :
                            tmp = /* SECOND */382368628;
                            break;
                        case \\"THIRD\\" :
                            tmp = /* THIRD */225952583;
                            break;
                        default:
                          throw Caml_builtin_exceptions.not_found;
                      }
                      return {
                              message: value.message,
                              field: tmp
                            };
                    }))
          }
        };
}

function serialize$2(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  var errors = value$2 !== undefined ? value$2.map((function (value) {
            var value$1 = value.field;
            var field = value$1 !== 225952583 ? (
                value$1 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
              ) : \\"THIRD\\";
            var value$2 = value.message;
            return {
                    message: value$2,
                    field: field
                  };
          })) : null;
  var mutationWithError = {
    errors: errors
  };
  return {
          mutationWithError: mutationWithError
        };
}

var Z__INTERNAL$2 = {
  graphql_module: 0
};

var ByDirective = {
  Raw: Raw$2,
  query: \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield @ppxOmitFutureValue \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$2,
  serialize: serialize$2,
  Z__INTERNAL: Z__INTERNAL$2
};

exports.Normal = Normal;
exports.ByConfig = ByConfig;
exports.ByDirective = ByDirective;
/* No side effect */
"
`;

exports[`Compilation (Records) omitFutureValueUnion.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_builtin_exceptions = require(\\"bs-platform/lib/js/caml_builtin_exceptions.js\\");

var Raw = { };

function parse(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$1.name,
            barkVolume: value$1.barkVolume
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      tmp = /* \`FutureAddedValue */[
        -31101740,
        value$1
      ];
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize(value) {
  var value$1 = value.dogOrHuman;
  var variant = value$1[0];
  var dogOrHuman;
  if (variant !== -31101740) {
    if (variant >= 3406428) {
      var value$2 = value$1[1];
      var value$3 = value$2.barkVolume;
      var value$4 = value$2.name;
      dogOrHuman = {
        __typename: \\"Dog\\",
        name: value$4,
        barkVolume: value$3
      };
    } else {
      var value$5 = value$1[1].name;
      dogOrHuman = {
        __typename: \\"Human\\",
        name: value$5
      };
    }
  } else {
    dogOrHuman = value$1[1];
  }
  return {
          dogOrHuman: dogOrHuman
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var Normal = {
  Raw: Raw,
  query: \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$1.name,
            barkVolume: value$1.barkVolume
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      throw Caml_builtin_exceptions.not_found;
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize$1(value) {
  var value$1 = value.dogOrHuman;
  var dogOrHuman;
  if (value$1[0] >= 3406428) {
    var value$2 = value$1[1];
    var value$3 = value$2.barkVolume;
    var value$4 = value$2.name;
    dogOrHuman = {
      __typename: \\"Dog\\",
      name: value$4,
      barkVolume: value$3
    };
  } else {
    var value$5 = value$1[1].name;
    dogOrHuman = {
      __typename: \\"Human\\",
      name: value$5
    };
  }
  return {
          dogOrHuman: dogOrHuman
        };
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var ByConfig = {
  Raw: Raw$1,
  query: \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$1,
  serialize: serialize$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var Raw$2 = { };

function parse$2(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$1.name,
            barkVolume: value$1.barkVolume
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      throw Caml_builtin_exceptions.not_found;
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize$2(value) {
  var value$1 = value.dogOrHuman;
  var dogOrHuman;
  if (value$1[0] >= 3406428) {
    var value$2 = value$1[1];
    var value$3 = value$2.barkVolume;
    var value$4 = value$2.name;
    dogOrHuman = {
      __typename: \\"Dog\\",
      name: value$4,
      barkVolume: value$3
    };
  } else {
    var value$5 = value$1[1].name;
    dogOrHuman = {
      __typename: \\"Human\\",
      name: value$5
    };
  }
  return {
          dogOrHuman: dogOrHuman
        };
}

var Z__INTERNAL$2 = {
  graphql_module: 0
};

var ByDirective = {
  Raw: Raw$2,
  query: \\"query   {\\\\ndogOrHuman @ppxOmitFutureValue {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$2,
  serialize: serialize$2,
  Z__INTERNAL: Z__INTERNAL$2
};

exports.Normal = Normal;
exports.ByConfig = ByConfig;
exports.ByDirective = ByDirective;
/* No side effect */
"
`;

exports[`Compilation (Records) pokedexApolloMode.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.pokemon;
  var tmp;
  if (value$1 == null) {
    tmp = undefined;
  } else {
    var value$2 = value$1.name;
    tmp = {
      id: value$1.id,
      name: (value$2 == null) ? undefined : value$2
    };
  }
  return {
          pokemon: tmp
        };
}

function serialize(value) {
  var value$1 = value.pokemon;
  var pokemon;
  if (value$1 !== undefined) {
    var value$2 = value$1;
    var value$3 = value$2.name;
    var name = value$3 !== undefined ? value$3 : null;
    var value$4 = value$2.id;
    pokemon = {
      id: value$4,
      name: name
    };
  } else {
    pokemon = null;
  }
  return {
          pokemon: pokemon
        };
}

var Z__INTERNAL = {
  _graphql_name_52: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\npokemon(name: \\\\\\"Pikachu\\\\\\")  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) pokedexScalars.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.pokemon;
  var tmp;
  if (value$1 == null) {
    tmp = undefined;
  } else {
    var value$2 = value$1.name;
    tmp = {
      id: value$1.id,
      name: (value$2 == null) ? undefined : value$2
    };
  }
  return {
          pokemon: tmp
        };
}

function serialize(value) {
  var value$1 = value.pokemon;
  var pokemon;
  if (value$1 !== undefined) {
    var value$2 = value$1;
    var value$3 = value$2.name;
    var name = value$3 !== undefined ? value$3 : null;
    var value$4 = value$2.id;
    pokemon = {
      id: value$4,
      name: name
    };
  } else {
    pokemon = null;
  }
  return {
          pokemon: pokemon
        };
}

function serializeVariables(inp) {
  var a = inp.id;
  var a$1 = inp.name;
  return {
          id: a !== undefined ? a : undefined,
          name: a$1 !== undefined ? a$1 : undefined
        };
}

function makeVariables(id, name, param) {
  return serializeVariables({
              id: id,
              name: name
            });
}

var Z__INTERNAL = {
  _graphql_name_100: 0,
  _graphql_name_94: 0,
  _graphql_id_111: 0,
  _graphql_id_107: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query pokemon($id: String, $name: String)  {\\\\npokemon(name: $name, id: $id)  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) record.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.variousScalars;
  return {
          variousScalars: {
            string: value$1.string,
            int: value$1.int
          }
        };
}

function serialize(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.int;
  var value$3 = value$1.string;
  var variousScalars = {
    string: value$3,
    int: value$2
  };
  return {
          variousScalars: variousScalars
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  return {
          variousScalars: {
            nullableString: (value$2 == null) ? undefined : value$2
          }
        };
}

function serialize$1(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  var nullableString = value$2 !== undefined ? value$2 : null;
  var variousScalars = {
    nullableString: nullableString
  };
  return {
          variousScalars: variousScalars
        };
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var OneFieldQuery = {
  Raw: Raw$1,
  query: \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$1,
  serialize: serialize$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var query = \\"fragment Fragment on VariousScalars   {\\\\nstring  \\\\nint  \\\\n}\\\\n\\";

var Raw$2 = { };

function parse$2(value) {
  return {
          string: value.string,
          int: value.int
        };
}

function serialize$2(value) {
  var value$1 = value.int;
  var value$2 = value.string;
  return {
          string: value$2,
          int: value$1
        };
}

var name = \\"Fragment\\";

var Z__INTERNAL$2 = {
  graphql: 0,
  graphql_module: 0
};

var Fragment = {
  query: query,
  Raw: Raw$2,
  parse: parse$2,
  serialize: serialize$2,
  name: name,
  Z__INTERNAL: Z__INTERNAL$2
};

var Raw$3 = { };

var query$1 = \\"query   {\\\\nvariousScalars  {\\\\n...Fragment   \\\\n}\\\\n\\\\n}\\\\nfragment Fragment on VariousScalars   {\\\\nstring  \\\\nint  \\\\n}\\\\n\\";

function parse$3(value) {
  return {
          variousScalars: parse$2(value.variousScalars)
        };
}

function serialize$3(value) {
  var value$1 = value.variousScalars;
  var variousScalars = serialize$2(value$1);
  return {
          variousScalars: variousScalars
        };
}

var Z__INTERNAL$3 = {
  graphql_module: 0
};

var Untitled1 = {
  Raw: Raw$3,
  query: query$1,
  parse: parse$3,
  serialize: serialize$3,
  Z__INTERNAL: Z__INTERNAL$3
};

var ExternalFragmentQuery = {
  Fragment: Fragment,
  Untitled1: Untitled1
};

var Raw$4 = { };

function parse$4(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp = typename === \\"Dog\\" ? /* \`Dog */[
      3406428,
      {
        name: value$1.name,
        barkVolume: value$1.barkVolume
      }
    ] : /* \`FutureAddedValue */[
      -31101740,
      value$1
    ];
  return {
          dogOrHuman: tmp
        };
}

function serialize$4(value) {
  var value$1 = value.dogOrHuman;
  var dogOrHuman;
  if (value$1[0] >= 3406428) {
    var value$2 = value$1[1];
    var value$3 = value$2.barkVolume;
    var value$4 = value$2.name;
    dogOrHuman = {
      __typename: \\"Dog\\",
      name: value$4,
      barkVolume: value$3
    };
  } else {
    dogOrHuman = value$1[1];
  }
  return {
          dogOrHuman: dogOrHuman
        };
}

var Z__INTERNAL$4 = {
  graphql_module: 0
};

var InlineFragmentQuery = {
  Raw: Raw$4,
  query: \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$4,
  serialize: serialize$4,
  Z__INTERNAL: Z__INTERNAL$4
};

var query$2 = \\"fragment DogFragment on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\";

var Raw$5 = { };

function parse$5(value) {
  return {
          name: value.name,
          barkVolume: value.barkVolume
        };
}

function serialize$5(value) {
  var value$1 = value.barkVolume;
  var value$2 = value.name;
  return {
          name: value$2,
          barkVolume: value$1
        };
}

var name$1 = \\"DogFragment\\";

var Z__INTERNAL$5 = {
  graphql: 0,
  graphql_module: 0
};

var DogFragment = {
  query: query$2,
  Raw: Raw$5,
  parse: parse$5,
  serialize: serialize$5,
  name: name$1,
  Z__INTERNAL: Z__INTERNAL$5
};

var Raw$6 = { };

var query$3 = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n...DogFragment   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\nfragment DogFragment on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\";

function parse$6(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp = typename === \\"Dog\\" ? /* \`Dog */[
      3406428,
      parse$5(value$1)
    ] : /* \`FutureAddedValue */[
      -31101740,
      value$1
    ];
  return {
          dogOrHuman: tmp
        };
}

function serialize$6(value) {
  var value$1 = value.dogOrHuman;
  var dogOrHuman = value$1[0] >= 3406428 ? serialize$5(value$1[1]) : value$1[1];
  return {
          dogOrHuman: dogOrHuman
        };
}

var Z__INTERNAL$6 = {
  graphql_module: 0
};

var Untitled1$1 = {
  Raw: Raw$6,
  query: query$3,
  parse: parse$6,
  serialize: serialize$6,
  Z__INTERNAL: Z__INTERNAL$6
};

var UnionExternalFragmentQuery = {
  DogFragment: DogFragment,
  Untitled1: Untitled1$1
};

exports.MyQuery = MyQuery;
exports.OneFieldQuery = OneFieldQuery;
exports.ExternalFragmentQuery = ExternalFragmentQuery;
exports.InlineFragmentQuery = InlineFragmentQuery;
exports.UnionExternalFragmentQuery = UnionExternalFragmentQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) recursiveInput.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          recursiveInput: value.recursiveInput
        };
}

function serialize(value) {
  var value$1 = value.recursiveInput;
  return {
          recursiveInput: value$1
        };
}

function serializeInputObjectRecursiveInput(inp) {
  var a = inp.otherField;
  var a$1 = inp.inner;
  var a$2 = inp.enum;
  var tmp;
  if (a$2 !== undefined) {
    var a$3 = a$2;
    tmp = a$3 !== 225952583 ? (
        a$3 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
      ) : \\"THIRD\\";
  } else {
    tmp = undefined;
  }
  return {
          otherField: a !== undefined ? a : undefined,
          inner: a$1 !== undefined ? serializeInputObjectRecursiveInput(a$1) : undefined,
          enum: tmp
        };
}

function serializeVariables(inp) {
  return {
          arg: serializeInputObjectRecursiveInput(inp.arg)
        };
}

function makeVariables(arg, param) {
  return {
          arg: serializeInputObjectRecursiveInput(arg)
        };
}

function makeInputObjectRecursiveInput(otherField, inner, $$enum, param) {
  return {
          otherField: otherField,
          inner: inner,
          enum: $$enum
        };
}

var Z__INTERNAL = {
  _graphql_arg_90: 0,
  _graphql_arg_85: 0,
  _graphql_RecursiveInput_47: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($arg: RecursiveInput!)  {\\\\nrecursiveInput(arg: $arg)  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  serializeInputObjectRecursiveInput: serializeInputObjectRecursiveInput,
  makeVariables: makeVariables,
  makeInputObjectRecursiveInput: makeInputObjectRecursiveInput,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) scalars.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  var value$3 = value$1.nullableInt;
  var value$4 = value$1.nullableFloat;
  var value$5 = value$1.nullableBoolean;
  var value$6 = value$1.nullableID;
  return {
          variousScalars: {
            nullableString: (value$2 == null) ? undefined : value$2,
            string: value$1.string,
            nullableInt: (value$3 == null) ? undefined : value$3,
            int: value$1.int,
            nullableFloat: (value$4 == null) ? undefined : value$4,
            float: value$1.float,
            nullableBoolean: (value$5 == null) ? undefined : value$5,
            boolean: value$1.boolean,
            nullableID: (value$6 == null) ? undefined : value$6,
            id: value$1.id
          }
        };
}

function serialize(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  var variousScalars = {
    nullableString: nullableString,
    string: value$10,
    nullableInt: nullableInt,
    int: value$8,
    nullableFloat: nullableFloat,
    float: value$6,
    nullableBoolean: nullableBoolean,
    boolean: value$4,
    nullableID: nullableID,
    id: value$2
  };
  return {
          variousScalars: variousScalars
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) scalarsArgs.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          scalarsInput: value.scalarsInput
        };
}

function serialize(value) {
  var value$1 = value.scalarsInput;
  return {
          scalarsInput: value$1
        };
}

function serializeVariables(inp) {
  var a = inp.nullableString;
  var a$1 = inp.nullableInt;
  var a$2 = inp.nullableFloat;
  var a$3 = inp.nullableBoolean;
  var a$4 = inp.nullableID;
  return {
          nullableString: a !== undefined ? a : undefined,
          string: inp.string,
          nullableInt: a$1 !== undefined ? a$1 : undefined,
          int: inp.int,
          nullableFloat: a$2 !== undefined ? a$2 : undefined,
          float: inp.float,
          nullableBoolean: a$3 !== undefined ? a$3 : undefined,
          boolean: inp.boolean,
          nullableID: a$4 !== undefined ? a$4 : undefined,
          id: inp.id
        };
}

function makeVariables(nullableString, string, nullableInt, $$int, nullableFloat, $$float, nullableBoolean, $$boolean, nullableID, id, param) {
  return serializeVariables({
              nullableString: nullableString,
              string: string,
              nullableInt: nullableInt,
              int: $$int,
              nullableFloat: nullableFloat,
              float: $$float,
              nullableBoolean: nullableBoolean,
              boolean: $$boolean,
              nullableID: nullableID,
              id: id
            });
}

var Z__INTERNAL = {
  _graphql_arg_292: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($nullableString: String, $string: String!, $nullableInt: Int, $int: Int!, $nullableFloat: Float, $float: Float!, $nullableBoolean: Boolean, $boolean: Boolean!, $nullableID: ID, $id: ID!)  {\\\\nscalarsInput(arg: {nullableString: $nullableString, string: $string, nullableInt: $nullableInt, int: $int, nullableFloat: $nullableFloat, float: $float, nullableBoolean: $nullableBoolean, boolean: $boolean, nullableID: $nullableID, id: $id})  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) scalarsInput.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          scalarsInput: value.scalarsInput
        };
}

function serialize(value) {
  var value$1 = value.scalarsInput;
  return {
          scalarsInput: value$1
        };
}

function serializeInputObjectVariousScalarsInput(inp) {
  var a = inp.nullableString;
  var a$1 = inp.nullableInt;
  var a$2 = inp.nullableFloat;
  var a$3 = inp.nullableBoolean;
  var a$4 = inp.nullableID;
  return {
          nullableString: a !== undefined ? a : undefined,
          string: inp.string,
          nullableInt: a$1 !== undefined ? a$1 : undefined,
          int: inp.int,
          nullableFloat: a$2 !== undefined ? a$2 : undefined,
          float: inp.float,
          nullableBoolean: a$3 !== undefined ? a$3 : undefined,
          boolean: inp.boolean,
          nullableID: a$4 !== undefined ? a$4 : undefined,
          id: inp.id
        };
}

function serializeVariables(inp) {
  return {
          arg: serializeInputObjectVariousScalarsInput(inp.arg)
        };
}

function makeVariables(arg, param) {
  return {
          arg: serializeInputObjectVariousScalarsInput(arg)
        };
}

function makeInputObjectVariousScalarsInput(nullableString, string, nullableInt, $$int, nullableFloat, $$float, nullableBoolean, $$boolean, nullableID, id, param) {
  return {
          nullableString: nullableString,
          string: string,
          nullableInt: nullableInt,
          int: $$int,
          nullableFloat: nullableFloat,
          float: $$float,
          nullableBoolean: nullableBoolean,
          boolean: $$boolean,
          nullableID: nullableID,
          id: id
        };
}

var Z__INTERNAL = {
  _graphql_arg_93: 0,
  _graphql_arg_88: 0,
  _graphql_VariousScalarsInput_47: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($arg: VariousScalarsInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  serializeInputObjectVariousScalarsInput: serializeInputObjectVariousScalarsInput,
  makeVariables: makeVariables,
  makeInputObjectVariousScalarsInput: makeInputObjectVariousScalarsInput,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) skipDirectives.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.v1;
  var value$2 = value$1.nullableString;
  var value$3 = value$1.string;
  var value$4 = value.v2;
  var value$5 = value$4.nullableString;
  var value$6 = value$4.string;
  return {
          v1: {
            nullableString: (value$2 == null) ? undefined : value$2,
            string: (value$3 == null) ? undefined : value$3
          },
          v2: {
            nullableString: (value$5 == null) ? undefined : value$5,
            string: (value$6 == null) ? undefined : value$6
          }
        };
}

function serialize(value) {
  var value$1 = value.v2;
  var value$2 = value$1.string;
  var string = value$2 !== undefined ? value$2 : null;
  var value$3 = value$1.nullableString;
  var nullableString = value$3 !== undefined ? value$3 : null;
  var v2 = {
    nullableString: nullableString,
    string: string
  };
  var value$4 = value.v1;
  var value$5 = value$4.string;
  var string$1 = value$5 !== undefined ? value$5 : null;
  var value$6 = value$4.nullableString;
  var nullableString$1 = value$6 !== undefined ? value$6 : null;
  var v1 = {
    nullableString: nullableString$1,
    string: string$1
  };
  return {
          v1: v1,
          v2: v2
        };
}

function serializeVariables(inp) {
  return {
          var: inp.var
        };
}

function makeVariables($$var, param) {
  return {
          var: $$var
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($var: Boolean!)  {\\\\nv1: variousScalars  {\\\\nnullableString @skip(if: $var) \\\\nstring @skip(if: $var) \\\\n}\\\\n\\\\nv2: variousScalars  {\\\\nnullableString @include(if: $var) \\\\nstring @include(if: $var) \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) subscription.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.simpleSubscription;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$1.name
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      tmp = /* \`FutureAddedValue */[
        -31101740,
        value$1
      ];
  }
  return {
          simpleSubscription: tmp
        };
}

function serialize(value) {
  var value$1 = value.simpleSubscription;
  var variant = value$1[0];
  var simpleSubscription;
  if (variant !== -31101740) {
    if (variant >= 3406428) {
      var value$2 = value$1[1].name;
      simpleSubscription = {
        __typename: \\"Dog\\",
        name: value$2
      };
    } else {
      var value$3 = value$1[1].name;
      simpleSubscription = {
        __typename: \\"Human\\",
        name: value$3
      };
    }
  } else {
    simpleSubscription = value$1[1];
  }
  return {
          simpleSubscription: simpleSubscription
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"subscription   {\\\\nsimpleSubscription  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) tagged_template.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  var value$3 = value$1.nullableInt;
  var value$4 = value$1.nullableFloat;
  var value$5 = value$1.nullableBoolean;
  var value$6 = value$1.nullableID;
  return {
          variousScalars: {
            nullableString: (value$2 == null) ? undefined : value$2,
            string: value$1.string,
            nullableInt: (value$3 == null) ? undefined : value$3,
            int: value$1.int,
            nullableFloat: (value$4 == null) ? undefined : value$4,
            float: value$1.float,
            nullableBoolean: (value$5 == null) ? undefined : value$5,
            boolean: value$1.boolean,
            nullableID: (value$6 == null) ? undefined : value$6,
            id: value$1.id
          }
        };
}

function serialize(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  var variousScalars = {
    nullableString: nullableString,
    string: value$10,
    nullableInt: nullableInt,
    int: value$8,
    nullableFloat: nullableFloat,
    float: value$6,
    nullableBoolean: nullableBoolean,
    boolean: value$4,
    nullableID: nullableID,
    id: value$2
  };
  return {
          variousScalars: variousScalars
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

let { graphql } = require(\\"gatsby\\")
;

var query = (graphql\`
  query   {
    variousScalars  {
      nullableString
      string
      nullableInt
      int
      nullableFloat
      float
      nullableBoolean
      boolean
      nullableID
      id
    }
  }
\`);

function parse$1(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  var value$3 = value$1.nullableInt;
  var value$4 = value$1.nullableFloat;
  var value$5 = value$1.nullableBoolean;
  var value$6 = value$1.nullableID;
  return {
          variousScalars: {
            nullableString: (value$2 == null) ? undefined : value$2,
            string: value$1.string,
            nullableInt: (value$3 == null) ? undefined : value$3,
            int: value$1.int,
            nullableFloat: (value$4 == null) ? undefined : value$4,
            float: value$1.float,
            nullableBoolean: (value$5 == null) ? undefined : value$5,
            boolean: value$1.boolean,
            nullableID: (value$6 == null) ? undefined : value$6,
            id: value$1.id
          }
        };
}

function serialize$1(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  var variousScalars = {
    nullableString: nullableString,
    string: value$10,
    nullableInt: nullableInt,
    int: value$8,
    nullableFloat: nullableFloat,
    float: value$6,
    nullableBoolean: nullableBoolean,
    boolean: value$4,
    nullableID: nullableID,
    id: value$2
  };
  return {
          variousScalars: variousScalars
        };
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var MyQuery2 = {
  Raw: Raw$1,
  query: query,
  parse: parse$1,
  serialize: serialize$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var Raw$2 = { };

let { graphql } = require(\\"gatsby\\")
;

var query$1 = (graphql\`
  query   {
    variousScalars  {
      nullableString
      string
      nullableInt
      int
      nullableFloat
      float
      nullableBoolean
      boolean
      nullableID
      id
    }
  }
\`);

function parse$2(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  var value$3 = value$1.nullableInt;
  var value$4 = value$1.nullableFloat;
  var value$5 = value$1.nullableBoolean;
  var value$6 = value$1.nullableID;
  return {
          variousScalars: {
            nullableString: (value$2 == null) ? undefined : value$2,
            string: value$1.string,
            nullableInt: (value$3 == null) ? undefined : value$3,
            int: value$1.int,
            nullableFloat: (value$4 == null) ? undefined : value$4,
            float: value$1.float,
            nullableBoolean: (value$5 == null) ? undefined : value$5,
            boolean: value$1.boolean,
            nullableID: (value$6 == null) ? undefined : value$6,
            id: value$1.id
          }
        };
}

function serialize$2(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  var variousScalars = {
    nullableString: nullableString,
    string: value$10,
    nullableInt: nullableInt,
    int: value$8,
    nullableFloat: nullableFloat,
    float: value$6,
    nullableBoolean: nullableBoolean,
    boolean: value$4,
    nullableID: nullableID,
    id: value$2
  };
  return {
          variousScalars: variousScalars
        };
}

var Z__INTERNAL$2 = {
  graphql_module: 0
};

var MyQuery3 = {
  Raw: Raw$2,
  query: query$1,
  parse: parse$2,
  serialize: serialize$2,
  Z__INTERNAL: Z__INTERNAL$2
};

var Raw$3 = { };

let graphql = require(\\"gatsby\\")
;

var query$2 = (graphql\`
  query   {
    variousScalars  {
      nullableString
      string
      nullableInt
      int
      nullableFloat
      float
      nullableBoolean
      boolean
      nullableID
      id
    }
  }
\`);

function parse$3(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  var value$3 = value$1.nullableInt;
  var value$4 = value$1.nullableFloat;
  var value$5 = value$1.nullableBoolean;
  var value$6 = value$1.nullableID;
  return {
          variousScalars: {
            nullableString: (value$2 == null) ? undefined : value$2,
            string: value$1.string,
            nullableInt: (value$3 == null) ? undefined : value$3,
            int: value$1.int,
            nullableFloat: (value$4 == null) ? undefined : value$4,
            float: value$1.float,
            nullableBoolean: (value$5 == null) ? undefined : value$5,
            boolean: value$1.boolean,
            nullableID: (value$6 == null) ? undefined : value$6,
            id: value$1.id
          }
        };
}

function serialize$3(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  var variousScalars = {
    nullableString: nullableString,
    string: value$10,
    nullableInt: nullableInt,
    int: value$8,
    nullableFloat: nullableFloat,
    float: value$6,
    nullableBoolean: nullableBoolean,
    boolean: value$4,
    nullableID: nullableID,
    id: value$2
  };
  return {
          variousScalars: variousScalars
        };
}

var Z__INTERNAL$3 = {
  graphql_module: 0
};

var MyQuery4 = {
  Raw: Raw$3,
  query: query$2,
  parse: parse$3,
  serialize: serialize$3,
  Z__INTERNAL: Z__INTERNAL$3
};

exports.MyQuery = MyQuery;
exports.MyQuery2 = MyQuery2;
exports.MyQuery3 = MyQuery3;
exports.MyQuery4 = MyQuery4;
/*  Not a pure module */
"
`;

exports[`Compilation (Records) typename.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.first;
  var value$2 = value$1.inner;
  var tmp;
  if (value$2 == null) {
    tmp = undefined;
  } else {
    var value$3 = value$2.inner;
    tmp = {
      __typename: value$2.__typename,
      inner: (value$3 == null) ? undefined : ({
            __typename: value$3.__typename,
            field: value$3.field
          })
    };
  }
  return {
          first: {
            __typename: value$1.__typename,
            inner: tmp
          }
        };
}

function serialize(value) {
  var value$1 = value.first;
  var value$2 = value$1.inner;
  var inner;
  if (value$2 !== undefined) {
    var value$3 = value$2;
    var value$4 = value$3.inner;
    var inner$1;
    if (value$4 !== undefined) {
      var value$5 = value$4;
      var value$6 = value$5.field;
      var value$7 = value$5.__typename;
      inner$1 = {
        __typename: value$7,
        field: value$6
      };
    } else {
      inner$1 = null;
    }
    var value$8 = value$3.__typename;
    inner = {
      __typename: value$8,
      inner: inner$1
    };
  } else {
    inner = null;
  }
  var value$9 = value$1.__typename;
  var first = {
    __typename: value$9,
    inner: inner
  };
  return {
          first: first
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) union.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$1.name,
            barkVolume: value$1.barkVolume
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      tmp = /* \`FutureAddedValue */[
        -31101740,
        value$1
      ];
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize(value) {
  var value$1 = value.dogOrHuman;
  var variant = value$1[0];
  var dogOrHuman;
  if (variant !== -31101740) {
    if (variant >= 3406428) {
      var value$2 = value$1[1];
      var value$3 = value$2.barkVolume;
      var value$4 = value$2.name;
      dogOrHuman = {
        __typename: \\"Dog\\",
        name: value$4,
        barkVolume: value$3
      };
    } else {
      var value$5 = value$1[1].name;
      dogOrHuman = {
        __typename: \\"Human\\",
        name: value$5
      };
    }
  } else {
    dogOrHuman = value$1[1];
  }
  return {
          dogOrHuman: dogOrHuman
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$1.name,
            barkVolume: value$1.barkVolume
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      tmp = /* \`FutureAddedValue */[
        -31101740,
        value$1
      ];
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize$1(value) {
  var value$1 = value.dogOrHuman;
  var variant = value$1[0];
  var dogOrHuman;
  if (variant !== -31101740) {
    if (variant >= 3406428) {
      var value$2 = value$1[1];
      var value$3 = value$2.barkVolume;
      var value$4 = value$2.name;
      dogOrHuman = {
        __typename: \\"Dog\\",
        name: value$4,
        barkVolume: value$3
      };
    } else {
      var value$5 = value$1[1].name;
      dogOrHuman = {
        __typename: \\"Human\\",
        name: value$5
      };
    }
  } else {
    dogOrHuman = value$1[1];
  }
  return {
          dogOrHuman: dogOrHuman
        };
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var MyQueryNoError = {
  Raw: Raw$1,
  query: \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$1,
  serialize: serialize$1,
  Z__INTERNAL: Z__INTERNAL$1
};

exports.MyQuery = MyQuery;
exports.MyQueryNoError = MyQueryNoError;
/* No side effect */
"
`;

exports[`Compilation (Records) unionPartial.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp = typename === \\"Dog\\" ? /* \`Dog */[
      3406428,
      {
        name: value$1.name,
        barkVolume: value$1.barkVolume
      }
    ] : /* \`FutureAddedValue */[
      -31101740,
      value$1
    ];
  return {
          dogOrHuman: tmp
        };
}

function serialize(value) {
  var value$1 = value.dogOrHuman;
  var dogOrHuman;
  if (value$1[0] >= 3406428) {
    var value$2 = value$1[1];
    var value$3 = value$2.barkVolume;
    var value$4 = value$2.name;
    dogOrHuman = {
      __typename: \\"Dog\\",
      name: value$4,
      barkVolume: value$3
    };
  } else {
    dogOrHuman = value$1[1];
  }
  return {
          dogOrHuman: dogOrHuman
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) variant.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Js_exn = require(\\"bs-platform/lib/js/js_exn.js\\");
var Js_json = require(\\"bs-platform/lib/js/js_json.js\\");
var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

function parse(value) {
  var value$1 = value.mutationForVariant;
  var match = Js_json.decodeObject(value$1);
  var tmp;
  if (match !== undefined) {
    var value$2 = Caml_option.valFromOption(match);
    var temp = value$2[\\"baseType\\"];
    var match$1 = Js_json.decodeNull(temp);
    if (match$1 !== undefined) {
      var temp$1 = value$2[\\"baseTypeList\\"];
      var match$2 = Js_json.decodeNull(temp$1);
      if (match$2 !== undefined) {
        var temp$2 = value$2[\\"dog\\"];
        var match$3 = Js_json.decodeNull(temp$2);
        if (match$3 !== undefined) {
          var temp$3 = value$2[\\"human\\"];
          var match$4 = Js_json.decodeNull(temp$3);
          if (match$4 !== undefined) {
            var temp$4 = value$2[\\"dogOrHuman\\"];
            var match$5 = Js_json.decodeNull(temp$4);
            if (match$5 !== undefined) {
              tmp = Js_exn.raiseError(\\"graphql_ppx: All fields on variant selection set on type VariantTestResult were null\\");
            } else {
              var typename = temp$4[\\"__typename\\"];
              var tmp$1;
              switch (typename) {
                case \\"Dog\\" :
                    tmp$1 = /* \`Dog */[
                      3406428,
                      {
                        name: temp$4.name,
                        barkVolume: temp$4.barkVolume
                      }
                    ];
                    break;
                case \\"Human\\" :
                    tmp$1 = /* \`Human */[
                      -1031617139,
                      {
                        name: temp$4.name
                      }
                    ];
                    break;
                default:
                  tmp$1 = /* \`FutureAddedValue */[
                    -31101740,
                    temp$4
                  ];
              }
              tmp = /* \`DogOrHuman */[
                974247566,
                tmp$1
              ];
            }
          } else {
            tmp = /* \`Human */[
              -1031617139,
              {
                name: temp$3.name
              }
            ];
          }
        } else {
          tmp = /* \`Dog */[
            3406428,
            {
              name: temp$2.name,
              barkVolume: temp$2.barkVolume
            }
          ];
        }
      } else {
        tmp = /* \`BaseTypeList */[
          -259847799,
          temp$1.map((function (value) {
                  return value;
                }))
        ];
      }
    } else {
      tmp = /* \`BaseType */[
        -620191861,
        temp
      ];
    }
  } else {
    tmp = Js_exn.raiseError(\\"graphql_ppx: Expected type VariantTestResult to be an object\\");
  }
  return {
          mutationForVariant: tmp
        };
}

function serialize(value) {
  var mutationForVariant = null;
  return {
          mutationForVariant: mutationForVariant
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"mutation   {\\\\nmutationForVariant  {\\\\nbaseType  \\\\nbaseTypeList  \\\\ndog  {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\nhuman  {\\\\nname  \\\\n}\\\\n\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Errors (Objects) InvalidObjectValues2.re 1`] = `
"We've found a bug for you!
  operations/errors/InvalidObjectValues2.re 8:13-18
  
   6 ┆ query {
   7 ┆     invalidObjectValues(
   8 ┆         nonRec: {
   9 ┆             nullableArray: [\\"\\"]
  10 ┆             field: \\"\\"
  
  Invalid argument. The field \\"nonNullableField\\" on argument \\"nonRec\\" is missing."
`;

exports[`Errors (Objects) InvalidObjectValues3.re 1`] = `
"We've found a bug for you!
  operations/errors/InvalidObjectValues3.re 9:35
  
   7 ┆ invalidObjectValues(
   8 ┆     nonRec: {
   9 ┆         nonNullableField: 5
  10 ┆         nullableArray: [\\"\\"]
  11 ┆         field: \\"\\"
  
  Invalid argument. Expected \\"String!\\" but received \\"Int!\\"."
`;

exports[`Errors (Objects) InvalidObjectValues4.re 1`] = `
"We've found a bug for you!
  operations/errors/InvalidObjectValues4.re 10:32-34
  
   8 ┆ nonRec: {
   9 ┆     nonNullableField: \\"!\\"
  10 ┆     nullableArray: [2]
  11 ┆     field: \\"\\"
  12 ┆     enum: FIRST
  
  Invalid argument. Expected \\"[String]\\" but received \\"[Int!]!\\"."
`;

exports[`Errors (Objects) InvalidObjectValues5.re 1`] = `
"We've found a bug for you!
  operations/errors/InvalidObjectValues5.re 20:23-24
  
  18 ┆             otherField: \\"\\"
  19 ┆         }
  20 ┆         enum: []
  21 ┆     }
  22 ┆ )
  
  Invalid argument. Expected \\"Enum\\" but received \\"EmptyList!\\"."
`;

exports[`Errors (Objects) deprecatedFields.re 1`] = `
"File \\"operations/errors/deprecatedFields.re\\", line 7, characters 6-21:
7 |       deprecatedField
          ^^^^^^^^^^^^^^^
Alert deprecated: Field \\"deprecatedField\\" has been deprecated. Reason: Use something else instead"
`;

exports[`Errors (Objects) invalidArgVariableType1.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidArgVariableType1.re 9:25-28
  
   7 ┆ query invalidArgValues {
   8 ┆   invalidArgValues(
   9 ┆       stringRequired: $arg
  10 ┆   )
  11 ┆ }
  
  Invalid argument. The variable \\"$arg\\" on argument \\"stringRequired\\" is missing."
`;

exports[`Errors (Objects) invalidArgVariableType2.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidArgVariableType2.re 8:25-28
  
   6 ┆ query invalidArgValues($arg: String) {
   7 ┆   invalidArgValues(
   8 ┆       stringRequired: $arg
   9 ┆   )
  10 ┆ }
  
  Invalid argument. Trying to apply the nullable variable \\"$arg\\" to the required argument \\"stringRequired\\"."
`;

exports[`Errors (Objects) invalidArgVariableType3.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidArgVariableType3.re 9:17-21
  
   7 ┆   invalidArgValues(
   8 ┆       stringRequired: $arg
   9 ┆       string: $arg2
  10 ┆   )
  11 ┆ }
  
  Invalid argument. Expected \\"String\\" but received \\"Int\\"."
`;

exports[`Errors (Objects) invalidArgVariableType4.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidArgVariableType4.re 10:14-18
  
   8 ┆ invalidArgValues(
   9 ┆     custom: $arg
  10 ┆     obj: $arg2
  11 ┆     stringRequired: \\"\\"
  12 ┆ )
  
  Invalid argument. Expected \\"InputObject\\" but received \\"Int\\"."
`;

exports[`Errors (Objects) invalidArgVariableType5.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidArgVariableType5.re 9:25-28
  
   7 ┆   invalidArgValues(
   8 ┆       id: $arg
   9 ┆       stringRequired: $arg
  10 ┆   )
  11 ┆ }
  
  Invalid argument. Trying to apply the nullable variable \\"$arg\\" to the required argument \\"stringRequired\\"."
`;

exports[`Errors (Objects) invalidArgVariableType6.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidArgVariableType6.re 8:15-18
  
   6 ┆ query invalidArgValues($arg: String) {
   7 ┆   invalidArgValues(
   8 ┆       list: $arg
   9 ┆       stringRequired: \\"\\"
  10 ┆   )
  
  Invalid argument. Expected \\"[String]\\" but received \\"String\\"."
`;

exports[`Errors (Objects) invalidDefaultValue1.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidDefaultValue1.re 21:14-26
  
  19 ┆ query invalidDefaultValues {
  20 ┆   invalidDefaultValues(
  21 ┆       int: \\"Some string\\"
  22 ┆   )
  23 ┆ }
  
  Invalid argument. Expected \\"Int\\" but received \\"String!\\"."
`;

exports[`Errors (Objects) invalidDefaultValue2.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidDefaultValue2.re 8:14-26
  
   6 ┆ query invalidDefaultValues {
   7 ┆   invalidDefaultValues(
   8 ┆       int: {test: \\"xxx\\"}
   9 ┆   )
  10 ┆ }
  
  Invalid argument. Expected \\"Int\\" but received \\"InputObject!\\"."
`;

exports[`Errors (Objects) invalidDefaultValue3.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidDefaultValue3.re 21:13
  
  19 ┆ query invalidDefaultValues {
  20 ┆   invalidDefaultValues(
  21 ┆       id: 5
  22 ┆   )
  23 ┆ }
  
  Invalid argument. Expected \\"ID\\" but received \\"Int!\\"."
`;

exports[`Errors (Objects) invalidDefaultValue4.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidDefaultValue4.re 8:17-26
  
   6 ┆ query invalidDefaultValues {
   7 ┆   invalidDefaultValues(
   8 ┆       string: [\\"1\\", \\"2\\"]
   9 ┆   )
  10 ┆ }
  
  Invalid argument. Expected \\"String\\" but received \\"List\\"."
`;

exports[`Errors (Objects) invalidObjectValues1.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidObjectValues1.re 19:37
  
  17 ┆     otherField: \\"\\"
  18 ┆     inner: {
  19 ┆         otherField: 5
  20 ┆     }
  21 ┆ }
  
  Invalid argument. Expected \\"String\\" but received \\"Int!\\"."
`;

exports[`Errors (Objects) invalidObjectValues6.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidObjectValues6.re 20:27-37
  
  18 ┆ query {
  19 ┆     invalidObjectValuesLst(
  20 ┆         embeddedList: {field: \\"\\"}
  21 ┆     )
  22 ┆ }
  
  Invalid argument. Expected \\"[InputObject]!\\" but received \\"InputObject!\\"."
`;

exports[`Errors (Objects) invalidObjectValues7.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidObjectValues7.re 20:36
  
  18 ┆ query {
  19 ┆     invalidObjectValuesLst(
  20 ┆         embeddedList: [{field: 5}]
  21 ┆     )
  22 ┆ }
  
  Invalid argument. Expected \\"String!\\" but received \\"Int!\\"."
`;

exports[`Errors (Objects) missingField1.re 1`] = `
"File \\"operations/errors/missingField1.re\\", line 6, characters 6-27:
6 |       thisFieldDoesNotExist
          ^^^^^^^^^^^^^^^^^^^^^
Error: Unknown field 'thisFieldDoesNotExist' on type CustomScalarObject

  We've found a bug for you!
  operations/errors/missingField1.re"
`;

exports[`Errors (Objects) missingField2.re 1`] = `
"File \\"operations/errors/missingField2.re\\", line 13, characters 8-28:
13 |     l1: thisTypeDoesNotExist {
             ^^^^^^^^^^^^^^^^^^^^
Error: Unknown field 'thisTypeDoesNotExist' on type Query

  We've found a bug for you!
  operations/errors/missingField2.re"
`;

exports[`Errors (Objects) missingField3.re 1`] = `
"File \\"operations/errors/missingField3.re\\", line 15, characters 6-18:
15 |       doesNotExist
           ^^^^^^^^^^^^
Error: Unknown field 'doesNotExist' on type Lists

  We've found a bug for you!
  operations/errors/missingField3.re"
`;

exports[`Errors (Objects) missingFragment.re 1`] = `
"We've found a bug for you!
  operations/errors/missingFragment.re 3:28-42
  
  1 │ module Fragment = [%graphql
  2 │   {|
  3 │   fragment ListFragment on UnknownFragment {
  4 │     nullableOfNullable
  5 │     nullableOfNonNullable
  
  Unknown type \\"UnknownFragment\\""
`;

exports[`Errors (Records) InvalidObjectValues2.re 1`] = `
"We've found a bug for you!
  operations/errors/InvalidObjectValues2.re 8:13-18
  
   6 ┆ query {
   7 ┆     invalidObjectValues(
   8 ┆         nonRec: {
   9 ┆             nullableArray: [\\"\\"]
  10 ┆             field: \\"\\"
  
  Invalid argument. The field \\"nonNullableField\\" on argument \\"nonRec\\" is missing."
`;

exports[`Errors (Records) InvalidObjectValues3.re 1`] = `
"We've found a bug for you!
  operations/errors/InvalidObjectValues3.re 9:35
  
   7 ┆ invalidObjectValues(
   8 ┆     nonRec: {
   9 ┆         nonNullableField: 5
  10 ┆         nullableArray: [\\"\\"]
  11 ┆         field: \\"\\"
  
  Invalid argument. Expected \\"String!\\" but received \\"Int!\\"."
`;

exports[`Errors (Records) InvalidObjectValues4.re 1`] = `
"We've found a bug for you!
  operations/errors/InvalidObjectValues4.re 10:32-34
  
   8 ┆ nonRec: {
   9 ┆     nonNullableField: \\"!\\"
  10 ┆     nullableArray: [2]
  11 ┆     field: \\"\\"
  12 ┆     enum: FIRST
  
  Invalid argument. Expected \\"[String]\\" but received \\"[Int!]!\\"."
`;

exports[`Errors (Records) InvalidObjectValues5.re 1`] = `
"We've found a bug for you!
  operations/errors/InvalidObjectValues5.re 20:23-24
  
  18 ┆             otherField: \\"\\"
  19 ┆         }
  20 ┆         enum: []
  21 ┆     }
  22 ┆ )
  
  Invalid argument. Expected \\"Enum\\" but received \\"EmptyList!\\"."
`;

exports[`Errors (Records) deprecatedFields.re 1`] = `
"File \\"operations/errors/deprecatedFields.re\\", line 7, characters 6-21:
7 |       deprecatedField
          ^^^^^^^^^^^^^^^
Alert deprecated: Field \\"deprecatedField\\" has been deprecated. Reason: Use something else instead"
`;

exports[`Errors (Records) invalidArgVariableType1.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidArgVariableType1.re 9:25-28
  
   7 ┆ query invalidArgValues {
   8 ┆   invalidArgValues(
   9 ┆       stringRequired: $arg
  10 ┆   )
  11 ┆ }
  
  Invalid argument. The variable \\"$arg\\" on argument \\"stringRequired\\" is missing."
`;

exports[`Errors (Records) invalidArgVariableType2.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidArgVariableType2.re 8:25-28
  
   6 ┆ query invalidArgValues($arg: String) {
   7 ┆   invalidArgValues(
   8 ┆       stringRequired: $arg
   9 ┆   )
  10 ┆ }
  
  Invalid argument. Trying to apply the nullable variable \\"$arg\\" to the required argument \\"stringRequired\\"."
`;

exports[`Errors (Records) invalidArgVariableType3.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidArgVariableType3.re 9:17-21
  
   7 ┆   invalidArgValues(
   8 ┆       stringRequired: $arg
   9 ┆       string: $arg2
  10 ┆   )
  11 ┆ }
  
  Invalid argument. Expected \\"String\\" but received \\"Int\\"."
`;

exports[`Errors (Records) invalidArgVariableType4.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidArgVariableType4.re 10:14-18
  
   8 ┆ invalidArgValues(
   9 ┆     custom: $arg
  10 ┆     obj: $arg2
  11 ┆     stringRequired: \\"\\"
  12 ┆ )
  
  Invalid argument. Expected \\"InputObject\\" but received \\"Int\\"."
`;

exports[`Errors (Records) invalidArgVariableType5.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidArgVariableType5.re 9:25-28
  
   7 ┆   invalidArgValues(
   8 ┆       id: $arg
   9 ┆       stringRequired: $arg
  10 ┆   )
  11 ┆ }
  
  Invalid argument. Trying to apply the nullable variable \\"$arg\\" to the required argument \\"stringRequired\\"."
`;

exports[`Errors (Records) invalidArgVariableType6.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidArgVariableType6.re 8:15-18
  
   6 ┆ query invalidArgValues($arg: String) {
   7 ┆   invalidArgValues(
   8 ┆       list: $arg
   9 ┆       stringRequired: \\"\\"
  10 ┆   )
  
  Invalid argument. Expected \\"[String]\\" but received \\"String\\"."
`;

exports[`Errors (Records) invalidDefaultValue1.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidDefaultValue1.re 21:14-26
  
  19 ┆ query invalidDefaultValues {
  20 ┆   invalidDefaultValues(
  21 ┆       int: \\"Some string\\"
  22 ┆   )
  23 ┆ }
  
  Invalid argument. Expected \\"Int\\" but received \\"String!\\"."
`;

exports[`Errors (Records) invalidDefaultValue2.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidDefaultValue2.re 8:14-26
  
   6 ┆ query invalidDefaultValues {
   7 ┆   invalidDefaultValues(
   8 ┆       int: {test: \\"xxx\\"}
   9 ┆   )
  10 ┆ }
  
  Invalid argument. Expected \\"Int\\" but received \\"InputObject!\\"."
`;

exports[`Errors (Records) invalidDefaultValue3.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidDefaultValue3.re 21:13
  
  19 ┆ query invalidDefaultValues {
  20 ┆   invalidDefaultValues(
  21 ┆       id: 5
  22 ┆   )
  23 ┆ }
  
  Invalid argument. Expected \\"ID\\" but received \\"Int!\\"."
`;

exports[`Errors (Records) invalidDefaultValue4.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidDefaultValue4.re 8:17-26
  
   6 ┆ query invalidDefaultValues {
   7 ┆   invalidDefaultValues(
   8 ┆       string: [\\"1\\", \\"2\\"]
   9 ┆   )
  10 ┆ }
  
  Invalid argument. Expected \\"String\\" but received \\"List\\"."
`;

exports[`Errors (Records) invalidObjectValues1.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidObjectValues1.re 19:37
  
  17 ┆     otherField: \\"\\"
  18 ┆     inner: {
  19 ┆         otherField: 5
  20 ┆     }
  21 ┆ }
  
  Invalid argument. Expected \\"String\\" but received \\"Int!\\"."
`;

exports[`Errors (Records) invalidObjectValues6.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidObjectValues6.re 20:27-37
  
  18 ┆ query {
  19 ┆     invalidObjectValuesLst(
  20 ┆         embeddedList: {field: \\"\\"}
  21 ┆     )
  22 ┆ }
  
  Invalid argument. Expected \\"[InputObject]!\\" but received \\"InputObject!\\"."
`;

exports[`Errors (Records) invalidObjectValues7.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidObjectValues7.re 20:36
  
  18 ┆ query {
  19 ┆     invalidObjectValuesLst(
  20 ┆         embeddedList: [{field: 5}]
  21 ┆     )
  22 ┆ }
  
  Invalid argument. Expected \\"String!\\" but received \\"Int!\\"."
`;

exports[`Errors (Records) missingField1.re 1`] = `
"File \\"operations/errors/missingField1.re\\", line 6, characters 6-27:
6 |       thisFieldDoesNotExist
          ^^^^^^^^^^^^^^^^^^^^^
Error: Unknown field 'thisFieldDoesNotExist' on type CustomScalarObject

  We've found a bug for you!
  operations/errors/missingField1.re"
`;

exports[`Errors (Records) missingField2.re 1`] = `
"File \\"operations/errors/missingField2.re\\", line 13, characters 8-28:
13 |     l1: thisTypeDoesNotExist {
             ^^^^^^^^^^^^^^^^^^^^
Error: Unknown field 'thisTypeDoesNotExist' on type Query

  We've found a bug for you!
  operations/errors/missingField2.re"
`;

exports[`Errors (Records) missingField3.re 1`] = `
"File \\"operations/errors/missingField3.re\\", line 15, characters 6-18:
15 |       doesNotExist
           ^^^^^^^^^^^^
Error: Unknown field 'doesNotExist' on type Lists

  We've found a bug for you!
  operations/errors/missingField3.re"
`;

exports[`Errors (Records) missingFragment.re 1`] = `
"We've found a bug for you!
  operations/errors/missingFragment.re 3:28-42
  
  1 │ module Fragment = [%graphql
  2 │   {|
  3 │   fragment ListFragment on UnknownFragment {
  4 │     nullableOfNullable
  5 │     nullableOfNonNullable
  
  Unknown type \\"UnknownFragment\\""
`;

exports[`Legacy argNamedQuery.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"argNamedQuery\\": int};
    type t_variables = {. \\"query\\": int};
  };
  let query = \\"query ($query: Int!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\";
  type t = {. \\"argNamedQuery\\": int};
  type t_variables = {. \\"query\\": int};
  let parse: Raw.t => t =
    value => {
      let argNamedQuery = {
        let value = value##argNamedQuery;
        value;
      };
      {\\"argNamedQuery\\": argNamedQuery};
    };
  let serialize: t => Raw.t =
    value => {
      let argNamedQuery = {
        let value = value##argNamedQuery;
        value;
      };
      {\\"argNamedQuery\\": argNamedQuery};
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"query\\": (a => a)(inp##query)};
  let make = (~query, ()) => {
    \\"query\\": query,
    \\"variables\\": serializeVariables({\\"query\\": query}: t_variables),
    \\"parse\\": parse,
  }
  and makeVariables = (~query, ()) =>
    serializeVariables({\\"query\\": query}: t_variables);
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy comment.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"nonrecursiveInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      .
      \\"nonNullableField\\": string,
      \\"nullableArray\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"field\\": Js.Nullable.t(string),
      \\"enum\\": Js.Nullable.t(string),
      \\"embeddedInput\\":
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
      \\"custom\\": Js.Nullable.t(Js.Json.t),
    }
    and t_variables_EmbeddedInput = {. \\"field\\": Js.Nullable.t(string)};
  };
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"nonrecursiveInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    .
    \\"nonNullableField\\": string,
    \\"nullableArray\\": option(array(option(string))),
    \\"field\\": option(string),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
    \\"embeddedInput\\": option(array(option(t_variables_EmbeddedInput))),
    \\"custom\\": option(Js.Json.t),
  }
  and t_variables_EmbeddedInput = {. \\"field\\": option(string)};
  let parse: Raw.t => t =
    value => {
      let nonrecursiveInput = {
        let value = value##nonrecursiveInput;
        value;
      };
      {\\"nonrecursiveInput\\": nonrecursiveInput};
    };
  let serialize: t => Raw.t =
    value => {
      let nonrecursiveInput = {
        let value = value##nonrecursiveInput;
        value;
      };
      {\\"nonrecursiveInput\\": nonrecursiveInput};
    };
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"arg\\": (a => serializeInputObjectNonrecursiveInput(a))(inp##arg),
    }
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {
      \\"nonNullableField\\": (a => a)(inp##nonNullableField),
      \\"nullableArray\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableArray,
        ),
      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
      \\"enum\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          inp##enum,
        ),
      \\"embeddedInput\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##embeddedInput,
        ),
      \\"custom\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##custom,
        ),
    }
  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {
      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
    };
  let make = (~arg, ()) => {
    \\"query\\": query,
    \\"variables\\": serializeVariables({\\"arg\\": arg}: t_variables),
    \\"parse\\": parse,
  }
  and makeVariables = (~arg, ()) =>
    serializeVariables({\\"arg\\": arg}: t_variables)
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        ~custom=?,
        (),
      )
      : t_variables_NonrecursiveInput => {
    \\"nonNullableField\\": nonNullableField,
    \\"nullableArray\\": nullableArray,
    \\"field\\": field,
    \\"enum\\": enum,
    \\"embeddedInput\\": embeddedInput,
    \\"custom\\": custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {
    \\"field\\": field,
  };
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec _graphql_NonrecursiveInput_49;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_49: _graphql_NonrecursiveInput_49 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy customDecoder.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module StringOfInt = {
  let parse = string_of_int;
  let serialize = int_of_string;
  type t = string;
};
module IntOfString = {
  let parse = int_of_string;
  let serialize = string_of_int;
  type t = int;
};
module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      .
      \\"string\\": string,
      \\"int\\": int,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {
    .
    \\"string\\": IntOfString.t,
    \\"int\\": StringOfInt.t,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let int = {
          let value = value##int;
          StringOfInt.parse(value);
        }
        and string = {
          let value = value##string;
          IntOfString.parse(value);
        };
        {\\"string\\": string, \\"int\\": int};
      };
      {\\"variousScalars\\": variousScalars};
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let int = {
          let value = value##int;
          StringOfInt.serialize(value);
        }
        and string = {
          let value = value##string;
          IntOfString.serialize(value);
        };
        {\\"string\\": string, \\"int\\": int};
      };
      {\\"variousScalars\\": variousScalars};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy customScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_customScalarField = {
      .
      \\"nullable\\": Js.Nullable.t(Js.Json.t),
      \\"nonNullable\\": Js.Json.t,
    };
    type t = {. \\"customScalarField\\": t_customScalarField};
    type t_variables = {
      .
      \\"opt\\": Js.Nullable.t(Js.Json.t),
      \\"req\\": Js.Json.t,
    };
  };
  let query = \\"query ($opt: CustomScalar, $req: CustomScalar!)  {\\\\ncustomScalarField(argOptional: $opt, argRequired: $req)  {\\\\nnullable  \\\\nnonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_customScalarField = {
    .
    \\"nullable\\": option(Js.Json.t),
    \\"nonNullable\\": Js.Json.t,
  };
  type t = {. \\"customScalarField\\": t_customScalarField};
  type t_variables = {
    .
    \\"opt\\": option(Js.Json.t),
    \\"req\\": Js.Json.t,
  };
  let parse: Raw.t => t =
    value => {
      let customScalarField = {
        let value = value##customScalarField;
        let nonNullable = {
          let value = value##nonNullable;
          value;
        }
        and nullable = {
          let value = value##nullable;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {\\"nullable\\": nullable, \\"nonNullable\\": nonNullable};
      };
      {\\"customScalarField\\": customScalarField};
    };
  let serialize: t => Raw.t =
    value => {
      let customScalarField = {
        let value = value##customScalarField;
        let nonNullable = {
          let value = value##nonNullable;
          value;
        }
        and nullable = {
          let value = value##nullable;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {\\"nullable\\": nullable, \\"nonNullable\\": nonNullable};
      };
      {\\"customScalarField\\": customScalarField};
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"opt\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##opt,
        ),
      \\"req\\": (a => a)(inp##req),
    };
  let make = (~opt=?, ~req, ()) => {
    \\"query\\": query,
    \\"variables\\": serializeVariables({\\"opt\\": opt, \\"req\\": req}: t_variables),
    \\"parse\\": parse,
  }
  and makeVariables = (~opt=?, ~req, ()) =>
    serializeVariables({\\"opt\\": opt, \\"req\\": req}: t_variables);
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy customTypes.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Color = {
  type t =
    | Red
    | Green
    | Blue;
  let parse = json =>
    switch (json |> Js.Json.decodeString) {
    | Some(\\"green\\") => Green
    | Some(\\"blue\\") => Blue
    | Some(\\"red\\")
    | Some(_)
    | None => Red
    };
  let serialize = color =>
    (
      switch (color) {
      | Red => \\"red\\"
      | Green => \\"green\\"
      | Blue => \\"blue\\"
      }
    )
    |> Js.Json.string;
};
module DateTime = {
  type t = Js.Date.t;
  let parse = json =>
    switch (json |> Js.Json.decodeString) {
    | Some(str) => str |> Js.Date.fromString
    | None => Js.Date.make()
    };
  let serialize = date => date |> Js.Date.toISOString |> Js.Json.string;
};
module MyQuery = {
  module Raw = {
    type t_customFields = {
      .
      \\"currentTime\\": Js.Json.t,
      \\"favoriteColor\\": Js.Json.t,
      \\"futureTime\\": Js.Nullable.t(Js.Json.t),
      \\"nullableColor\\": Js.Nullable.t(Js.Json.t),
    };
    type t = {. \\"customFields\\": t_customFields};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ncustomFields  {\\\\ncurrentTime  \\\\nfavoriteColor  \\\\nfutureTime  \\\\nnullableColor  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_customFields = {
    .
    \\"currentTime\\": DateTime.t,
    \\"favoriteColor\\": Color.t,
    \\"futureTime\\": option(DateTime.t),
    \\"nullableColor\\": option(Color.t),
  };
  type t = {. \\"customFields\\": t_customFields};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let customFields = {
        let value = value##customFields;
        let nullableColor = {
          let value = value##nullableColor;
          switch (Js.toOption(value)) {
          | Some(value) => Some(Color.parse(value))
          | None => None
          };
        }
        and futureTime = {
          let value = value##futureTime;
          switch (Js.toOption(value)) {
          | Some(value) => Some(DateTime.parse(value))
          | None => None
          };
        }
        and favoriteColor = {
          let value = value##favoriteColor;
          Color.parse(value);
        }
        and currentTime = {
          let value = value##currentTime;
          DateTime.parse(value);
        };
        {
          \\"currentTime\\": currentTime,
          \\"favoriteColor\\": favoriteColor,
          \\"futureTime\\": futureTime,
          \\"nullableColor\\": nullableColor,
        };
      };
      {\\"customFields\\": customFields};
    };
  let serialize: t => Raw.t =
    value => {
      let customFields = {
        let value = value##customFields;
        let nullableColor = {
          let value = value##nullableColor;
          switch (value) {
          | Some(value) => Js.Nullable.return(Color.serialize(value))
          | None => Js.Nullable.null
          };
        }
        and futureTime = {
          let value = value##futureTime;
          switch (value) {
          | Some(value) => Js.Nullable.return(DateTime.serialize(value))
          | None => Js.Nullable.null
          };
        }
        and favoriteColor = {
          let value = value##favoriteColor;
          Color.serialize(value);
        }
        and currentTime = {
          let value = value##currentTime;
          DateTime.serialize(value);
        };
        {
          \\"currentTime\\": currentTime,
          \\"favoriteColor\\": favoriteColor,
          \\"futureTime\\": futureTime,
          \\"nullableColor\\": nullableColor,
        };
      };
      {\\"customFields\\": customFields};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy defaultObjectValueOnScalar.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"defaultObjectValueOnScalar\\": string};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndefaultObjectValueOnScalar(filter: {some: {json: \\\\\\"value\\\\\\"}}, arg: {field: \\\\\\"otherValue\\\\\\"})  \\\\n}\\\\n\\";
  type t = {. \\"defaultObjectValueOnScalar\\": string};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let defaultObjectValueOnScalar = {
        let value = value##defaultObjectValueOnScalar;
        value;
      };
      {\\"defaultObjectValueOnScalar\\": defaultObjectValueOnScalar};
    };
  let serialize: t => Raw.t =
    value => {
      let defaultObjectValueOnScalar = {
        let value = value##defaultObjectValueOnScalar;
        value;
      };
      {\\"defaultObjectValueOnScalar\\": defaultObjectValueOnScalar};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy enumInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"enumInput\\": string};
    type t_variables = {. \\"arg\\": string};
  };
  let query = \\"query ($arg: SampleField!)  {\\\\nenumInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"enumInput\\": string};
  type t_variables = {. \\"arg\\": [ | \`FIRST | \`SECOND | \`THIRD]};
  let parse: Raw.t => t =
    value => {
      let enumInput = {
        let value = value##enumInput;
        value;
      };
      {\\"enumInput\\": enumInput};
    };
  let serialize: t => Raw.t =
    value => {
      let enumInput = {
        let value = value##enumInput;
        value;
      };
      {\\"enumInput\\": enumInput};
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"arg\\":
        (
          a =>
            switch (a) {
            | \`FIRST => \\"FIRST\\"
            | \`SECOND => \\"SECOND\\"
            | \`THIRD => \\"THIRD\\"
            }
        )(
          inp##arg,
        ),
    };
  let make = (~arg, ()) => {
    \\"query\\": query,
    \\"variables\\": serializeVariables({\\"arg\\": arg}: t_variables),
    \\"parse\\": parse,
  }
  and makeVariables = (~arg, ()) =>
    serializeVariables({\\"arg\\": arg}: t_variables);
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec _graphql_SampleField_47;
    /**\`\`\`
SampleField {
  FIRST
  SECOND
  THIRD
}
\`\`\`*/
    let _graphql_SampleField_47: _graphql_SampleField_47 = Obj.magic(0);
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy explicit_object_record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module RecordsQuery = {
  module Raw = {
    type t_lists = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
    type t = {lists: t_lists};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_lists = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  type t = {lists: t_lists};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        lists: {
          let value = (value: Raw.t).lists;
          (
            {
              nullableOfNullable: {
                let value = (value: Raw.t_lists).nullableOfNullable;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              },
              nullableOfNonNullable: {
                let value = (value: Raw.t_lists).nullableOfNonNullable;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value |> Js.Array.map(value => value))
                | None => None
                };
              },
              nonNullableOfNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNullable;
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   );
              },
              nonNullableOfNonNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNonNullable;
                value |> Js.Array.map(value => value);
              },
            }: t_lists
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let lists = {
          let value = (value: t).lists;
          (
            {
              let nonNullableOfNonNullable = {
                let value = (value: t_lists).nonNullableOfNonNullable;
                value |> Js.Array.map(value => value);
              }
              and nonNullableOfNullable = {
                let value = (value: t_lists).nonNullableOfNullable;
                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   );
              }
              and nullableOfNonNullable = {
                let value = (value: t_lists).nullableOfNonNullable;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(value |> Js.Array.map(value => value))
                | None => Js.Nullable.null
                };
              }
              and nullableOfNullable = {
                let value = (value: t_lists).nullableOfNullable;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map(value =>
                         switch (value) {
                         | Some(value) => Js.Nullable.return(value)
                         | None => Js.Nullable.null
                         }
                       ),
                  )
                | None => Js.Nullable.null
                };
              };
              {
                nullableOfNullable,
                nullableOfNonNullable,
                nonNullableOfNullable,
                nonNullableOfNonNullable,
              };
            }: Raw.t_lists
          );
        };
        {lists: lists};
      }: Raw.t
    );
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module RecordsQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ObjectsQuery = {
  module Raw = {
    type t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
    type t = {. \\"lists\\": t_lists};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  type t = {. \\"lists\\": t_lists};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;
          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;
          value
          |> Js.Array.map(value =>
               switch (Js.toOption(value)) {
               | Some(value) => Some(value)
               | None => None
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value |> Js.Array.map(value => value))
          | None => None
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 ),
            )
          | None => None
          };
        };
        {
          \\"nullableOfNullable\\": nullableOfNullable,
          \\"nullableOfNonNullable\\": nullableOfNonNullable,
          \\"nonNullableOfNullable\\": nonNullableOfNullable,
          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {\\"lists\\": lists};
    };
  let serialize: t => Raw.t =
    value => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;
          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;
          value
          |> Js.Array.map(value =>
               switch (value) {
               | Some(value) => Js.Nullable.return(value)
               | None => Js.Nullable.null
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(value |> Js.Array.map(value => value))
          | None => Js.Nullable.null
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 ),
            )
          | None => Js.Nullable.null
          };
        };
        {
          \\"nullableOfNullable\\": nullableOfNullable,
          \\"nullableOfNonNullable\\": nullableOfNonNullable,
          \\"nonNullableOfNullable\\": nonNullableOfNullable,
          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {\\"lists\\": lists};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ObjectsQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy extensions.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module type GraphQLQuery = {
  module Raw: {
    type t;
    type t_variables;
  };
  type t;
  type t_variables;

  let query: string;
  let parse: Raw.t => t;
  let serialize: t => Raw.t;
};

module ExtendQuery = (M: GraphQLQuery) => {
  let use = () => ();
};
module Bla' = {
  module Raw = {
    type t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
    type t = {. \\"lists\\": t_lists};
    type t_variables = Js.Json.t;
  };
  let query = \\"query Bla  {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  type t = {. \\"lists\\": t_lists};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;
          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;
          value
          |> Js.Array.map(value =>
               switch (Js.toOption(value)) {
               | Some(value) => Some(value)
               | None => None
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value |> Js.Array.map(value => value))
          | None => None
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 ),
            )
          | None => None
          };
        };
        {
          \\"nullableOfNullable\\": nullableOfNullable,
          \\"nullableOfNonNullable\\": nullableOfNonNullable,
          \\"nonNullableOfNullable\\": nonNullableOfNullable,
          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {\\"lists\\": lists};
    };
  let serialize: t => Raw.t =
    value => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;
          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;
          value
          |> Js.Array.map(value =>
               switch (value) {
               | Some(value) => Js.Nullable.return(value)
               | None => Js.Nullable.null
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(value |> Js.Array.map(value => value))
          | None => Js.Nullable.null
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 ),
            )
          | None => Js.Nullable.null
          };
        };
        {
          \\"nullableOfNullable\\": nullableOfNullable,
          \\"nullableOfNonNullable\\": nullableOfNonNullable,
          \\"nonNullableOfNullable\\": nonNullableOfNullable,
          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {\\"lists\\": lists};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module Bla = {
  include Bla';
  include ExtendQuery(Bla');
};
"
`;

exports[`Legacy fragmentDefinition.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Fragments = {
  module ListFragment = {
    let query = \\"fragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        .
        \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
        \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      };
      type nonrec t_Lists = t;
    };
    type t = {
      .
      \\"nullableOfNullable\\": option(array(option(string))),
      \\"nullableOfNonNullable\\": option(array(string)),
    };
    type nonrec t_Lists = t;
    let parse = (value: Raw.t) => {
      let nullableOfNonNullable = {
        let value = value##nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      }
      and nullableOfNullable = {
        let value = value##nullableOfNullable;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      };
      {
        \\"nullableOfNullable\\": nullableOfNullable,
        \\"nullableOfNonNullable\\": nullableOfNonNullable,
      };
    };
    let serialize: t => Raw.t =
      value => {
        let nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(value |> Js.Array.map(value => value))
          | None => Js.Nullable.null
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 ),
            )
          | None => Js.Nullable.null
          };
        };
        {
          \\"nullableOfNullable\\": nullableOfNullable,
          \\"nullableOfNonNullable\\": nullableOfNonNullable,
        };
      };
    let name = \\"ListFragment\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql;
      /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}
\`\`\`*/
      let graphql: graphql = Obj.magic(0);
      type nonrec graphql_module;
      /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module Fragments {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  module Another = {
    let query = \\"fragment Another on Lists   {\\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
    module Raw = {
      type t = {. \\"nullableOfNonNullable\\": Js.Nullable.t(array(string))};
      type nonrec t_Lists = t;
    };
    type t = {. \\"nullableOfNonNullable\\": option(array(string))};
    type nonrec t_Lists = t;
    let parse = (value: Raw.t) => {
      let nullableOfNonNullable = {
        let value = value##nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      };
      {\\"nullableOfNonNullable\\": nullableOfNonNullable};
    };
    let serialize: t => Raw.t =
      value => {
        let nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(value |> Js.Array.map(value => value))
          | None => Js.Nullable.null
          };
        };
        {\\"nullableOfNonNullable\\": nullableOfNonNullable};
      };
    let name = \\"Another\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql;
      /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}
\`\`\`*/
      let graphql: graphql = Obj.magic(0);
      type nonrec graphql_module;
      /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module Fragments {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
};
module MyQuery = {
  module Raw = {
    type t_l2;
    type t_l3;
    type t_l4;
    type t = {
      .
      \\"l1\\": Fragments.ListFragment.Raw.t,
      \\"l2\\": t_l2,
      \\"l3\\": t_l3,
      \\"l4\\": t_l4,
    };
    type t_variables = Js.Json.t;
  };
  let query =
    (
      (
        (
          (
            (
              (
                (
                  (
                    (
                      (
                        (
                          (
                            \\"query   {\\\\nl1: lists  {\\\\n...\\"
                            ++ Fragments.ListFragment.name
                          )
                          ++ \\"   \\\\n}\\\\n\\\\nl2: lists  {\\\\n...\\"
                        )
                        ++ Fragments.ListFragment.name
                      )
                      ++ \\"   \\\\n...\\"
                    )
                    ++ Fragments.ListFragment.name
                  )
                  ++ \\"   \\\\n}\\\\n\\\\nl3: lists  {\\\\nnullableOfNullable  \\\\n...\\"
                )
                ++ Fragments.ListFragment.name
              )
              ++ \\"   \\\\n...\\"
            )
            ++ Fragments.ListFragment.name
          )
          ++ \\"   \\\\n}\\\\n\\\\nl4: lists  {\\\\nnullableOfNullable  \\\\n...\\"
        )
        ++ Fragments.ListFragment.name
      )
      ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
    )
    ++ Fragments.ListFragment.query;
  type t_l2 = {
    .
    \\"frag1\\": Fragments.ListFragment.t_Lists,
    \\"frag2\\": Fragments.ListFragment.t_Lists,
  };
  type t_l3 = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"frag1\\": Fragments.ListFragment.t_Lists,
    \\"frag2\\": Fragments.ListFragment.t_Lists,
  };
  type t_l4 = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"listFragment\\": Fragments.ListFragment.t_Lists,
  };
  type t = {
    .
    \\"l1\\": Fragments.ListFragment.t,
    \\"l2\\": t_l2,
    \\"l3\\": t_l3,
    \\"l4\\": t_l4,
  };
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let l4 = {
        let value = value##l4;
        let listFragment = {
          let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
          Fragments.ListFragment.parse(value);
        }
        and nullableOfNullable = {
          let value =
            Obj.magic(
              Js.Dict.unsafeGet(Obj.magic(value), \\"nullableOfNullable\\"),
            );
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 ),
            )
          | None => None
          };
        };
        {
          \\"nullableOfNullable\\": nullableOfNullable,
          \\"listFragment\\": listFragment,
        };
      }
      and l3 = {
        let value = value##l3;
        let frag2 = {
          let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
          Fragments.ListFragment.parse(value);
        }
        and frag1 = {
          let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
          Fragments.ListFragment.parse(value);
        }
        and nullableOfNullable = {
          let value =
            Obj.magic(
              Js.Dict.unsafeGet(Obj.magic(value), \\"nullableOfNullable\\"),
            );
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 ),
            )
          | None => None
          };
        };
        {
          \\"nullableOfNullable\\": nullableOfNullable,
          \\"frag1\\": frag1,
          \\"frag2\\": frag2,
        };
      }
      and l2 = {
        let value = value##l2;
        let frag2 = {
          let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
          Fragments.ListFragment.parse(value);
        }
        and frag1 = {
          let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
          Fragments.ListFragment.parse(value);
        };
        {\\"frag1\\": frag1, \\"frag2\\": frag2};
      }
      and l1 = {
        let value = value##l1;
        Fragments.ListFragment.parse(value);
      };
      {\\"l1\\": l1, \\"l2\\": l2, \\"l3\\": l3, \\"l4\\": l4};
    };
  let serialize: t => Raw.t =
    value => {
      let l4 = {
        let value = value##l4;
        (
          Obj.magic(
            Js.Array.reduce(
              GraphQL_PPX.deepMerge,
              Obj.magic(
                {
                  let nullableOfNullable = {
                    let value = value##nullableOfNullable;
                    switch (value) {
                    | Some(value) =>
                      Js.Nullable.return(
                        value
                        |> Js.Array.map(value =>
                             switch (value) {
                             | Some(value) => Js.Nullable.return(value)
                             | None => Js.Nullable.null
                             }
                           ),
                      )
                    | None => Js.Nullable.null
                    };
                  };
                  {\\"nullableOfNullable\\": nullableOfNullable};
                },
              ): Js.Json.t,
              [|
                (
                  Obj.magic(
                    Fragments.ListFragment.serialize(value##listFragment),
                  ): Js.Json.t
                ),
              |],
            ),
          ): Raw.t_l4
        );
      }
      and l3 = {
        let value = value##l3;
        (
          Obj.magic(
            Js.Array.reduce(
              GraphQL_PPX.deepMerge,
              Obj.magic(
                {
                  let nullableOfNullable = {
                    let value = value##nullableOfNullable;
                    switch (value) {
                    | Some(value) =>
                      Js.Nullable.return(
                        value
                        |> Js.Array.map(value =>
                             switch (value) {
                             | Some(value) => Js.Nullable.return(value)
                             | None => Js.Nullable.null
                             }
                           ),
                      )
                    | None => Js.Nullable.null
                    };
                  };
                  {\\"nullableOfNullable\\": nullableOfNullable};
                },
              ): Js.Json.t,
              [|
                (
                  Obj.magic(Fragments.ListFragment.serialize(value##frag1)): Js.Json.t
                ),
                (
                  Obj.magic(Fragments.ListFragment.serialize(value##frag2)): Js.Json.t
                ),
              |],
            ),
          ): Raw.t_l3
        );
      }
      and l2 = {
        let value = value##l2;
        (
          Obj.magic(
            Js.Array.reduce(
              GraphQL_PPX.deepMerge,
              Obj.magic(Js.Dict.empty): Js.Json.t,
              [|
                (
                  Obj.magic(Fragments.ListFragment.serialize(value##frag1)): Js.Json.t
                ),
                (
                  Obj.magic(Fragments.ListFragment.serialize(value##frag2)): Js.Json.t
                ),
              |],
            ),
          ): Raw.t_l2
        );
      }
      and l1 = {
        let value = value##l1;
        Fragments.ListFragment.serialize(value);
      };
      {\\"l1\\": l1, \\"l2\\": l2, \\"l3\\": l3, \\"l4\\": l4};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery2 = {
  module Raw = {
    type t = {. \\"lists\\": Fragments.ListFragment.Raw.t};
    type t_variables = Js.Json.t;
  };
  let query =
    (
      (\\"query   {\\\\nlists  {\\\\n...\\" ++ Fragments.ListFragment.name)
      ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
    )
    ++ Fragments.ListFragment.query;
  type t = {. \\"lists\\": Fragments.ListFragment.t};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let lists = {
        let value = value##lists;
        Fragments.ListFragment.parse(value);
      };
      {\\"lists\\": lists};
    };
  let serialize: t => Raw.t =
    value => {
      let lists = {
        let value = value##lists;
        Fragments.ListFragment.serialize(value);
      };
      {\\"lists\\": lists};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery2 {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy interface.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
"
`;

exports[`Legacy lists.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
    type t = {. \\"lists\\": t_lists};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  type t = {. \\"lists\\": t_lists};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;
          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;
          value
          |> Js.Array.map(value =>
               switch (Js.toOption(value)) {
               | Some(value) => Some(value)
               | None => None
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value |> Js.Array.map(value => value))
          | None => None
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 ),
            )
          | None => None
          };
        };
        {
          \\"nullableOfNullable\\": nullableOfNullable,
          \\"nullableOfNonNullable\\": nullableOfNonNullable,
          \\"nonNullableOfNullable\\": nonNullableOfNullable,
          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {\\"lists\\": lists};
    };
  let serialize: t => Raw.t =
    value => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;
          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;
          value
          |> Js.Array.map(value =>
               switch (value) {
               | Some(value) => Js.Nullable.return(value)
               | None => Js.Nullable.null
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(value |> Js.Array.map(value => value))
          | None => Js.Nullable.null
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 ),
            )
          | None => Js.Nullable.null
          };
        };
        {
          \\"nullableOfNullable\\": nullableOfNullable,
          \\"nullableOfNonNullable\\": nullableOfNonNullable,
          \\"nonNullableOfNullable\\": nonNullableOfNullable,
          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {\\"lists\\": lists};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy listsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"listsInput\\": string};
    type t_variables = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
  };
  let query = \\"query ($nullableOfNullable: [String], $nullableOfNonNullable: [String!], $nonNullableOfNullable: [String]!, $nonNullableOfNonNullable: [String!]!)  {\\\\nlistsInput(arg: {nullableOfNullable: $nullableOfNullable, nullableOfNonNullable: $nullableOfNonNullable, nonNullableOfNullable: $nonNullableOfNullable, nonNullableOfNonNullable: $nonNullableOfNonNullable})  \\\\n}\\\\n\\";
  type t = {. \\"listsInput\\": string};
  type t_variables = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  let parse: Raw.t => t =
    value => {
      let listsInput = {
        let value = value##listsInput;
        value;
      };
      {\\"listsInput\\": listsInput};
    };
  let serialize: t => Raw.t =
    value => {
      let listsInput = {
        let value = value##listsInput;
        value;
      };
      {\\"listsInput\\": listsInput};
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"nullableOfNullable\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableOfNullable,
        ),
      \\"nullableOfNonNullable\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return((a => Array.map(b => (a => a)(b), a))(b))
            }
        )(
          inp##nullableOfNonNullable,
        ),
      \\"nonNullableOfNullable\\":
        (
          a =>
            Array.map(
              b =>
                (
                  a =>
                    switch (a) {
                    | None => Js.Nullable.undefined
                    | Some(b) => Js.Nullable.return((a => a)(b))
                    }
                )(
                  b,
                ),
              a,
            )
        )(
          inp##nonNullableOfNullable,
        ),
      \\"nonNullableOfNonNullable\\":
        (a => Array.map(b => (a => a)(b), a))(
          inp##nonNullableOfNonNullable,
        ),
    };
  let make =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      ) => {
    \\"query\\": query,
    \\"variables\\":
      serializeVariables(
        {
          \\"nullableOfNullable\\": nullableOfNullable,
          \\"nullableOfNonNullable\\": nullableOfNonNullable,
          \\"nonNullableOfNullable\\": nonNullableOfNullable,
          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        }: t_variables,
      ),
    \\"parse\\": parse,
  }
  and makeVariables =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      ) =>
    serializeVariables(
      {
        \\"nullableOfNullable\\": nullableOfNullable,
        \\"nullableOfNonNullable\\": nullableOfNonNullable,
        \\"nonNullableOfNullable\\": nonNullableOfNullable,
        \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
      }: t_variables,
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy listsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"listsInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_ListsInput}
    and t_variables_ListsInput = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
  };
  let query = \\"query ($arg: ListsInput!)  {\\\\nlistsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"listsInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_ListsInput}
  and t_variables_ListsInput = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  let parse: Raw.t => t =
    value => {
      let listsInput = {
        let value = value##listsInput;
        value;
      };
      {\\"listsInput\\": listsInput};
    };
  let serialize: t => Raw.t =
    value => {
      let listsInput = {
        let value = value##listsInput;
        value;
      };
      {\\"listsInput\\": listsInput};
    };
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"arg\\": (a => serializeInputObjectListsInput(a))(inp##arg)}
  and serializeInputObjectListsInput:
    t_variables_ListsInput => Raw.t_variables_ListsInput =
    inp => {
      \\"nullableOfNullable\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableOfNullable,
        ),
      \\"nullableOfNonNullable\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return((a => Array.map(b => (a => a)(b), a))(b))
            }
        )(
          inp##nullableOfNonNullable,
        ),
      \\"nonNullableOfNullable\\":
        (
          a =>
            Array.map(
              b =>
                (
                  a =>
                    switch (a) {
                    | None => Js.Nullable.undefined
                    | Some(b) => Js.Nullable.return((a => a)(b))
                    }
                )(
                  b,
                ),
              a,
            )
        )(
          inp##nonNullableOfNullable,
        ),
      \\"nonNullableOfNonNullable\\":
        (a => Array.map(b => (a => a)(b), a))(
          inp##nonNullableOfNonNullable,
        ),
    };
  let make = (~arg, ()) => {
    \\"query\\": query,
    \\"variables\\": serializeVariables({\\"arg\\": arg}: t_variables),
    \\"parse\\": parse,
  }
  and makeVariables = (~arg, ()) =>
    serializeVariables({\\"arg\\": arg}: t_variables)
  and makeInputObjectListsInput =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      )
      : t_variables_ListsInput => {
    \\"nullableOfNullable\\": nullableOfNullable,
    \\"nullableOfNonNullable\\": nullableOfNonNullable,
    \\"nonNullableOfNullable\\": nonNullableOfNullable,
    \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
  };
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec _graphql_ListsInput_47;
    /**\`\`\`
ListsInput {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}
\`\`\`*/
    let _graphql_ListsInput_47: _graphql_ListsInput_47 = Obj.magic(0);
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy mutation.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_mutationWithError_value = {. \\"stringField\\": string};
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      .
      \\"field\\": t_mutationWithError_errors_field,
      \\"message\\": string,
    };
    type t_mutationWithError = {
      .
      \\"value\\": Js.Nullable.t(t_mutationWithError_value),
      \\"errors\\": Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {. \\"mutationWithError\\": t_mutationWithError};
    type t_variables = Js.Json.t;
  };
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nvalue  {\\\\nstringField  \\\\n}\\\\n\\\\nerrors  {\\\\nfield  \\\\nmessage  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_mutationWithError_value = {. \\"stringField\\": string};
  type t_mutationWithError_errors_field = [
    | \`FutureAddedValue(string)
    | \`FIRST
    | \`SECOND
    | \`THIRD
  ];
  type t_mutationWithError_errors = {
    .
    \\"field\\": t_mutationWithError_errors_field,
    \\"message\\": string,
  };
  type t_mutationWithError = {
    .
    \\"value\\": option(t_mutationWithError_value),
    \\"errors\\": option(array(t_mutationWithError_errors)),
  };
  type t = {. \\"mutationWithError\\": t_mutationWithError};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let mutationWithError = {
        let value = value##mutationWithError;
        let errors = {
          let value = value##errors;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   let message = {
                     let value = value##message;
                     value;
                   }
                   and field = {
                     let value = value##field;
                     switch (Obj.magic(value: string)) {
                     | \\"FIRST\\" => \`FIRST
                     | \\"SECOND\\" => \`SECOND
                     | \\"THIRD\\" => \`THIRD
                     | other => \`FutureAddedValue(other)
                     };
                   };
                   {\\"field\\": field, \\"message\\": message};
                 ),
            )
          | None => None
          };
        }
        and value = {
          let value = value##value;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {
                let stringField = {
                  let value = value##stringField;
                  value;
                };
                {\\"stringField\\": stringField};
              },
            )
          | None => None
          };
        };
        {\\"value\\": value, \\"errors\\": errors};
      };
      {\\"mutationWithError\\": mutationWithError};
    };
  let serialize: t => Raw.t =
    value => {
      let mutationWithError = {
        let value = value##mutationWithError;
        let errors = {
          let value = value##errors;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   let message = {
                     let value = value##message;
                     value;
                   }
                   and field = {
                     let value = value##field;
                     switch (value) {
                     | \`FIRST => \\"FIRST\\"
                     | \`SECOND => \\"SECOND\\"
                     | \`THIRD => \\"THIRD\\"
                     | \`FutureAddedValue(other) => other
                     };
                   };
                   {\\"field\\": field, \\"message\\": message};
                 ),
            )
          | None => Js.Nullable.null
          };
        }
        and value = {
          let value = value##value;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {
                let stringField = {
                  let value = value##stringField;
                  value;
                };
                {\\"stringField\\": stringField};
              },
            )
          | None => Js.Nullable.null
          };
        };
        {\\"value\\": value, \\"errors\\": errors};
      };
      {\\"mutationWithError\\": mutationWithError};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy mutationWithArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"optionalInputArgs\\": string};
    type t_variables = {. \\"required\\": string};
  };
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t = {. \\"optionalInputArgs\\": string};
  type t_variables = {. \\"required\\": string};
  let parse: Raw.t => t =
    value => {
      let optionalInputArgs = {
        let value = value##optionalInputArgs;
        value;
      };
      {\\"optionalInputArgs\\": optionalInputArgs};
    };
  let serialize: t => Raw.t =
    value => {
      let optionalInputArgs = {
        let value = value##optionalInputArgs;
        value;
      };
      {\\"optionalInputArgs\\": optionalInputArgs};
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"required\\": (a => a)(inp##required)};
  let make = (~required, ()) => {
    \\"query\\": query,
    \\"variables\\": serializeVariables({\\"required\\": required}: t_variables),
    \\"parse\\": parse,
  }
  and makeVariables = (~required, ()) =>
    serializeVariables({\\"required\\": required}: t_variables);
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy mutationWithArgsAndNoRecords.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"optionalInputArgs\\": string};
    type t_variables = {. \\"required\\": string};
  };
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t = {. \\"optionalInputArgs\\": string};
  type t_variables = {. \\"required\\": string};
  let parse: Raw.t => t =
    value => {
      let optionalInputArgs = {
        let value = value##optionalInputArgs;
        value;
      };
      {\\"optionalInputArgs\\": optionalInputArgs};
    };
  let serialize: t => Raw.t =
    value => {
      let optionalInputArgs = {
        let value = value##optionalInputArgs;
        value;
      };
      {\\"optionalInputArgs\\": optionalInputArgs};
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"required\\": (a => a)(inp##required)};
  let make = (~required, ()) => {
    \\"query\\": query,
    \\"variables\\": serializeVariables({\\"required\\": required}: t_variables),
    \\"parse\\": parse,
  }
  and makeVariables = (~required, ()) =>
    serializeVariables({\\"required\\": required}: t_variables);
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy nested.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type record = {
  f1: string,
  f2: string,
};
module MyQuery = {
  module Raw = {
    type t_first_inner_inner = {. \\"field\\": string};
    type t_first_inner = {. \\"inner\\": Js.Nullable.t(t_first_inner_inner)};
    type t_first = {. \\"inner\\": Js.Nullable.t(t_first_inner)};
    type t_second_inner_inner = {
      .
      \\"f1\\": string,
      \\"f2\\": string,
    };
    type t_second_inner = {. \\"inner\\": Js.Nullable.t(t_second_inner_inner)};
    type t_second = {. \\"inner\\": Js.Nullable.t(t_second_inner)};
    type t_let_inner_inner = {. \\"field\\": string};
    type t_let_inner = {. \\"inner\\": Js.Nullable.t(t_let_inner_inner)};
    type t_let = {. \\"inner\\": Js.Nullable.t(t_let_inner)};
    type t = {
      .
      \\"first\\": t_first,
      \\"second\\": t_second,
      \\"let_\\": t_let,
    };
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nsecond: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nf1: field  \\\\nf2: field  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nlet: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_first_inner_inner = {. \\"field\\": string};
  type t_first_inner = {. \\"inner\\": option(t_first_inner_inner)};
  type t_first = {. \\"inner\\": option(t_first_inner)};
  type t_second_inner_inner = {
    f1: string,
    f2: string,
  };
  type t_second_inner = {. \\"inner\\": option(t_second_inner_inner)};
  type t_second = {. \\"inner\\": option(t_second_inner)};
  type t_let_inner_inner = {. \\"field\\": string};
  type t_let_inner = {. \\"inner\\": option(t_let_inner_inner)};
  type t_let = {. \\"inner\\": option(t_let_inner)};
  type t = {
    .
    \\"first\\": t_first,
    \\"second\\": t_second,
    \\"let_\\": t_let,
  };
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let let_ = {
        let value = value##let_;
        let inner = {
          let value = value##inner;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {
                let inner = {
                  let value = value##inner;
                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some(
                      {
                        let field = {
                          let value = value##field;
                          value;
                        };
                        {\\"field\\": field};
                      },
                    )
                  | None => None
                  };
                };
                {\\"inner\\": inner};
              },
            )
          | None => None
          };
        };
        {\\"inner\\": inner};
      }
      and second = {
        let value = value##second;
        let inner = {
          let value = value##inner;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {
                let inner = {
                  let value = value##inner;
                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some(
                      {
                        let f2 = {
                          let value = value##f2;
                          value;
                        }
                        and f1 = {
                          let value = value##f1;
                          value;
                        };
                        {f1, f2};
                      }: t_second_inner_inner,
                    )
                  | None => None
                  };
                };
                {\\"inner\\": inner};
              },
            )
          | None => None
          };
        };
        {\\"inner\\": inner};
      }
      and first = {
        let value = value##first;
        let inner = {
          let value = value##inner;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {
                let inner = {
                  let value = value##inner;
                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some(
                      {
                        let field = {
                          let value = value##field;
                          value;
                        };
                        {\\"field\\": field};
                      },
                    )
                  | None => None
                  };
                };
                {\\"inner\\": inner};
              },
            )
          | None => None
          };
        };
        {\\"inner\\": inner};
      };
      {\\"first\\": first, \\"second\\": second, \\"let_\\": let_};
    };
  let serialize: t => Raw.t =
    value => {
      let let_ = {
        let value = value##let_;
        let inner = {
          let value = value##inner;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {
                let inner = {
                  let value = value##inner;
                  switch (value) {
                  | Some(value) =>
                    Js.Nullable.return(
                      {
                        let field = {
                          let value = value##field;
                          value;
                        };
                        {\\"field\\": field};
                      },
                    )
                  | None => Js.Nullable.null
                  };
                };
                {\\"inner\\": inner};
              },
            )
          | None => Js.Nullable.null
          };
        };
        {\\"inner\\": inner};
      }
      and second = {
        let value = value##second;
        let inner = {
          let value = value##inner;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {
                let inner = {
                  let value = value##inner;
                  switch (value) {
                  | Some(value) =>
                    Js.Nullable.return(
                      {
                        let f2 = {
                          let value = (value: t_second_inner_inner).f2;
                          value;
                        }
                        and f1 = {
                          let value = (value: t_second_inner_inner).f1;
                          value;
                        };
                        {\\"f1\\": f1, \\"f2\\": f2};
                      },
                    )
                  | None => Js.Nullable.null
                  };
                };
                {\\"inner\\": inner};
              },
            )
          | None => Js.Nullable.null
          };
        };
        {\\"inner\\": inner};
      }
      and first = {
        let value = value##first;
        let inner = {
          let value = value##inner;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {
                let inner = {
                  let value = value##inner;
                  switch (value) {
                  | Some(value) =>
                    Js.Nullable.return(
                      {
                        let field = {
                          let value = value##field;
                          value;
                        };
                        {\\"field\\": field};
                      },
                    )
                  | None => Js.Nullable.null
                  };
                };
                {\\"inner\\": inner};
              },
            )
          | None => Js.Nullable.null
          };
        };
        {\\"inner\\": inner};
      };
      {\\"first\\": first, \\"second\\": second, \\"let_\\": let_};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy nonrecursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"nonrecursiveInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      .
      \\"nonNullableField\\": string,
      \\"nullableArray\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"field\\": Js.Nullable.t(string),
      \\"enum\\": Js.Nullable.t(string),
      \\"embeddedInput\\":
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
      \\"custom\\": Js.Nullable.t(Js.Json.t),
    }
    and t_variables_EmbeddedInput = {. \\"field\\": Js.Nullable.t(string)};
  };
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"nonrecursiveInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    .
    \\"nonNullableField\\": string,
    \\"nullableArray\\": option(array(option(string))),
    \\"field\\": option(string),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
    \\"embeddedInput\\": option(array(option(t_variables_EmbeddedInput))),
    \\"custom\\": option(Js.Json.t),
  }
  and t_variables_EmbeddedInput = {. \\"field\\": option(string)};
  let parse: Raw.t => t =
    value => {
      let nonrecursiveInput = {
        let value = value##nonrecursiveInput;
        value;
      };
      {\\"nonrecursiveInput\\": nonrecursiveInput};
    };
  let serialize: t => Raw.t =
    value => {
      let nonrecursiveInput = {
        let value = value##nonrecursiveInput;
        value;
      };
      {\\"nonrecursiveInput\\": nonrecursiveInput};
    };
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"arg\\": (a => serializeInputObjectNonrecursiveInput(a))(inp##arg),
    }
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {
      \\"nonNullableField\\": (a => a)(inp##nonNullableField),
      \\"nullableArray\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableArray,
        ),
      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
      \\"enum\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          inp##enum,
        ),
      \\"embeddedInput\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##embeddedInput,
        ),
      \\"custom\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##custom,
        ),
    }
  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {
      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
    };
  let make = (~arg, ()) => {
    \\"query\\": query,
    \\"variables\\": serializeVariables({\\"arg\\": arg}: t_variables),
    \\"parse\\": parse,
  }
  and makeVariables = (~arg, ()) =>
    serializeVariables({\\"arg\\": arg}: t_variables)
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        ~custom=?,
        (),
      )
      : t_variables_NonrecursiveInput => {
    \\"nonNullableField\\": nonNullableField,
    \\"nullableArray\\": nullableArray,
    \\"field\\": field,
    \\"enum\\": enum,
    \\"embeddedInput\\": embeddedInput,
    \\"custom\\": custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {
    \\"field\\": field,
  };
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec _graphql_NonrecursiveInput_49;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_49: _graphql_NonrecursiveInput_49 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery2 = {
  module Raw = {
    type t = {
      .
      \\"scalarsInput\\": string,
      \\"more\\": string,
    };
    type t_variables = {
      .
      \\"arg\\": t_variables_NonrecursiveInput,
      \\"arg2\\": t_variables_NonrecursiveInput,
    }
    and t_variables_NonrecursiveInput = {
      .
      \\"nonNullableField\\": string,
      \\"nullableArray\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"field\\": Js.Nullable.t(string),
      \\"enum\\": Js.Nullable.t(string),
      \\"embeddedInput\\":
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
      \\"custom\\": Js.Nullable.t(Js.Json.t),
    }
    and t_variables_EmbeddedInput = {. \\"field\\": Js.Nullable.t(string)};
  };
  let query = \\"query ($arg: NonrecursiveInput!, $arg2: NonrecursiveInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\nmore: scalarsInput(arg: $arg2)  \\\\n}\\\\n\\";
  type t = {
    .
    \\"scalarsInput\\": string,
    \\"more\\": string,
  };
  type t_variables = {
    .
    \\"arg\\": t_variables_NonrecursiveInput,
    \\"arg2\\": t_variables_NonrecursiveInput,
  }
  and t_variables_NonrecursiveInput = {
    .
    \\"nonNullableField\\": string,
    \\"nullableArray\\": option(array(option(string))),
    \\"field\\": option(string),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
    \\"embeddedInput\\": option(array(option(t_variables_EmbeddedInput))),
    \\"custom\\": option(Js.Json.t),
  }
  and t_variables_EmbeddedInput = {. \\"field\\": option(string)};
  let parse: Raw.t => t =
    value => {
      let more = {
        let value = value##more;
        value;
      }
      and scalarsInput = {
        let value = value##scalarsInput;
        value;
      };
      {\\"scalarsInput\\": scalarsInput, \\"more\\": more};
    };
  let serialize: t => Raw.t =
    value => {
      let more = {
        let value = value##more;
        value;
      }
      and scalarsInput = {
        let value = value##scalarsInput;
        value;
      };
      {\\"scalarsInput\\": scalarsInput, \\"more\\": more};
    };
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"arg\\": (a => serializeInputObjectNonrecursiveInput(a))(inp##arg),
      \\"arg2\\": (a => serializeInputObjectNonrecursiveInput(a))(inp##arg2),
    }
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {
      \\"nonNullableField\\": (a => a)(inp##nonNullableField),
      \\"nullableArray\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableArray,
        ),
      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
      \\"enum\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          inp##enum,
        ),
      \\"embeddedInput\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##embeddedInput,
        ),
      \\"custom\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##custom,
        ),
    }
  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {
      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
    };
  let make = (~arg, ~arg2, ()) => {
    \\"query\\": query,
    \\"variables\\": serializeVariables({\\"arg\\": arg, \\"arg2\\": arg2}: t_variables),
    \\"parse\\": parse,
  }
  and makeVariables = (~arg, ~arg2, ()) =>
    serializeVariables({\\"arg\\": arg, \\"arg2\\": arg2}: t_variables)
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        ~custom=?,
        (),
      )
      : t_variables_NonrecursiveInput => {
    \\"nonNullableField\\": nonNullableField,
    \\"nullableArray\\": nullableArray,
    \\"field\\": field,
    \\"enum\\": enum,
    \\"embeddedInput\\": embeddedInput,
    \\"custom\\": custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {
    \\"field\\": field,
  };
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec _graphql_NonrecursiveInput_169;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_169: _graphql_NonrecursiveInput_169 =
      Obj.magic(0);
    type nonrec _graphql_NonrecursiveInput_196;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_196: _graphql_NonrecursiveInput_196 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery2 {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy omitFutureValueEnum.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Normal = {
  module Raw = {
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      .
      \\"message\\": string,
      \\"field\\": t_mutationWithError_errors_field,
    };
    type t_mutationWithError = {
      .
      \\"errors\\": Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {. \\"mutationWithError\\": t_mutationWithError};
    type t_variables = Js.Json.t;
  };
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_mutationWithError_errors_field = [
    | \`FutureAddedValue(string)
    | \`FIRST
    | \`SECOND
    | \`THIRD
  ];
  type t_mutationWithError_errors = {
    .
    \\"message\\": string,
    \\"field\\": t_mutationWithError_errors_field,
  };
  type t_mutationWithError = {
    .
    \\"errors\\": option(array(t_mutationWithError_errors)),
  };
  type t = {. \\"mutationWithError\\": t_mutationWithError};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let mutationWithError = {
        let value = value##mutationWithError;
        let errors = {
          let value = value##errors;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   let field = {
                     let value = value##field;
                     switch (Obj.magic(value: string)) {
                     | \\"FIRST\\" => \`FIRST
                     | \\"SECOND\\" => \`SECOND
                     | \\"THIRD\\" => \`THIRD
                     | other => \`FutureAddedValue(other)
                     };
                   }
                   and message = {
                     let value = value##message;
                     value;
                   };
                   {\\"message\\": message, \\"field\\": field};
                 ),
            )
          | None => None
          };
        };
        {\\"errors\\": errors};
      };
      {\\"mutationWithError\\": mutationWithError};
    };
  let serialize: t => Raw.t =
    value => {
      let mutationWithError = {
        let value = value##mutationWithError;
        let errors = {
          let value = value##errors;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   let field = {
                     let value = value##field;
                     switch (value) {
                     | \`FIRST => \\"FIRST\\"
                     | \`SECOND => \\"SECOND\\"
                     | \`THIRD => \\"THIRD\\"
                     | \`FutureAddedValue(other) => other
                     };
                   }
                   and message = {
                     let value = value##message;
                     value;
                   };
                   {\\"message\\": message, \\"field\\": field};
                 ),
            )
          | None => Js.Nullable.null
          };
        };
        {\\"errors\\": errors};
      };
      {\\"mutationWithError\\": mutationWithError};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module Normal {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByConfig = {
  module Raw = {
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      .
      \\"message\\": string,
      \\"field\\": t_mutationWithError_errors_field,
    };
    type t_mutationWithError = {
      .
      \\"errors\\": Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {. \\"mutationWithError\\": t_mutationWithError};
    type t_variables = Js.Json.t;
  };
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_mutationWithError_errors_field = [ | \`FIRST | \`SECOND | \`THIRD];
  type t_mutationWithError_errors = {
    .
    \\"message\\": string,
    \\"field\\": t_mutationWithError_errors_field,
  };
  type t_mutationWithError = {
    .
    \\"errors\\": option(array(t_mutationWithError_errors)),
  };
  type t = {. \\"mutationWithError\\": t_mutationWithError};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let mutationWithError = {
        let value = value##mutationWithError;
        let errors = {
          let value = value##errors;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   let field = {
                     let value = value##field;
                     switch (Obj.magic(value: string)) {
                     | \\"FIRST\\" => \`FIRST
                     | \\"SECOND\\" => \`SECOND
                     | \\"THIRD\\" => \`THIRD
                     | _ => raise(Not_found)
                     };
                   }
                   and message = {
                     let value = value##message;
                     value;
                   };
                   {\\"message\\": message, \\"field\\": field};
                 ),
            )
          | None => None
          };
        };
        {\\"errors\\": errors};
      };
      {\\"mutationWithError\\": mutationWithError};
    };
  let serialize: t => Raw.t =
    value => {
      let mutationWithError = {
        let value = value##mutationWithError;
        let errors = {
          let value = value##errors;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   let field = {
                     let value = value##field;
                     switch (value) {
                     | \`FIRST => \\"FIRST\\"
                     | \`SECOND => \\"SECOND\\"
                     | \`THIRD => \\"THIRD\\"
                     };
                   }
                   and message = {
                     let value = value##message;
                     value;
                   };
                   {\\"message\\": message, \\"field\\": field};
                 ),
            )
          | None => Js.Nullable.null
          };
        };
        {\\"errors\\": errors};
      };
      {\\"mutationWithError\\": mutationWithError};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByConfig {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByDirective = {
  module Raw = {
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      .
      \\"message\\": string,
      \\"field\\": t_mutationWithError_errors_field,
    };
    type t_mutationWithError = {
      .
      \\"errors\\": Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {. \\"mutationWithError\\": t_mutationWithError};
    type t_variables = Js.Json.t;
  };
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield @ppxOmitFutureValue \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_mutationWithError_errors_field = [ | \`FIRST | \`SECOND | \`THIRD];
  type t_mutationWithError_errors = {
    .
    \\"message\\": string,
    \\"field\\": t_mutationWithError_errors_field,
  };
  type t_mutationWithError = {
    .
    \\"errors\\": option(array(t_mutationWithError_errors)),
  };
  type t = {. \\"mutationWithError\\": t_mutationWithError};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let mutationWithError = {
        let value = value##mutationWithError;
        let errors = {
          let value = value##errors;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   let field = {
                     let value = value##field;
                     switch (Obj.magic(value: string)) {
                     | \\"FIRST\\" => \`FIRST
                     | \\"SECOND\\" => \`SECOND
                     | \\"THIRD\\" => \`THIRD
                     | _ => raise(Not_found)
                     };
                   }
                   and message = {
                     let value = value##message;
                     value;
                   };
                   {\\"message\\": message, \\"field\\": field};
                 ),
            )
          | None => None
          };
        };
        {\\"errors\\": errors};
      };
      {\\"mutationWithError\\": mutationWithError};
    };
  let serialize: t => Raw.t =
    value => {
      let mutationWithError = {
        let value = value##mutationWithError;
        let errors = {
          let value = value##errors;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   let field = {
                     let value = value##field;
                     switch (value) {
                     | \`FIRST => \\"FIRST\\"
                     | \`SECOND => \\"SECOND\\"
                     | \`THIRD => \\"THIRD\\"
                     };
                   }
                   and message = {
                     let value = value##message;
                     value;
                   };
                   {\\"message\\": message, \\"field\\": field};
                 ),
            )
          | None => Js.Nullable.null
          };
        };
        {\\"errors\\": errors};
      };
      {\\"mutationWithError\\": mutationWithError};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByDirective {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy omitFutureValueUnion.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Normal = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman_Human = {. \\"name\\": string};
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {\\"name\\": name, \\"barkVolume\\": barkVolume};
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                let name = {
                  let value = value##name;
                  value;
                };
                {\\"name\\": name};
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
  let serialize: t => Raw.t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {\\"__typename\\": \\"Dog\\", \\"name\\": name, \\"barkVolume\\": barkVolume};
              },
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = value##name;
                  value;
                };
                {\\"__typename\\": \\"Human\\", \\"name\\": name};
              },
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module Normal {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByConfig = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman_Human = {. \\"name\\": string};
  type t_dogOrHuman = [
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {\\"name\\": name, \\"barkVolume\\": barkVolume};
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                let name = {
                  let value = value##name;
                  value;
                };
                {\\"name\\": name};
              },
            )
          | _ => raise(Not_found)
          }: t_dogOrHuman
        );
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
  let serialize: t => Raw.t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {\\"__typename\\": \\"Dog\\", \\"name\\": name, \\"barkVolume\\": barkVolume};
              },
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = value##name;
                  value;
                };
                {\\"__typename\\": \\"Human\\", \\"name\\": name};
              },
            ): Raw.t_dogOrHuman
          )
        };
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByConfig {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByDirective = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndogOrHuman @ppxOmitFutureValue {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman_Human = {. \\"name\\": string};
  type t_dogOrHuman = [
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {\\"name\\": name, \\"barkVolume\\": barkVolume};
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                let name = {
                  let value = value##name;
                  value;
                };
                {\\"name\\": name};
              },
            )
          | _ => raise(Not_found)
          }: t_dogOrHuman
        );
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
  let serialize: t => Raw.t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {\\"__typename\\": \\"Dog\\", \\"name\\": name, \\"barkVolume\\": barkVolume};
              },
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = value##name;
                  value;
                };
                {\\"__typename\\": \\"Human\\", \\"name\\": name};
              },
            ): Raw.t_dogOrHuman
          )
        };
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByDirective {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy pokedexApolloMode.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_pokemon = {
      .
      \\"id\\": string,
      \\"name\\": Js.Nullable.t(string),
    };
    type t = {. \\"pokemon\\": Js.Nullable.t(t_pokemon)};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\npokemon(name: \\\\\\"Pikachu\\\\\\")  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_pokemon = {
    .
    \\"id\\": string,
    \\"name\\": option(string),
  };
  type t = {. \\"pokemon\\": option(t_pokemon)};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let pokemon = {
        let value = value##pokemon;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            {
              let name = {
                let value = value##name;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and id = {
                let value = value##id;
                value;
              };
              {\\"id\\": id, \\"name\\": name};
            },
          )
        | None => None
        };
      };
      {\\"pokemon\\": pokemon};
    };
  let serialize: t => Raw.t =
    value => {
      let pokemon = {
        let value = value##pokemon;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            {
              let name = {
                let value = value##name;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and id = {
                let value = value##id;
                value;
              };
              {\\"id\\": id, \\"name\\": name};
            },
          )
        | None => Js.Nullable.null
        };
      };
      {\\"pokemon\\": pokemon};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy pokedexScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_pokemon = {
      .
      \\"id\\": string,
      \\"name\\": Js.Nullable.t(string),
    };
    type t = {. \\"pokemon\\": Js.Nullable.t(t_pokemon)};
    type t_variables = {
      .
      \\"id\\": Js.Nullable.t(string),
      \\"name\\": Js.Nullable.t(string),
    };
  };
  let query = \\"query pokemon($id: String, $name: String)  {\\\\npokemon(name: $name, id: $id)  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_pokemon = {
    .
    \\"id\\": string,
    \\"name\\": option(string),
  };
  type t = {. \\"pokemon\\": option(t_pokemon)};
  type t_variables = {
    .
    \\"id\\": option(string),
    \\"name\\": option(string),
  };
  let parse: Raw.t => t =
    value => {
      let pokemon = {
        let value = value##pokemon;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            {
              let name = {
                let value = value##name;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and id = {
                let value = value##id;
                value;
              };
              {\\"id\\": id, \\"name\\": name};
            },
          )
        | None => None
        };
      };
      {\\"pokemon\\": pokemon};
    };
  let serialize: t => Raw.t =
    value => {
      let pokemon = {
        let value = value##pokemon;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            {
              let name = {
                let value = value##name;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and id = {
                let value = value##id;
                value;
              };
              {\\"id\\": id, \\"name\\": name};
            },
          )
        | None => Js.Nullable.null
        };
      };
      {\\"pokemon\\": pokemon};
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"id\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##id,
        ),
      \\"name\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##name,
        ),
    };
  let make = (~id=?, ~name=?, ()) => {
    \\"query\\": query,
    \\"variables\\": serializeVariables({\\"id\\": id, \\"name\\": name}: t_variables),
    \\"parse\\": parse,
  }
  and makeVariables = (~id=?, ~name=?, ()) =>
    serializeVariables({\\"id\\": id, \\"name\\": name}: t_variables);
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type scalars = {
  string,
  int,
};

type dog = {
  name: string,
  barkVolume: float,
};

type oneFieldQuery = {nullableString: option(string)};
module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      .
      \\"string\\": string,
      \\"int\\": int,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"variousScalars\\": scalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        (
          {
            let int = {
              let value = value##int;
              value;
            }
            and string = {
              let value = value##string;
              value;
            };
            {string, int};
          }: scalars
        );
      };
      {\\"variousScalars\\": variousScalars};
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let int = {
          let value = (value: scalars).int;
          value;
        }
        and string = {
          let value = (value: scalars).string;
          value;
        };
        {\\"string\\": string, \\"int\\": int};
      };
      {\\"variousScalars\\": variousScalars};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module OneFieldQuery = {
  module Raw = {
    type t_variousScalars = {. \\"nullableString\\": Js.Nullable.t(string)};
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {nullableString: option(string)};
  type t = {. \\"variousScalars\\": t_variousScalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        (
          {
            let nullableString = {
              let value = value##nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            };
            {nullableString: nullableString};
          }: t_variousScalars
        );
      };
      {\\"variousScalars\\": variousScalars};
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let nullableString = {
          let value = (value: t_variousScalars).nullableString;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {\\"nullableString\\": nullableString};
      };
      {\\"variousScalars\\": variousScalars};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module OneFieldQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ExternalFragmentQuery = {
  module Fragment = {
    let query = \\"fragment Fragment on VariousScalars   {\\\\nstring  \\\\nint  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        .
        \\"string\\": string,
        \\"int\\": int,
      };
      type nonrec t_VariousScalars = t;
    };
    type t = {
      string,
      int,
    };
    type nonrec t_VariousScalars = t;
    let parse = (value: Raw.t): t => {
      let int = {
        let value = value##int;
        value;
      }
      and string = {
        let value = value##string;
        value;
      };
      {string, int};
    };
    let serialize: t => Raw.t =
      value => {
        let int = {
          let value = (value: t).int;
          value;
        }
        and string = {
          let value = (value: t).string;
          value;
        };
        {\\"string\\": string, \\"int\\": int};
      };
    let name = \\"Fragment\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql;
      /**\`\`\`
VariousScalars {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}
\`\`\`*/
      let graphql: graphql = Obj.magic(0);
      type nonrec graphql_module;
      /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ExternalFragmentQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  module Untitled1 = {
    module Raw = {
      type t = {. \\"variousScalars\\": Fragment.Raw.t};
      type t_variables = Js.Json.t;
    };
    let query =
      (
        (\\"query   {\\\\nvariousScalars  {\\\\n...\\" ++ Fragment.name)
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ Fragment.query;
    type t = {. \\"variousScalars\\": Fragment.t};
    type t_variables = Js.Json.t;
    let parse: Raw.t => t =
      value => {
        let variousScalars = {
          let value = value##variousScalars;
          Fragment.parse(value);
        };
        {\\"variousScalars\\": variousScalars};
      };
    let serialize: t => Raw.t =
      value => {
        let variousScalars = {
          let value = value##variousScalars;
          Fragment.serialize(value);
        };
        {\\"variousScalars\\": variousScalars};
      };
    let make = () => {
      \\"query\\": query,
      \\"variables\\": Js.Json.null,
      \\"parse\\": parse,
    };
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql_module;
      /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ExternalFragmentQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
};
module InlineFragmentQuery = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                (
                  {
                    let barkVolume = {
                      let value = value##barkVolume;
                      value;
                    }
                    and name = {
                      let value = value##name;
                      value;
                    };
                    {name, barkVolume};
                  }: t_dogOrHuman_Dog
                );
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
  let serialize: t => Raw.t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = (value: t_dogOrHuman_Dog).barkVolume;
                  value;
                }
                and name = {
                  let value = (value: t_dogOrHuman_Dog).name;
                  value;
                };
                {\\"__typename\\": \\"Dog\\", \\"name\\": name, \\"barkVolume\\": barkVolume};
              },
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module InlineFragmentQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module UnionExternalFragmentQuery = {
  module DogFragment = {
    let query = \\"fragment DogFragment on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        .
        \\"name\\": string,
        \\"barkVolume\\": float,
      };
      type nonrec t_Dog = t;
    };
    type t = {
      name: string,
      barkVolume: float,
    };
    type nonrec t_Dog = t;
    let parse = (value: Raw.t): t => {
      let barkVolume = {
        let value = value##barkVolume;
        value;
      }
      and name = {
        let value = value##name;
        value;
      };
      {name, barkVolume};
    };
    let serialize: t => Raw.t =
      value => {
        let barkVolume = {
          let value = (value: t).barkVolume;
          value;
        }
        and name = {
          let value = (value: t).name;
          value;
        };
        {\\"name\\": name, \\"barkVolume\\": barkVolume};
      };
    let name = \\"DogFragment\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql;
      /**\`\`\`
Dog {
  name: String!
  barkVolume: Float!
}
\`\`\`*/
      let graphql: graphql = Obj.magic(0);
      type nonrec graphql_module;
      /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module UnionExternalFragmentQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  module Untitled1 = {
    module Raw = {
      type t_dogOrHuman;
      type t = {. \\"dogOrHuman\\": t_dogOrHuman};
      type t_variables = Js.Json.t;
    };
    let query =
      (
        (
          \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n...\\"
          ++ DogFragment.name
        )
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ DogFragment.query;
    type t_dogOrHuman = [
      | \`FutureAddedValue(Js.Json.t)
      | \`Dog(DogFragment.t)
    ];
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = Js.Json.t;
    let parse: Raw.t => t =
      value => {
        let dogOrHuman = {
          let value = value##dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: DogFragment.Raw.t = Obj.magic(value);
                  DogFragment.parse(value);
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        };
        {\\"dogOrHuman\\": dogOrHuman};
      };
    let serialize: t => Raw.t =
      value => {
        let dogOrHuman = {
          let value = value##dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(DogFragment.serialize(value)): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        };
        {\\"dogOrHuman\\": dogOrHuman};
      };
    let make = () => {
      \\"query\\": query,
      \\"variables\\": Js.Json.null,
      \\"parse\\": parse,
    };
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql_module;
      /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module UnionExternalFragmentQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
};
"
`;

exports[`Legacy recursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"recursiveInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_RecursiveInput}
    and t_variables_RecursiveInput = {
      .
      \\"otherField\\": Js.Nullable.t(string),
      \\"inner\\": Js.Nullable.t(t_variables_RecursiveInput),
      \\"enum\\": Js.Nullable.t(string),
    };
  };
  let query = \\"query ($arg: RecursiveInput!)  {\\\\nrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"recursiveInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_RecursiveInput}
  and t_variables_RecursiveInput = {
    .
    \\"otherField\\": option(string),
    \\"inner\\": option(t_variables_RecursiveInput),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  let parse: Raw.t => t =
    value => {
      let recursiveInput = {
        let value = value##recursiveInput;
        value;
      };
      {\\"recursiveInput\\": recursiveInput};
    };
  let serialize: t => Raw.t =
    value => {
      let recursiveInput = {
        let value = value##recursiveInput;
        value;
      };
      {\\"recursiveInput\\": recursiveInput};
    };
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"arg\\": (a => serializeInputObjectRecursiveInput(a))(inp##arg)}
  and serializeInputObjectRecursiveInput:
    t_variables_RecursiveInput => Raw.t_variables_RecursiveInput =
    inp => {
      \\"otherField\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##otherField,
        ),
      \\"inner\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (a => serializeInputObjectRecursiveInput(a))(b),
              )
            }
        )(
          inp##inner,
        ),
      \\"enum\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          inp##enum,
        ),
    };
  let make = (~arg, ()) => {
    \\"query\\": query,
    \\"variables\\": serializeVariables({\\"arg\\": arg}: t_variables),
    \\"parse\\": parse,
  }
  and makeVariables = (~arg, ()) =>
    serializeVariables({\\"arg\\": arg}: t_variables)
  and makeInputObjectRecursiveInput =
      (~otherField=?, ~inner=?, ~enum=?, ()): t_variables_RecursiveInput => {
    \\"otherField\\": otherField,
    \\"inner\\": inner,
    \\"enum\\": enum,
  };
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec _graphql_RecursiveInput_47;
    /**\`\`\`
RecursiveInput {
  otherField: String
  inner: RecursiveInput
  enum: SampleField
}
\`\`\`*/
    let _graphql_RecursiveInput_47: _graphql_RecursiveInput_47 = Obj.magic(0);
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy scalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {
          \\"nullableString\\": nullableString,
          \\"string\\": string,
          \\"nullableInt\\": nullableInt,
          \\"int\\": int,
          \\"nullableFloat\\": nullableFloat,
          \\"float\\": float,
          \\"nullableBoolean\\": nullableBoolean,
          \\"boolean\\": boolean,
          \\"nullableID\\": nullableID,
          \\"id\\": id,
        };
      };
      {\\"variousScalars\\": variousScalars};
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {
          \\"nullableString\\": nullableString,
          \\"string\\": string,
          \\"nullableInt\\": nullableInt,
          \\"int\\": int,
          \\"nullableFloat\\": nullableFloat,
          \\"float\\": float,
          \\"nullableBoolean\\": nullableBoolean,
          \\"boolean\\": boolean,
          \\"nullableID\\": nullableID,
          \\"id\\": id,
        };
      };
      {\\"variousScalars\\": variousScalars};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy scalarsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"scalarsInput\\": string};
    type t_variables = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  let query = \\"query ($nullableString: String, $string: String!, $nullableInt: Int, $int: Int!, $nullableFloat: Float, $float: Float!, $nullableBoolean: Boolean, $boolean: Boolean!, $nullableID: ID, $id: ID!)  {\\\\nscalarsInput(arg: {nullableString: $nullableString, string: $string, nullableInt: $nullableInt, int: $int, nullableFloat: $nullableFloat, float: $float, nullableBoolean: $nullableBoolean, boolean: $boolean, nullableID: $nullableID, id: $id})  \\\\n}\\\\n\\";
  type t = {. \\"scalarsInput\\": string};
  type t_variables = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {
      let scalarsInput = {
        let value = value##scalarsInput;
        value;
      };
      {\\"scalarsInput\\": scalarsInput};
    };
  let serialize: t => Raw.t =
    value => {
      let scalarsInput = {
        let value = value##scalarsInput;
        value;
      };
      {\\"scalarsInput\\": scalarsInput};
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"nullableString\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableString,
        ),
      \\"string\\": (a => a)(inp##string),
      \\"nullableInt\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableInt,
        ),
      \\"int\\": (a => a)(inp##int),
      \\"nullableFloat\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableFloat,
        ),
      \\"float\\": (a => a)(inp##float),
      \\"nullableBoolean\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableBoolean,
        ),
      \\"boolean\\": (a => a)(inp##boolean),
      \\"nullableID\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableID,
        ),
      \\"id\\": (a => a)(inp##id),
    };
  let make =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      ) => {
    \\"query\\": query,
    \\"variables\\":
      serializeVariables(
        {
          \\"nullableString\\": nullableString,
          \\"string\\": string,
          \\"nullableInt\\": nullableInt,
          \\"int\\": int,
          \\"nullableFloat\\": nullableFloat,
          \\"float\\": float,
          \\"nullableBoolean\\": nullableBoolean,
          \\"boolean\\": boolean,
          \\"nullableID\\": nullableID,
          \\"id\\": id,
        }: t_variables,
      ),
    \\"parse\\": parse,
  }
  and makeVariables =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      ) =>
    serializeVariables(
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      }: t_variables,
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy scalarsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"scalarsInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_VariousScalarsInput}
    and t_variables_VariousScalarsInput = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  let query = \\"query ($arg: VariousScalarsInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"scalarsInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_VariousScalarsInput}
  and t_variables_VariousScalarsInput = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {
      let scalarsInput = {
        let value = value##scalarsInput;
        value;
      };
      {\\"scalarsInput\\": scalarsInput};
    };
  let serialize: t => Raw.t =
    value => {
      let scalarsInput = {
        let value = value##scalarsInput;
        value;
      };
      {\\"scalarsInput\\": scalarsInput};
    };
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"arg\\": (a => serializeInputObjectVariousScalarsInput(a))(inp##arg),
    }
  and serializeInputObjectVariousScalarsInput:
    t_variables_VariousScalarsInput => Raw.t_variables_VariousScalarsInput =
    inp => {
      \\"nullableString\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableString,
        ),
      \\"string\\": (a => a)(inp##string),
      \\"nullableInt\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableInt,
        ),
      \\"int\\": (a => a)(inp##int),
      \\"nullableFloat\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableFloat,
        ),
      \\"float\\": (a => a)(inp##float),
      \\"nullableBoolean\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableBoolean,
        ),
      \\"boolean\\": (a => a)(inp##boolean),
      \\"nullableID\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableID,
        ),
      \\"id\\": (a => a)(inp##id),
    };
  let make = (~arg, ()) => {
    \\"query\\": query,
    \\"variables\\": serializeVariables({\\"arg\\": arg}: t_variables),
    \\"parse\\": parse,
  }
  and makeVariables = (~arg, ()) =>
    serializeVariables({\\"arg\\": arg}: t_variables)
  and makeInputObjectVariousScalarsInput =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      )
      : t_variables_VariousScalarsInput => {
    \\"nullableString\\": nullableString,
    \\"string\\": string,
    \\"nullableInt\\": nullableInt,
    \\"int\\": int,
    \\"nullableFloat\\": nullableFloat,
    \\"float\\": float,
    \\"nullableBoolean\\": nullableBoolean,
    \\"boolean\\": boolean,
    \\"nullableID\\": nullableID,
    \\"id\\": id,
  };
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec _graphql_VariousScalarsInput_47;
    /**\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}
\`\`\`*/
    let _graphql_VariousScalarsInput_47: _graphql_VariousScalarsInput_47 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy skipDirectives.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_v1 = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": Js.Nullable.t(string),
    };
    type t_v2 = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": Js.Nullable.t(string),
    };
    type t = {
      .
      \\"v1\\": t_v1,
      \\"v2\\": t_v2,
    };
    type t_variables = {. \\"var\\": bool};
  };
  let query = \\"query ($var: Boolean!)  {\\\\nv1: variousScalars  {\\\\nnullableString @skip(if: $var) \\\\nstring @skip(if: $var) \\\\n}\\\\n\\\\nv2: variousScalars  {\\\\nnullableString @include(if: $var) \\\\nstring @include(if: $var) \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_v1 = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": option(string),
  };
  type t_v2 = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": option(string),
  };
  type t = {
    .
    \\"v1\\": t_v1,
    \\"v2\\": t_v2,
  };
  type t_variables = {. \\"var\\": bool};
  let parse: Raw.t => t =
    value => {
      let v2 = {
        let value = value##v2;
        let string = {
          let value = value##string;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and nullableString = {
          let value = value##nullableString;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {\\"nullableString\\": nullableString, \\"string\\": string};
      }
      and v1 = {
        let value = value##v1;
        let string = {
          let value = value##string;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and nullableString = {
          let value = value##nullableString;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {\\"nullableString\\": nullableString, \\"string\\": string};
      };
      {\\"v1\\": v1, \\"v2\\": v2};
    };
  let serialize: t => Raw.t =
    value => {
      let v2 = {
        let value = value##v2;
        let string = {
          let value = value##string;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and nullableString = {
          let value = value##nullableString;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {\\"nullableString\\": nullableString, \\"string\\": string};
      }
      and v1 = {
        let value = value##v1;
        let string = {
          let value = value##string;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and nullableString = {
          let value = value##nullableString;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {\\"nullableString\\": nullableString, \\"string\\": string};
      };
      {\\"v1\\": v1, \\"v2\\": v2};
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"var\\": (a => a)(inp##var)};
  let make = (~var, ()) => {
    \\"query\\": query,
    \\"variables\\": serializeVariables({\\"var\\": var}: t_variables),
    \\"parse\\": parse,
  }
  and makeVariables = (~var, ()) =>
    serializeVariables({\\"var\\": var}: t_variables);
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy subscription.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_simpleSubscription_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_simpleSubscription_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_simpleSubscription;
    type t = {. \\"simpleSubscription\\": t_simpleSubscription};
    type t_variables = Js.Json.t;
  };
  let query = \\"subscription   {\\\\nsimpleSubscription  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_simpleSubscription_Dog = {. \\"name\\": string};
  type t_simpleSubscription_Human = {. \\"name\\": string};
  type t_simpleSubscription = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_simpleSubscription_Dog)
    | \`Human(t_simpleSubscription_Human)
  ];
  type t = {. \\"simpleSubscription\\": t_simpleSubscription};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let simpleSubscription = {
        let value = value##simpleSubscription;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_simpleSubscription_Dog = Obj.magic(value);
                let name = {
                  let value = value##name;
                  value;
                };
                {\\"name\\": name};
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_simpleSubscription_Human = Obj.magic(value);
                let name = {
                  let value = value##name;
                  value;
                };
                {\\"name\\": name};
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_simpleSubscription
        );
      };
      {\\"simpleSubscription\\": simpleSubscription};
    };
  let serialize: t => Raw.t =
    value => {
      let simpleSubscription = {
        let value = value##simpleSubscription;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let name = {
                  let value = value##name;
                  value;
                };
                {\\"__typename\\": \\"Dog\\", \\"name\\": name};
              },
            ): Raw.t_simpleSubscription
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = value##name;
                  value;
                };
                {\\"__typename\\": \\"Human\\", \\"name\\": name};
              },
            ): Raw.t_simpleSubscription
          )
        | \`FutureAddedValue(value) => (
            Obj.magic(value): Raw.t_simpleSubscription
          )
        };
      };
      {\\"simpleSubscription\\": simpleSubscription};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy tagged_template.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {
          \\"nullableString\\": nullableString,
          \\"string\\": string,
          \\"nullableInt\\": nullableInt,
          \\"int\\": int,
          \\"nullableFloat\\": nullableFloat,
          \\"float\\": float,
          \\"nullableBoolean\\": nullableBoolean,
          \\"boolean\\": boolean,
          \\"nullableID\\": nullableID,
          \\"id\\": id,
        };
      };
      {\\"variousScalars\\": variousScalars};
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {
          \\"nullableString\\": nullableString,
          \\"string\\": string,
          \\"nullableInt\\": nullableInt,
          \\"int\\": int,
          \\"nullableFloat\\": nullableFloat,
          \\"float\\": float,
          \\"nullableBoolean\\": nullableBoolean,
          \\"boolean\\": boolean,
          \\"nullableID\\": nullableID,
          \\"id\\": id,
        };
      };
      {\\"variousScalars\\": variousScalars};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery2 = {
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = Js.Json.t;
  };
  %raw
  \\"let { graphql } = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {
          \\"nullableString\\": nullableString,
          \\"string\\": string,
          \\"nullableInt\\": nullableInt,
          \\"int\\": int,
          \\"nullableFloat\\": nullableFloat,
          \\"float\\": float,
          \\"nullableBoolean\\": nullableBoolean,
          \\"boolean\\": boolean,
          \\"nullableID\\": nullableID,
          \\"id\\": id,
        };
      };
      {\\"variousScalars\\": variousScalars};
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {
          \\"nullableString\\": nullableString,
          \\"string\\": string,
          \\"nullableInt\\": nullableInt,
          \\"int\\": int,
          \\"nullableFloat\\": nullableFloat,
          \\"float\\": float,
          \\"nullableBoolean\\": nullableBoolean,
          \\"boolean\\": boolean,
          \\"nullableID\\": nullableID,
          \\"id\\": id,
        };
      };
      {\\"variousScalars\\": variousScalars};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery2 {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery3 = {
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = Js.Json.t;
  };
  %raw
  \\"let { graphql } = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {
          \\"nullableString\\": nullableString,
          \\"string\\": string,
          \\"nullableInt\\": nullableInt,
          \\"int\\": int,
          \\"nullableFloat\\": nullableFloat,
          \\"float\\": float,
          \\"nullableBoolean\\": nullableBoolean,
          \\"boolean\\": boolean,
          \\"nullableID\\": nullableID,
          \\"id\\": id,
        };
      };
      {\\"variousScalars\\": variousScalars};
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {
          \\"nullableString\\": nullableString,
          \\"string\\": string,
          \\"nullableInt\\": nullableInt,
          \\"int\\": int,
          \\"nullableFloat\\": nullableFloat,
          \\"float\\": float,
          \\"nullableBoolean\\": nullableBoolean,
          \\"boolean\\": boolean,
          \\"nullableID\\": nullableID,
          \\"id\\": id,
        };
      };
      {\\"variousScalars\\": variousScalars};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery3 {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery4 = {
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = Js.Json.t;
  };
  %raw
  \\"let graphql = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {
          \\"nullableString\\": nullableString,
          \\"string\\": string,
          \\"nullableInt\\": nullableInt,
          \\"int\\": int,
          \\"nullableFloat\\": nullableFloat,
          \\"float\\": float,
          \\"nullableBoolean\\": nullableBoolean,
          \\"boolean\\": boolean,
          \\"nullableID\\": nullableID,
          \\"id\\": id,
        };
      };
      {\\"variousScalars\\": variousScalars};
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {
          \\"nullableString\\": nullableString,
          \\"string\\": string,
          \\"nullableInt\\": nullableInt,
          \\"int\\": int,
          \\"nullableFloat\\": nullableFloat,
          \\"float\\": float,
          \\"nullableBoolean\\": nullableBoolean,
          \\"boolean\\": boolean,
          \\"nullableID\\": nullableID,
          \\"id\\": id,
        };
      };
      {\\"variousScalars\\": variousScalars};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery4 {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy typename.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_first_inner_inner = {
      .
      \\"__typename\\": string,
      \\"field\\": string,
    };
    type t_first_inner = {
      .
      \\"__typename\\": string,
      \\"inner\\": Js.Nullable.t(t_first_inner_inner),
    };
    type t_first = {
      .
      \\"__typename\\": string,
      \\"inner\\": Js.Nullable.t(t_first_inner),
    };
    type t = {. \\"first\\": t_first};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_first_inner_inner = {
    .
    \\"__typename\\": string,
    \\"field\\": string,
  };
  type t_first_inner = {
    .
    \\"__typename\\": string,
    \\"inner\\": option(t_first_inner_inner),
  };
  type t_first = {
    .
    \\"__typename\\": string,
    \\"inner\\": option(t_first_inner),
  };
  type t = {. \\"first\\": t_first};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let first = {
        let value = value##first;
        let inner = {
          let value = value##inner;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {
                let inner = {
                  let value = value##inner;
                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some(
                      {
                        let field = {
                          let value = value##field;
                          value;
                        }
                        and __typename = {
                          let value = value##__typename;
                          value;
                        };
                        {\\"__typename\\": __typename, \\"field\\": field};
                      },
                    )
                  | None => None
                  };
                }
                and __typename = {
                  let value = value##__typename;
                  value;
                };
                {\\"__typename\\": __typename, \\"inner\\": inner};
              },
            )
          | None => None
          };
        }
        and __typename = {
          let value = value##__typename;
          value;
        };
        {\\"__typename\\": __typename, \\"inner\\": inner};
      };
      {\\"first\\": first};
    };
  let serialize: t => Raw.t =
    value => {
      let first = {
        let value = value##first;
        let inner = {
          let value = value##inner;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {
                let inner = {
                  let value = value##inner;
                  switch (value) {
                  | Some(value) =>
                    Js.Nullable.return(
                      {
                        let field = {
                          let value = value##field;
                          value;
                        }
                        and __typename = {
                          let value = value##__typename;
                          value;
                        };
                        {\\"__typename\\": __typename, \\"field\\": field};
                      },
                    )
                  | None => Js.Nullable.null
                  };
                }
                and __typename = {
                  let value = value##__typename;
                  value;
                };
                {\\"__typename\\": __typename, \\"inner\\": inner};
              },
            )
          | None => Js.Nullable.null
          };
        }
        and __typename = {
          let value = value##__typename;
          value;
        };
        {\\"__typename\\": __typename, \\"inner\\": inner};
      };
      {\\"first\\": first};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy union.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman_Human = {. \\"name\\": string};
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {\\"name\\": name, \\"barkVolume\\": barkVolume};
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                let name = {
                  let value = value##name;
                  value;
                };
                {\\"name\\": name};
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
  let serialize: t => Raw.t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {\\"__typename\\": \\"Dog\\", \\"name\\": name, \\"barkVolume\\": barkVolume};
              },
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = value##name;
                  value;
                };
                {\\"__typename\\": \\"Human\\", \\"name\\": name};
              },
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQueryNoError = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman_Human = {. \\"name\\": string};
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {\\"name\\": name, \\"barkVolume\\": barkVolume};
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                let name = {
                  let value = value##name;
                  value;
                };
                {\\"name\\": name};
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
  let serialize: t => Raw.t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {\\"__typename\\": \\"Dog\\", \\"name\\": name, \\"barkVolume\\": barkVolume};
              },
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = value##name;
                  value;
                };
                {\\"__typename\\": \\"Human\\", \\"name\\": name};
              },
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQueryNoError {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy unionPartial.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {\\"name\\": name, \\"barkVolume\\": barkVolume};
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
  let serialize: t => Raw.t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {\\"__typename\\": \\"Dog\\", \\"name\\": name, \\"barkVolume\\": barkVolume};
              },
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy variant.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_mutationForVariant_dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_mutationForVariant_human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_mutationForVariant_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_mutationForVariant_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_mutationForVariant_dogOrHuman;
    type t_mutationForVariant;
    type t = {. \\"mutationForVariant\\": t_mutationForVariant};
    type t_variables = Js.Json.t;
  };
  let query = \\"mutation   {\\\\nmutationForVariant  {\\\\nbaseType  \\\\nbaseTypeList  \\\\ndog  {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\nhuman  {\\\\nname  \\\\n}\\\\n\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_mutationForVariant_dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_mutationForVariant_human = {. \\"name\\": string};
  type t_mutationForVariant_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_mutationForVariant_dogOrHuman_Human = {. \\"name\\": string};
  type t_mutationForVariant_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_mutationForVariant_dogOrHuman_Dog)
    | \`Human(t_mutationForVariant_dogOrHuman_Human)
  ];
  type t_mutationForVariant = [
    | \`BaseType(string)
    | \`BaseTypeList(array(string))
    | \`Dog(t_mutationForVariant_dog)
    | \`Human(t_mutationForVariant_human)
    | \`DogOrHuman(t_mutationForVariant_dogOrHuman)
  ];
  type t = {. \\"mutationForVariant\\": t_mutationForVariant};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let mutationForVariant = {
        let value = value##mutationForVariant;
        switch (Js.Json.decodeObject(Obj.magic(value): Js.Json.t)) {
        | None =>
          Js.Exn.raiseError(
            \\"graphql_ppx: \\"
            ++ \\"Expected type \\"
            ++ \\"VariantTestResult\\"
            ++ \\" to be an object\\",
          )
        | Some(value) =>
          let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"baseType\\");
          switch (Js.Json.decodeNull(temp)) {
          | None =>
            let value = temp;
            \`BaseType(value);
          | Some(_) =>
            let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"baseTypeList\\");
            switch (Js.Json.decodeNull(temp)) {
            | None =>
              let value = temp;
              \`BaseTypeList(value |> Js.Array.map(value => value));
            | Some(_) =>
              let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"dog\\");
              switch (Js.Json.decodeNull(temp)) {
              | None =>
                let value = temp;
                \`Dog(
                  {
                    let barkVolume = {
                      let value = value##barkVolume;
                      value;
                    }
                    and name = {
                      let value = value##name;
                      value;
                    };
                    {\\"name\\": name, \\"barkVolume\\": barkVolume};
                  },
                );
              | Some(_) =>
                let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"human\\");
                switch (Js.Json.decodeNull(temp)) {
                | None =>
                  let value = temp;
                  \`Human(
                    {
                      let name = {
                        let value = value##name;
                        value;
                      };
                      {\\"name\\": name};
                    },
                  );
                | Some(_) =>
                  let temp =
                    Js.Dict.unsafeGet(Obj.magic(value), \\"dogOrHuman\\");
                  switch (Js.Json.decodeNull(temp)) {
                  | None =>
                    let value = temp;
                    \`DogOrHuman(
                      {
                        let typename: string =
                          Obj.magic(
                            Js.Dict.unsafeGet(
                              Obj.magic(value),
                              \\"__typename\\",
                            ),
                          );
                        (
                          switch (typename) {
                          | \\"Dog\\" =>
                            \`Dog(
                              {
                                let value: Raw.t_mutationForVariant_dogOrHuman_Dog =
                                  Obj.magic(value);
                                let barkVolume = {
                                  let value = value##barkVolume;
                                  value;
                                }
                                and name = {
                                  let value = value##name;
                                  value;
                                };
                                {\\"name\\": name, \\"barkVolume\\": barkVolume};
                              },
                            )
                          | \\"Human\\" =>
                            \`Human(
                              {
                                let value: Raw.t_mutationForVariant_dogOrHuman_Human =
                                  Obj.magic(value);
                                let name = {
                                  let value = value##name;
                                  value;
                                };
                                {\\"name\\": name};
                              },
                            )
                          | _ =>
                            \`FutureAddedValue(Obj.magic(value): Js.Json.t)
                          }: t_mutationForVariant_dogOrHuman
                        );
                      },
                    );
                  | Some(_) =>
                    Js.Exn.raiseError(
                      \\"graphql_ppx: \\"
                      ++ \\"All fields on variant selection set on type \\"
                      ++ \\"VariantTestResult\\"
                      ++ \\" were null\\",
                    )
                  };
                };
              };
            };
          };
        };
      };
      {\\"mutationForVariant\\": mutationForVariant};
    };
  let serialize: t => Raw.t =
    value => {
      let mutationForVariant = {
        let value = value##mutationForVariant;
        Obj.magic(Js.Json.null);
      };
      {\\"mutationForVariant\\": mutationForVariant};
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects argNamedQuery.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"argNamedQuery\\": int};
    type t_variables = {. \\"query\\": int};
  };
  let query = \\"query ($query: Int!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\";
  type t = {. \\"argNamedQuery\\": int};
  type t_variables = {. \\"query\\": int};
  let parse: Raw.t => t =
    value => {
      let argNamedQuery = {
        let value = value##argNamedQuery;
        value;
      };
      {\\"argNamedQuery\\": argNamedQuery};
    };
  let serialize: t => Raw.t =
    value => {
      let argNamedQuery = {
        let value = value##argNamedQuery;
        value;
      };
      {\\"argNamedQuery\\": argNamedQuery};
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"query\\": (a => a)(inp##query)};
  let makeVariables = (~query, ()) =>
    serializeVariables({\\"query\\": query}: t_variables);
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects comment.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"nonrecursiveInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      .
      \\"nonNullableField\\": string,
      \\"nullableArray\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"field\\": Js.Nullable.t(string),
      \\"enum\\": Js.Nullable.t(string),
      \\"embeddedInput\\":
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
      \\"custom\\": Js.Nullable.t(Js.Json.t),
    }
    and t_variables_EmbeddedInput = {. \\"field\\": Js.Nullable.t(string)};
  };
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"nonrecursiveInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    .
    \\"nonNullableField\\": string,
    \\"nullableArray\\": option(array(option(string))),
    \\"field\\": option(string),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
    \\"embeddedInput\\": option(array(option(t_variables_EmbeddedInput))),
    \\"custom\\": option(Js.Json.t),
  }
  and t_variables_EmbeddedInput = {. \\"field\\": option(string)};
  let parse: Raw.t => t =
    value => {
      let nonrecursiveInput = {
        let value = value##nonrecursiveInput;
        value;
      };
      {\\"nonrecursiveInput\\": nonrecursiveInput};
    };
  let serialize: t => Raw.t =
    value => {
      let nonrecursiveInput = {
        let value = value##nonrecursiveInput;
        value;
      };
      {\\"nonrecursiveInput\\": nonrecursiveInput};
    };
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"arg\\": (a => serializeInputObjectNonrecursiveInput(a))(inp##arg),
    }
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {
      \\"nonNullableField\\": (a => a)(inp##nonNullableField),
      \\"nullableArray\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableArray,
        ),
      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
      \\"enum\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          inp##enum,
        ),
      \\"embeddedInput\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##embeddedInput,
        ),
      \\"custom\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##custom,
        ),
    }
  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {
      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({\\"arg\\": arg}: t_variables)
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        ~custom=?,
        (),
      )
      : t_variables_NonrecursiveInput => {
    \\"nonNullableField\\": nonNullableField,
    \\"nullableArray\\": nullableArray,
    \\"field\\": field,
    \\"enum\\": enum,
    \\"embeddedInput\\": embeddedInput,
    \\"custom\\": custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {
    \\"field\\": field,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec _graphql_NonrecursiveInput_49;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_49: _graphql_NonrecursiveInput_49 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects customDecoder.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module StringOfInt = {
  let parse = string_of_int;
  let serialize = int_of_string;
  type t = string;
};
module IntOfString = {
  let parse = int_of_string;
  let serialize = string_of_int;
  type t = int;
};
module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      .
      \\"string\\": string,
      \\"int\\": int,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {
    .
    \\"string\\": IntOfString.t,
    \\"int\\": StringOfInt.t,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let int = {
          let value = value##int;
          StringOfInt.parse(value);
        }
        and string = {
          let value = value##string;
          IntOfString.parse(value);
        };
        {\\"string\\": string, \\"int\\": int};
      };
      {\\"variousScalars\\": variousScalars};
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let int = {
          let value = value##int;
          StringOfInt.serialize(value);
        }
        and string = {
          let value = value##string;
          IntOfString.serialize(value);
        };
        {\\"string\\": string, \\"int\\": int};
      };
      {\\"variousScalars\\": variousScalars};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects customScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_customScalarField = {
      .
      \\"nullable\\": Js.Nullable.t(Js.Json.t),
      \\"nonNullable\\": Js.Json.t,
    };
    type t = {. \\"customScalarField\\": t_customScalarField};
    type t_variables = {
      .
      \\"opt\\": Js.Nullable.t(Js.Json.t),
      \\"req\\": Js.Json.t,
    };
  };
  let query = \\"query ($opt: CustomScalar, $req: CustomScalar!)  {\\\\ncustomScalarField(argOptional: $opt, argRequired: $req)  {\\\\nnullable  \\\\nnonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_customScalarField = {
    .
    \\"nullable\\": option(Js.Json.t),
    \\"nonNullable\\": Js.Json.t,
  };
  type t = {. \\"customScalarField\\": t_customScalarField};
  type t_variables = {
    .
    \\"opt\\": option(Js.Json.t),
    \\"req\\": Js.Json.t,
  };
  let parse: Raw.t => t =
    value => {
      let customScalarField = {
        let value = value##customScalarField;
        let nonNullable = {
          let value = value##nonNullable;
          value;
        }
        and nullable = {
          let value = value##nullable;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {\\"nullable\\": nullable, \\"nonNullable\\": nonNullable};
      };
      {\\"customScalarField\\": customScalarField};
    };
  let serialize: t => Raw.t =
    value => {
      let customScalarField = {
        let value = value##customScalarField;
        let nonNullable = {
          let value = value##nonNullable;
          value;
        }
        and nullable = {
          let value = value##nullable;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {\\"nullable\\": nullable, \\"nonNullable\\": nonNullable};
      };
      {\\"customScalarField\\": customScalarField};
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"opt\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##opt,
        ),
      \\"req\\": (a => a)(inp##req),
    };
  let makeVariables = (~opt=?, ~req, ()) =>
    serializeVariables({\\"opt\\": opt, \\"req\\": req}: t_variables);
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects customTypes.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Color = {
  type t =
    | Red
    | Green
    | Blue;
  let parse = json =>
    switch (json |> Js.Json.decodeString) {
    | Some(\\"green\\") => Green
    | Some(\\"blue\\") => Blue
    | Some(\\"red\\")
    | Some(_)
    | None => Red
    };
  let serialize = color =>
    (
      switch (color) {
      | Red => \\"red\\"
      | Green => \\"green\\"
      | Blue => \\"blue\\"
      }
    )
    |> Js.Json.string;
};
module DateTime = {
  type t = Js.Date.t;
  let parse = json =>
    switch (json |> Js.Json.decodeString) {
    | Some(str) => str |> Js.Date.fromString
    | None => Js.Date.make()
    };
  let serialize = date => date |> Js.Date.toISOString |> Js.Json.string;
};
module MyQuery = {
  module Raw = {
    type t_customFields = {
      .
      \\"currentTime\\": Js.Json.t,
      \\"favoriteColor\\": Js.Json.t,
      \\"futureTime\\": Js.Nullable.t(Js.Json.t),
      \\"nullableColor\\": Js.Nullable.t(Js.Json.t),
    };
    type t = {. \\"customFields\\": t_customFields};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ncustomFields  {\\\\ncurrentTime  \\\\nfavoriteColor  \\\\nfutureTime  \\\\nnullableColor  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_customFields = {
    .
    \\"currentTime\\": DateTime.t,
    \\"favoriteColor\\": Color.t,
    \\"futureTime\\": option(DateTime.t),
    \\"nullableColor\\": option(Color.t),
  };
  type t = {. \\"customFields\\": t_customFields};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let customFields = {
        let value = value##customFields;
        let nullableColor = {
          let value = value##nullableColor;
          switch (Js.toOption(value)) {
          | Some(value) => Some(Color.parse(value))
          | None => None
          };
        }
        and futureTime = {
          let value = value##futureTime;
          switch (Js.toOption(value)) {
          | Some(value) => Some(DateTime.parse(value))
          | None => None
          };
        }
        and favoriteColor = {
          let value = value##favoriteColor;
          Color.parse(value);
        }
        and currentTime = {
          let value = value##currentTime;
          DateTime.parse(value);
        };
        {
          \\"currentTime\\": currentTime,
          \\"favoriteColor\\": favoriteColor,
          \\"futureTime\\": futureTime,
          \\"nullableColor\\": nullableColor,
        };
      };
      {\\"customFields\\": customFields};
    };
  let serialize: t => Raw.t =
    value => {
      let customFields = {
        let value = value##customFields;
        let nullableColor = {
          let value = value##nullableColor;
          switch (value) {
          | Some(value) => Js.Nullable.return(Color.serialize(value))
          | None => Js.Nullable.null
          };
        }
        and futureTime = {
          let value = value##futureTime;
          switch (value) {
          | Some(value) => Js.Nullable.return(DateTime.serialize(value))
          | None => Js.Nullable.null
          };
        }
        and favoriteColor = {
          let value = value##favoriteColor;
          Color.serialize(value);
        }
        and currentTime = {
          let value = value##currentTime;
          DateTime.serialize(value);
        };
        {
          \\"currentTime\\": currentTime,
          \\"favoriteColor\\": favoriteColor,
          \\"futureTime\\": futureTime,
          \\"nullableColor\\": nullableColor,
        };
      };
      {\\"customFields\\": customFields};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects defaultObjectValueOnScalar.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"defaultObjectValueOnScalar\\": string};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndefaultObjectValueOnScalar(filter: {some: {json: \\\\\\"value\\\\\\"}}, arg: {field: \\\\\\"otherValue\\\\\\"})  \\\\n}\\\\n\\";
  type t = {. \\"defaultObjectValueOnScalar\\": string};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let defaultObjectValueOnScalar = {
        let value = value##defaultObjectValueOnScalar;
        value;
      };
      {\\"defaultObjectValueOnScalar\\": defaultObjectValueOnScalar};
    };
  let serialize: t => Raw.t =
    value => {
      let defaultObjectValueOnScalar = {
        let value = value##defaultObjectValueOnScalar;
        value;
      };
      {\\"defaultObjectValueOnScalar\\": defaultObjectValueOnScalar};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects enumInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"enumInput\\": string};
    type t_variables = {. \\"arg\\": string};
  };
  let query = \\"query ($arg: SampleField!)  {\\\\nenumInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"enumInput\\": string};
  type t_variables = {. \\"arg\\": [ | \`FIRST | \`SECOND | \`THIRD]};
  let parse: Raw.t => t =
    value => {
      let enumInput = {
        let value = value##enumInput;
        value;
      };
      {\\"enumInput\\": enumInput};
    };
  let serialize: t => Raw.t =
    value => {
      let enumInput = {
        let value = value##enumInput;
        value;
      };
      {\\"enumInput\\": enumInput};
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"arg\\":
        (
          a =>
            switch (a) {
            | \`FIRST => \\"FIRST\\"
            | \`SECOND => \\"SECOND\\"
            | \`THIRD => \\"THIRD\\"
            }
        )(
          inp##arg,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({\\"arg\\": arg}: t_variables);
  module Z__INTERNAL = {
    type root = t;
    type nonrec _graphql_SampleField_47;
    /**\`\`\`
SampleField {
  FIRST
  SECOND
  THIRD
}
\`\`\`*/
    let _graphql_SampleField_47: _graphql_SampleField_47 = Obj.magic(0);
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects explicit_object_record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module RecordsQuery = {
  module Raw = {
    type t_lists = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
    type t = {lists: t_lists};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_lists = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  type t = {lists: t_lists};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        lists: {
          let value = (value: Raw.t).lists;
          (
            {
              nullableOfNullable: {
                let value = (value: Raw.t_lists).nullableOfNullable;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              },
              nullableOfNonNullable: {
                let value = (value: Raw.t_lists).nullableOfNonNullable;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value |> Js.Array.map(value => value))
                | None => None
                };
              },
              nonNullableOfNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNullable;
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   );
              },
              nonNullableOfNonNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNonNullable;
                value |> Js.Array.map(value => value);
              },
            }: t_lists
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let lists = {
          let value = (value: t).lists;
          (
            {
              let nonNullableOfNonNullable = {
                let value = (value: t_lists).nonNullableOfNonNullable;
                value |> Js.Array.map(value => value);
              }
              and nonNullableOfNullable = {
                let value = (value: t_lists).nonNullableOfNullable;
                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   );
              }
              and nullableOfNonNullable = {
                let value = (value: t_lists).nullableOfNonNullable;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(value |> Js.Array.map(value => value))
                | None => Js.Nullable.null
                };
              }
              and nullableOfNullable = {
                let value = (value: t_lists).nullableOfNullable;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map(value =>
                         switch (value) {
                         | Some(value) => Js.Nullable.return(value)
                         | None => Js.Nullable.null
                         }
                       ),
                  )
                | None => Js.Nullable.null
                };
              };
              {
                nullableOfNullable,
                nullableOfNonNullable,
                nonNullableOfNullable,
                nonNullableOfNonNullable,
              };
            }: Raw.t_lists
          );
        };
        {lists: lists};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module RecordsQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ObjectsQuery = {
  module Raw = {
    type t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
    type t = {. \\"lists\\": t_lists};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  type t = {. \\"lists\\": t_lists};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;
          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;
          value
          |> Js.Array.map(value =>
               switch (Js.toOption(value)) {
               | Some(value) => Some(value)
               | None => None
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value |> Js.Array.map(value => value))
          | None => None
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 ),
            )
          | None => None
          };
        };
        {
          \\"nullableOfNullable\\": nullableOfNullable,
          \\"nullableOfNonNullable\\": nullableOfNonNullable,
          \\"nonNullableOfNullable\\": nonNullableOfNullable,
          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {\\"lists\\": lists};
    };
  let serialize: t => Raw.t =
    value => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;
          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;
          value
          |> Js.Array.map(value =>
               switch (value) {
               | Some(value) => Js.Nullable.return(value)
               | None => Js.Nullable.null
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(value |> Js.Array.map(value => value))
          | None => Js.Nullable.null
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 ),
            )
          | None => Js.Nullable.null
          };
        };
        {
          \\"nullableOfNullable\\": nullableOfNullable,
          \\"nullableOfNonNullable\\": nullableOfNonNullable,
          \\"nonNullableOfNullable\\": nonNullableOfNullable,
          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {\\"lists\\": lists};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ObjectsQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects extensions.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module type GraphQLQuery = {
  module Raw: {
    type t;
    type t_variables;
  };
  type t;
  type t_variables;

  let query: string;
  let parse: Raw.t => t;
  let serialize: t => Raw.t;
};

module ExtendQuery = (M: GraphQLQuery) => {
  let use = () => ();
};
module Bla' = {
  module Raw = {
    type t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
    type t = {. \\"lists\\": t_lists};
    type t_variables = Js.Json.t;
  };
  let query = \\"query Bla  {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  type t = {. \\"lists\\": t_lists};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;
          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;
          value
          |> Js.Array.map(value =>
               switch (Js.toOption(value)) {
               | Some(value) => Some(value)
               | None => None
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value |> Js.Array.map(value => value))
          | None => None
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 ),
            )
          | None => None
          };
        };
        {
          \\"nullableOfNullable\\": nullableOfNullable,
          \\"nullableOfNonNullable\\": nullableOfNonNullable,
          \\"nonNullableOfNullable\\": nonNullableOfNullable,
          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {\\"lists\\": lists};
    };
  let serialize: t => Raw.t =
    value => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;
          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;
          value
          |> Js.Array.map(value =>
               switch (value) {
               | Some(value) => Js.Nullable.return(value)
               | None => Js.Nullable.null
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(value |> Js.Array.map(value => value))
          | None => Js.Nullable.null
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 ),
            )
          | None => Js.Nullable.null
          };
        };
        {
          \\"nullableOfNullable\\": nullableOfNullable,
          \\"nullableOfNonNullable\\": nullableOfNonNullable,
          \\"nonNullableOfNullable\\": nonNullableOfNullable,
          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {\\"lists\\": lists};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module Bla = {
  include Bla';
  include ExtendQuery(Bla');
};
"
`;

exports[`Objects fragmentDefinition.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Fragments = {
  module ListFragment = {
    let query = \\"fragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        .
        \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
        \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      };
      type nonrec t_Lists = t;
    };
    type t = {
      .
      \\"nullableOfNullable\\": option(array(option(string))),
      \\"nullableOfNonNullable\\": option(array(string)),
    };
    type nonrec t_Lists = t;
    let parse = (value: Raw.t) => {
      let nullableOfNonNullable = {
        let value = value##nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      }
      and nullableOfNullable = {
        let value = value##nullableOfNullable;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      };
      {
        \\"nullableOfNullable\\": nullableOfNullable,
        \\"nullableOfNonNullable\\": nullableOfNonNullable,
      };
    };
    let serialize: t => Raw.t =
      value => {
        let nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(value |> Js.Array.map(value => value))
          | None => Js.Nullable.null
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 ),
            )
          | None => Js.Nullable.null
          };
        };
        {
          \\"nullableOfNullable\\": nullableOfNullable,
          \\"nullableOfNonNullable\\": nullableOfNonNullable,
        };
      };
    let name = \\"ListFragment\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql;
      /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}
\`\`\`*/
      let graphql: graphql = Obj.magic(0);
      type nonrec graphql_module;
      /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module Fragments {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  module Another = {
    let query = \\"fragment Another on Lists   {\\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
    module Raw = {
      type t = {. \\"nullableOfNonNullable\\": Js.Nullable.t(array(string))};
      type nonrec t_Lists = t;
    };
    type t = {. \\"nullableOfNonNullable\\": option(array(string))};
    type nonrec t_Lists = t;
    let parse = (value: Raw.t) => {
      let nullableOfNonNullable = {
        let value = value##nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      };
      {\\"nullableOfNonNullable\\": nullableOfNonNullable};
    };
    let serialize: t => Raw.t =
      value => {
        let nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(value |> Js.Array.map(value => value))
          | None => Js.Nullable.null
          };
        };
        {\\"nullableOfNonNullable\\": nullableOfNonNullable};
      };
    let name = \\"Another\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql;
      /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}
\`\`\`*/
      let graphql: graphql = Obj.magic(0);
      type nonrec graphql_module;
      /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module Fragments {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
};
module MyQuery = {
  module Raw = {
    type t_l2;
    type t_l3;
    type t_l4;
    type t = {
      .
      \\"l1\\": Fragments.ListFragment.Raw.t,
      \\"l2\\": t_l2,
      \\"l3\\": t_l3,
      \\"l4\\": t_l4,
    };
    type t_variables = Js.Json.t;
  };
  let query =
    (
      (
        (
          (
            (
              (
                (
                  (
                    (
                      (
                        (
                          (
                            \\"query   {\\\\nl1: lists  {\\\\n...\\"
                            ++ Fragments.ListFragment.name
                          )
                          ++ \\"   \\\\n}\\\\n\\\\nl2: lists  {\\\\n...\\"
                        )
                        ++ Fragments.ListFragment.name
                      )
                      ++ \\"   \\\\n...\\"
                    )
                    ++ Fragments.ListFragment.name
                  )
                  ++ \\"   \\\\n}\\\\n\\\\nl3: lists  {\\\\nnullableOfNullable  \\\\n...\\"
                )
                ++ Fragments.ListFragment.name
              )
              ++ \\"   \\\\n...\\"
            )
            ++ Fragments.ListFragment.name
          )
          ++ \\"   \\\\n}\\\\n\\\\nl4: lists  {\\\\nnullableOfNullable  \\\\n...\\"
        )
        ++ Fragments.ListFragment.name
      )
      ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
    )
    ++ Fragments.ListFragment.query;
  type t_l2 = {
    .
    \\"frag1\\": Fragments.ListFragment.t_Lists,
    \\"frag2\\": Fragments.ListFragment.t_Lists,
  };
  type t_l3 = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"frag1\\": Fragments.ListFragment.t_Lists,
    \\"frag2\\": Fragments.ListFragment.t_Lists,
  };
  type t_l4 = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"listFragment\\": Fragments.ListFragment.t_Lists,
  };
  type t = {
    .
    \\"l1\\": Fragments.ListFragment.t,
    \\"l2\\": t_l2,
    \\"l3\\": t_l3,
    \\"l4\\": t_l4,
  };
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let l4 = {
        let value = value##l4;
        let listFragment = {
          let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
          Fragments.ListFragment.parse(value);
        }
        and nullableOfNullable = {
          let value =
            Obj.magic(
              Js.Dict.unsafeGet(Obj.magic(value), \\"nullableOfNullable\\"),
            );
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 ),
            )
          | None => None
          };
        };
        {
          \\"nullableOfNullable\\": nullableOfNullable,
          \\"listFragment\\": listFragment,
        };
      }
      and l3 = {
        let value = value##l3;
        let frag2 = {
          let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
          Fragments.ListFragment.parse(value);
        }
        and frag1 = {
          let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
          Fragments.ListFragment.parse(value);
        }
        and nullableOfNullable = {
          let value =
            Obj.magic(
              Js.Dict.unsafeGet(Obj.magic(value), \\"nullableOfNullable\\"),
            );
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 ),
            )
          | None => None
          };
        };
        {
          \\"nullableOfNullable\\": nullableOfNullable,
          \\"frag1\\": frag1,
          \\"frag2\\": frag2,
        };
      }
      and l2 = {
        let value = value##l2;
        let frag2 = {
          let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
          Fragments.ListFragment.parse(value);
        }
        and frag1 = {
          let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
          Fragments.ListFragment.parse(value);
        };
        {\\"frag1\\": frag1, \\"frag2\\": frag2};
      }
      and l1 = {
        let value = value##l1;
        Fragments.ListFragment.parse(value);
      };
      {\\"l1\\": l1, \\"l2\\": l2, \\"l3\\": l3, \\"l4\\": l4};
    };
  let serialize: t => Raw.t =
    value => {
      let l4 = {
        let value = value##l4;
        (
          Obj.magic(
            Js.Array.reduce(
              GraphQL_PPX.deepMerge,
              Obj.magic(
                {
                  let nullableOfNullable = {
                    let value = value##nullableOfNullable;
                    switch (value) {
                    | Some(value) =>
                      Js.Nullable.return(
                        value
                        |> Js.Array.map(value =>
                             switch (value) {
                             | Some(value) => Js.Nullable.return(value)
                             | None => Js.Nullable.null
                             }
                           ),
                      )
                    | None => Js.Nullable.null
                    };
                  };
                  {\\"nullableOfNullable\\": nullableOfNullable};
                },
              ): Js.Json.t,
              [|
                (
                  Obj.magic(
                    Fragments.ListFragment.serialize(value##listFragment),
                  ): Js.Json.t
                ),
              |],
            ),
          ): Raw.t_l4
        );
      }
      and l3 = {
        let value = value##l3;
        (
          Obj.magic(
            Js.Array.reduce(
              GraphQL_PPX.deepMerge,
              Obj.magic(
                {
                  let nullableOfNullable = {
                    let value = value##nullableOfNullable;
                    switch (value) {
                    | Some(value) =>
                      Js.Nullable.return(
                        value
                        |> Js.Array.map(value =>
                             switch (value) {
                             | Some(value) => Js.Nullable.return(value)
                             | None => Js.Nullable.null
                             }
                           ),
                      )
                    | None => Js.Nullable.null
                    };
                  };
                  {\\"nullableOfNullable\\": nullableOfNullable};
                },
              ): Js.Json.t,
              [|
                (
                  Obj.magic(Fragments.ListFragment.serialize(value##frag1)): Js.Json.t
                ),
                (
                  Obj.magic(Fragments.ListFragment.serialize(value##frag2)): Js.Json.t
                ),
              |],
            ),
          ): Raw.t_l3
        );
      }
      and l2 = {
        let value = value##l2;
        (
          Obj.magic(
            Js.Array.reduce(
              GraphQL_PPX.deepMerge,
              Obj.magic(Js.Dict.empty): Js.Json.t,
              [|
                (
                  Obj.magic(Fragments.ListFragment.serialize(value##frag1)): Js.Json.t
                ),
                (
                  Obj.magic(Fragments.ListFragment.serialize(value##frag2)): Js.Json.t
                ),
              |],
            ),
          ): Raw.t_l2
        );
      }
      and l1 = {
        let value = value##l1;
        Fragments.ListFragment.serialize(value);
      };
      {\\"l1\\": l1, \\"l2\\": l2, \\"l3\\": l3, \\"l4\\": l4};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery2 = {
  module Raw = {
    type t = {. \\"lists\\": Fragments.ListFragment.Raw.t};
    type t_variables = Js.Json.t;
  };
  let query =
    (
      (\\"query   {\\\\nlists  {\\\\n...\\" ++ Fragments.ListFragment.name)
      ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
    )
    ++ Fragments.ListFragment.query;
  type t = {. \\"lists\\": Fragments.ListFragment.t};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let lists = {
        let value = value##lists;
        Fragments.ListFragment.parse(value);
      };
      {\\"lists\\": lists};
    };
  let serialize: t => Raw.t =
    value => {
      let lists = {
        let value = value##lists;
        Fragments.ListFragment.serialize(value);
      };
      {\\"lists\\": lists};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery2 {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects interface.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
"
`;

exports[`Objects lists.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
    type t = {. \\"lists\\": t_lists};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  type t = {. \\"lists\\": t_lists};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;
          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;
          value
          |> Js.Array.map(value =>
               switch (Js.toOption(value)) {
               | Some(value) => Some(value)
               | None => None
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value |> Js.Array.map(value => value))
          | None => None
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 ),
            )
          | None => None
          };
        };
        {
          \\"nullableOfNullable\\": nullableOfNullable,
          \\"nullableOfNonNullable\\": nullableOfNonNullable,
          \\"nonNullableOfNullable\\": nonNullableOfNullable,
          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {\\"lists\\": lists};
    };
  let serialize: t => Raw.t =
    value => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;
          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;
          value
          |> Js.Array.map(value =>
               switch (value) {
               | Some(value) => Js.Nullable.return(value)
               | None => Js.Nullable.null
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(value |> Js.Array.map(value => value))
          | None => Js.Nullable.null
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 ),
            )
          | None => Js.Nullable.null
          };
        };
        {
          \\"nullableOfNullable\\": nullableOfNullable,
          \\"nullableOfNonNullable\\": nullableOfNonNullable,
          \\"nonNullableOfNullable\\": nonNullableOfNullable,
          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {\\"lists\\": lists};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects listsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"listsInput\\": string};
    type t_variables = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
  };
  let query = \\"query ($nullableOfNullable: [String], $nullableOfNonNullable: [String!], $nonNullableOfNullable: [String]!, $nonNullableOfNonNullable: [String!]!)  {\\\\nlistsInput(arg: {nullableOfNullable: $nullableOfNullable, nullableOfNonNullable: $nullableOfNonNullable, nonNullableOfNullable: $nonNullableOfNullable, nonNullableOfNonNullable: $nonNullableOfNonNullable})  \\\\n}\\\\n\\";
  type t = {. \\"listsInput\\": string};
  type t_variables = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  let parse: Raw.t => t =
    value => {
      let listsInput = {
        let value = value##listsInput;
        value;
      };
      {\\"listsInput\\": listsInput};
    };
  let serialize: t => Raw.t =
    value => {
      let listsInput = {
        let value = value##listsInput;
        value;
      };
      {\\"listsInput\\": listsInput};
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"nullableOfNullable\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableOfNullable,
        ),
      \\"nullableOfNonNullable\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return((a => Array.map(b => (a => a)(b), a))(b))
            }
        )(
          inp##nullableOfNonNullable,
        ),
      \\"nonNullableOfNullable\\":
        (
          a =>
            Array.map(
              b =>
                (
                  a =>
                    switch (a) {
                    | None => Js.Nullable.undefined
                    | Some(b) => Js.Nullable.return((a => a)(b))
                    }
                )(
                  b,
                ),
              a,
            )
        )(
          inp##nonNullableOfNullable,
        ),
      \\"nonNullableOfNonNullable\\":
        (a => Array.map(b => (a => a)(b), a))(
          inp##nonNullableOfNonNullable,
        ),
    };
  let makeVariables =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      ) =>
    serializeVariables(
      {
        \\"nullableOfNullable\\": nullableOfNullable,
        \\"nullableOfNonNullable\\": nullableOfNonNullable,
        \\"nonNullableOfNullable\\": nonNullableOfNullable,
        \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
      }: t_variables,
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects listsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"listsInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_ListsInput}
    and t_variables_ListsInput = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
  };
  let query = \\"query ($arg: ListsInput!)  {\\\\nlistsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"listsInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_ListsInput}
  and t_variables_ListsInput = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  let parse: Raw.t => t =
    value => {
      let listsInput = {
        let value = value##listsInput;
        value;
      };
      {\\"listsInput\\": listsInput};
    };
  let serialize: t => Raw.t =
    value => {
      let listsInput = {
        let value = value##listsInput;
        value;
      };
      {\\"listsInput\\": listsInput};
    };
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"arg\\": (a => serializeInputObjectListsInput(a))(inp##arg)}
  and serializeInputObjectListsInput:
    t_variables_ListsInput => Raw.t_variables_ListsInput =
    inp => {
      \\"nullableOfNullable\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableOfNullable,
        ),
      \\"nullableOfNonNullable\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return((a => Array.map(b => (a => a)(b), a))(b))
            }
        )(
          inp##nullableOfNonNullable,
        ),
      \\"nonNullableOfNullable\\":
        (
          a =>
            Array.map(
              b =>
                (
                  a =>
                    switch (a) {
                    | None => Js.Nullable.undefined
                    | Some(b) => Js.Nullable.return((a => a)(b))
                    }
                )(
                  b,
                ),
              a,
            )
        )(
          inp##nonNullableOfNullable,
        ),
      \\"nonNullableOfNonNullable\\":
        (a => Array.map(b => (a => a)(b), a))(
          inp##nonNullableOfNonNullable,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({\\"arg\\": arg}: t_variables)
  and makeInputObjectListsInput =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      )
      : t_variables_ListsInput => {
    \\"nullableOfNullable\\": nullableOfNullable,
    \\"nullableOfNonNullable\\": nullableOfNonNullable,
    \\"nonNullableOfNullable\\": nonNullableOfNullable,
    \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec _graphql_ListsInput_47;
    /**\`\`\`
ListsInput {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}
\`\`\`*/
    let _graphql_ListsInput_47: _graphql_ListsInput_47 = Obj.magic(0);
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects mutation.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_mutationWithError_value = {. \\"stringField\\": string};
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      .
      \\"field\\": t_mutationWithError_errors_field,
      \\"message\\": string,
    };
    type t_mutationWithError = {
      .
      \\"value\\": Js.Nullable.t(t_mutationWithError_value),
      \\"errors\\": Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {. \\"mutationWithError\\": t_mutationWithError};
    type t_variables = Js.Json.t;
  };
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nvalue  {\\\\nstringField  \\\\n}\\\\n\\\\nerrors  {\\\\nfield  \\\\nmessage  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_mutationWithError_value = {. \\"stringField\\": string};
  type t_mutationWithError_errors_field = [
    | \`FutureAddedValue(string)
    | \`FIRST
    | \`SECOND
    | \`THIRD
  ];
  type t_mutationWithError_errors = {
    .
    \\"field\\": t_mutationWithError_errors_field,
    \\"message\\": string,
  };
  type t_mutationWithError = {
    .
    \\"value\\": option(t_mutationWithError_value),
    \\"errors\\": option(array(t_mutationWithError_errors)),
  };
  type t = {. \\"mutationWithError\\": t_mutationWithError};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let mutationWithError = {
        let value = value##mutationWithError;
        let errors = {
          let value = value##errors;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   let message = {
                     let value = value##message;
                     value;
                   }
                   and field = {
                     let value = value##field;
                     switch (Obj.magic(value: string)) {
                     | \\"FIRST\\" => \`FIRST
                     | \\"SECOND\\" => \`SECOND
                     | \\"THIRD\\" => \`THIRD
                     | other => \`FutureAddedValue(other)
                     };
                   };
                   {\\"field\\": field, \\"message\\": message};
                 ),
            )
          | None => None
          };
        }
        and value = {
          let value = value##value;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {
                let stringField = {
                  let value = value##stringField;
                  value;
                };
                {\\"stringField\\": stringField};
              },
            )
          | None => None
          };
        };
        {\\"value\\": value, \\"errors\\": errors};
      };
      {\\"mutationWithError\\": mutationWithError};
    };
  let serialize: t => Raw.t =
    value => {
      let mutationWithError = {
        let value = value##mutationWithError;
        let errors = {
          let value = value##errors;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   let message = {
                     let value = value##message;
                     value;
                   }
                   and field = {
                     let value = value##field;
                     switch (value) {
                     | \`FIRST => \\"FIRST\\"
                     | \`SECOND => \\"SECOND\\"
                     | \`THIRD => \\"THIRD\\"
                     | \`FutureAddedValue(other) => other
                     };
                   };
                   {\\"field\\": field, \\"message\\": message};
                 ),
            )
          | None => Js.Nullable.null
          };
        }
        and value = {
          let value = value##value;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {
                let stringField = {
                  let value = value##stringField;
                  value;
                };
                {\\"stringField\\": stringField};
              },
            )
          | None => Js.Nullable.null
          };
        };
        {\\"value\\": value, \\"errors\\": errors};
      };
      {\\"mutationWithError\\": mutationWithError};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects mutationWithArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"optionalInputArgs\\": string};
    type t_variables = {. \\"required\\": string};
  };
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t = {. \\"optionalInputArgs\\": string};
  type t_variables = {. \\"required\\": string};
  let parse: Raw.t => t =
    value => {
      let optionalInputArgs = {
        let value = value##optionalInputArgs;
        value;
      };
      {\\"optionalInputArgs\\": optionalInputArgs};
    };
  let serialize: t => Raw.t =
    value => {
      let optionalInputArgs = {
        let value = value##optionalInputArgs;
        value;
      };
      {\\"optionalInputArgs\\": optionalInputArgs};
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"required\\": (a => a)(inp##required)};
  let makeVariables = (~required, ()) =>
    serializeVariables({\\"required\\": required}: t_variables);
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects mutationWithArgsAndNoRecords.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"optionalInputArgs\\": string};
    type t_variables = {. \\"required\\": string};
  };
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t = {. \\"optionalInputArgs\\": string};
  type t_variables = {. \\"required\\": string};
  let parse: Raw.t => t =
    value => {
      let optionalInputArgs = {
        let value = value##optionalInputArgs;
        value;
      };
      {\\"optionalInputArgs\\": optionalInputArgs};
    };
  let serialize: t => Raw.t =
    value => {
      let optionalInputArgs = {
        let value = value##optionalInputArgs;
        value;
      };
      {\\"optionalInputArgs\\": optionalInputArgs};
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"required\\": (a => a)(inp##required)};
  let makeVariables = (~required, ()) =>
    serializeVariables({\\"required\\": required}: t_variables);
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects nested.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type record = {
  f1: string,
  f2: string,
};
module MyQuery = {
  module Raw = {
    type t_first_inner_inner = {. \\"field\\": string};
    type t_first_inner = {. \\"inner\\": Js.Nullable.t(t_first_inner_inner)};
    type t_first = {. \\"inner\\": Js.Nullable.t(t_first_inner)};
    type t_second_inner_inner = {
      .
      \\"f1\\": string,
      \\"f2\\": string,
    };
    type t_second_inner = {. \\"inner\\": Js.Nullable.t(t_second_inner_inner)};
    type t_second = {. \\"inner\\": Js.Nullable.t(t_second_inner)};
    type t_let_inner_inner = {. \\"field\\": string};
    type t_let_inner = {. \\"inner\\": Js.Nullable.t(t_let_inner_inner)};
    type t_let = {. \\"inner\\": Js.Nullable.t(t_let_inner)};
    type t = {
      .
      \\"first\\": t_first,
      \\"second\\": t_second,
      \\"let_\\": t_let,
    };
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nsecond: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nf1: field  \\\\nf2: field  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nlet: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_first_inner_inner = {. \\"field\\": string};
  type t_first_inner = {. \\"inner\\": option(t_first_inner_inner)};
  type t_first = {. \\"inner\\": option(t_first_inner)};
  type t_second_inner_inner = {
    f1: string,
    f2: string,
  };
  type t_second_inner = {. \\"inner\\": option(t_second_inner_inner)};
  type t_second = {. \\"inner\\": option(t_second_inner)};
  type t_let_inner_inner = {. \\"field\\": string};
  type t_let_inner = {. \\"inner\\": option(t_let_inner_inner)};
  type t_let = {. \\"inner\\": option(t_let_inner)};
  type t = {
    .
    \\"first\\": t_first,
    \\"second\\": t_second,
    \\"let_\\": t_let,
  };
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let let_ = {
        let value = value##let_;
        let inner = {
          let value = value##inner;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {
                let inner = {
                  let value = value##inner;
                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some(
                      {
                        let field = {
                          let value = value##field;
                          value;
                        };
                        {\\"field\\": field};
                      },
                    )
                  | None => None
                  };
                };
                {\\"inner\\": inner};
              },
            )
          | None => None
          };
        };
        {\\"inner\\": inner};
      }
      and second = {
        let value = value##second;
        let inner = {
          let value = value##inner;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {
                let inner = {
                  let value = value##inner;
                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some(
                      {
                        let f2 = {
                          let value = value##f2;
                          value;
                        }
                        and f1 = {
                          let value = value##f1;
                          value;
                        };
                        {f1, f2};
                      }: t_second_inner_inner,
                    )
                  | None => None
                  };
                };
                {\\"inner\\": inner};
              },
            )
          | None => None
          };
        };
        {\\"inner\\": inner};
      }
      and first = {
        let value = value##first;
        let inner = {
          let value = value##inner;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {
                let inner = {
                  let value = value##inner;
                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some(
                      {
                        let field = {
                          let value = value##field;
                          value;
                        };
                        {\\"field\\": field};
                      },
                    )
                  | None => None
                  };
                };
                {\\"inner\\": inner};
              },
            )
          | None => None
          };
        };
        {\\"inner\\": inner};
      };
      {\\"first\\": first, \\"second\\": second, \\"let_\\": let_};
    };
  let serialize: t => Raw.t =
    value => {
      let let_ = {
        let value = value##let_;
        let inner = {
          let value = value##inner;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {
                let inner = {
                  let value = value##inner;
                  switch (value) {
                  | Some(value) =>
                    Js.Nullable.return(
                      {
                        let field = {
                          let value = value##field;
                          value;
                        };
                        {\\"field\\": field};
                      },
                    )
                  | None => Js.Nullable.null
                  };
                };
                {\\"inner\\": inner};
              },
            )
          | None => Js.Nullable.null
          };
        };
        {\\"inner\\": inner};
      }
      and second = {
        let value = value##second;
        let inner = {
          let value = value##inner;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {
                let inner = {
                  let value = value##inner;
                  switch (value) {
                  | Some(value) =>
                    Js.Nullable.return(
                      {
                        let f2 = {
                          let value = (value: t_second_inner_inner).f2;
                          value;
                        }
                        and f1 = {
                          let value = (value: t_second_inner_inner).f1;
                          value;
                        };
                        {\\"f1\\": f1, \\"f2\\": f2};
                      },
                    )
                  | None => Js.Nullable.null
                  };
                };
                {\\"inner\\": inner};
              },
            )
          | None => Js.Nullable.null
          };
        };
        {\\"inner\\": inner};
      }
      and first = {
        let value = value##first;
        let inner = {
          let value = value##inner;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {
                let inner = {
                  let value = value##inner;
                  switch (value) {
                  | Some(value) =>
                    Js.Nullable.return(
                      {
                        let field = {
                          let value = value##field;
                          value;
                        };
                        {\\"field\\": field};
                      },
                    )
                  | None => Js.Nullable.null
                  };
                };
                {\\"inner\\": inner};
              },
            )
          | None => Js.Nullable.null
          };
        };
        {\\"inner\\": inner};
      };
      {\\"first\\": first, \\"second\\": second, \\"let_\\": let_};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects nonrecursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"nonrecursiveInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      .
      \\"nonNullableField\\": string,
      \\"nullableArray\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"field\\": Js.Nullable.t(string),
      \\"enum\\": Js.Nullable.t(string),
      \\"embeddedInput\\":
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
      \\"custom\\": Js.Nullable.t(Js.Json.t),
    }
    and t_variables_EmbeddedInput = {. \\"field\\": Js.Nullable.t(string)};
  };
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"nonrecursiveInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    .
    \\"nonNullableField\\": string,
    \\"nullableArray\\": option(array(option(string))),
    \\"field\\": option(string),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
    \\"embeddedInput\\": option(array(option(t_variables_EmbeddedInput))),
    \\"custom\\": option(Js.Json.t),
  }
  and t_variables_EmbeddedInput = {. \\"field\\": option(string)};
  let parse: Raw.t => t =
    value => {
      let nonrecursiveInput = {
        let value = value##nonrecursiveInput;
        value;
      };
      {\\"nonrecursiveInput\\": nonrecursiveInput};
    };
  let serialize: t => Raw.t =
    value => {
      let nonrecursiveInput = {
        let value = value##nonrecursiveInput;
        value;
      };
      {\\"nonrecursiveInput\\": nonrecursiveInput};
    };
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"arg\\": (a => serializeInputObjectNonrecursiveInput(a))(inp##arg),
    }
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {
      \\"nonNullableField\\": (a => a)(inp##nonNullableField),
      \\"nullableArray\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableArray,
        ),
      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
      \\"enum\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          inp##enum,
        ),
      \\"embeddedInput\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##embeddedInput,
        ),
      \\"custom\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##custom,
        ),
    }
  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {
      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({\\"arg\\": arg}: t_variables)
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        ~custom=?,
        (),
      )
      : t_variables_NonrecursiveInput => {
    \\"nonNullableField\\": nonNullableField,
    \\"nullableArray\\": nullableArray,
    \\"field\\": field,
    \\"enum\\": enum,
    \\"embeddedInput\\": embeddedInput,
    \\"custom\\": custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {
    \\"field\\": field,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec _graphql_NonrecursiveInput_49;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_49: _graphql_NonrecursiveInput_49 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery2 = {
  module Raw = {
    type t = {
      .
      \\"scalarsInput\\": string,
      \\"more\\": string,
    };
    type t_variables = {
      .
      \\"arg\\": t_variables_NonrecursiveInput,
      \\"arg2\\": t_variables_NonrecursiveInput,
    }
    and t_variables_NonrecursiveInput = {
      .
      \\"nonNullableField\\": string,
      \\"nullableArray\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"field\\": Js.Nullable.t(string),
      \\"enum\\": Js.Nullable.t(string),
      \\"embeddedInput\\":
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
      \\"custom\\": Js.Nullable.t(Js.Json.t),
    }
    and t_variables_EmbeddedInput = {. \\"field\\": Js.Nullable.t(string)};
  };
  let query = \\"query ($arg: NonrecursiveInput!, $arg2: NonrecursiveInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\nmore: scalarsInput(arg: $arg2)  \\\\n}\\\\n\\";
  type t = {
    .
    \\"scalarsInput\\": string,
    \\"more\\": string,
  };
  type t_variables = {
    .
    \\"arg\\": t_variables_NonrecursiveInput,
    \\"arg2\\": t_variables_NonrecursiveInput,
  }
  and t_variables_NonrecursiveInput = {
    .
    \\"nonNullableField\\": string,
    \\"nullableArray\\": option(array(option(string))),
    \\"field\\": option(string),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
    \\"embeddedInput\\": option(array(option(t_variables_EmbeddedInput))),
    \\"custom\\": option(Js.Json.t),
  }
  and t_variables_EmbeddedInput = {. \\"field\\": option(string)};
  let parse: Raw.t => t =
    value => {
      let more = {
        let value = value##more;
        value;
      }
      and scalarsInput = {
        let value = value##scalarsInput;
        value;
      };
      {\\"scalarsInput\\": scalarsInput, \\"more\\": more};
    };
  let serialize: t => Raw.t =
    value => {
      let more = {
        let value = value##more;
        value;
      }
      and scalarsInput = {
        let value = value##scalarsInput;
        value;
      };
      {\\"scalarsInput\\": scalarsInput, \\"more\\": more};
    };
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"arg\\": (a => serializeInputObjectNonrecursiveInput(a))(inp##arg),
      \\"arg2\\": (a => serializeInputObjectNonrecursiveInput(a))(inp##arg2),
    }
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {
      \\"nonNullableField\\": (a => a)(inp##nonNullableField),
      \\"nullableArray\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableArray,
        ),
      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
      \\"enum\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          inp##enum,
        ),
      \\"embeddedInput\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##embeddedInput,
        ),
      \\"custom\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##custom,
        ),
    }
  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {
      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
    };
  let makeVariables = (~arg, ~arg2, ()) =>
    serializeVariables({\\"arg\\": arg, \\"arg2\\": arg2}: t_variables)
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        ~custom=?,
        (),
      )
      : t_variables_NonrecursiveInput => {
    \\"nonNullableField\\": nonNullableField,
    \\"nullableArray\\": nullableArray,
    \\"field\\": field,
    \\"enum\\": enum,
    \\"embeddedInput\\": embeddedInput,
    \\"custom\\": custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {
    \\"field\\": field,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec _graphql_NonrecursiveInput_169;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_169: _graphql_NonrecursiveInput_169 =
      Obj.magic(0);
    type nonrec _graphql_NonrecursiveInput_196;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_196: _graphql_NonrecursiveInput_196 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery2 {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects omitFutureValueEnum.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Normal = {
  module Raw = {
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      .
      \\"message\\": string,
      \\"field\\": t_mutationWithError_errors_field,
    };
    type t_mutationWithError = {
      .
      \\"errors\\": Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {. \\"mutationWithError\\": t_mutationWithError};
    type t_variables = Js.Json.t;
  };
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_mutationWithError_errors_field = [
    | \`FutureAddedValue(string)
    | \`FIRST
    | \`SECOND
    | \`THIRD
  ];
  type t_mutationWithError_errors = {
    .
    \\"message\\": string,
    \\"field\\": t_mutationWithError_errors_field,
  };
  type t_mutationWithError = {
    .
    \\"errors\\": option(array(t_mutationWithError_errors)),
  };
  type t = {. \\"mutationWithError\\": t_mutationWithError};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let mutationWithError = {
        let value = value##mutationWithError;
        let errors = {
          let value = value##errors;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   let field = {
                     let value = value##field;
                     switch (Obj.magic(value: string)) {
                     | \\"FIRST\\" => \`FIRST
                     | \\"SECOND\\" => \`SECOND
                     | \\"THIRD\\" => \`THIRD
                     | other => \`FutureAddedValue(other)
                     };
                   }
                   and message = {
                     let value = value##message;
                     value;
                   };
                   {\\"message\\": message, \\"field\\": field};
                 ),
            )
          | None => None
          };
        };
        {\\"errors\\": errors};
      };
      {\\"mutationWithError\\": mutationWithError};
    };
  let serialize: t => Raw.t =
    value => {
      let mutationWithError = {
        let value = value##mutationWithError;
        let errors = {
          let value = value##errors;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   let field = {
                     let value = value##field;
                     switch (value) {
                     | \`FIRST => \\"FIRST\\"
                     | \`SECOND => \\"SECOND\\"
                     | \`THIRD => \\"THIRD\\"
                     | \`FutureAddedValue(other) => other
                     };
                   }
                   and message = {
                     let value = value##message;
                     value;
                   };
                   {\\"message\\": message, \\"field\\": field};
                 ),
            )
          | None => Js.Nullable.null
          };
        };
        {\\"errors\\": errors};
      };
      {\\"mutationWithError\\": mutationWithError};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module Normal {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByConfig = {
  module Raw = {
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      .
      \\"message\\": string,
      \\"field\\": t_mutationWithError_errors_field,
    };
    type t_mutationWithError = {
      .
      \\"errors\\": Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {. \\"mutationWithError\\": t_mutationWithError};
    type t_variables = Js.Json.t;
  };
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_mutationWithError_errors_field = [ | \`FIRST | \`SECOND | \`THIRD];
  type t_mutationWithError_errors = {
    .
    \\"message\\": string,
    \\"field\\": t_mutationWithError_errors_field,
  };
  type t_mutationWithError = {
    .
    \\"errors\\": option(array(t_mutationWithError_errors)),
  };
  type t = {. \\"mutationWithError\\": t_mutationWithError};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let mutationWithError = {
        let value = value##mutationWithError;
        let errors = {
          let value = value##errors;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   let field = {
                     let value = value##field;
                     switch (Obj.magic(value: string)) {
                     | \\"FIRST\\" => \`FIRST
                     | \\"SECOND\\" => \`SECOND
                     | \\"THIRD\\" => \`THIRD
                     | _ => raise(Not_found)
                     };
                   }
                   and message = {
                     let value = value##message;
                     value;
                   };
                   {\\"message\\": message, \\"field\\": field};
                 ),
            )
          | None => None
          };
        };
        {\\"errors\\": errors};
      };
      {\\"mutationWithError\\": mutationWithError};
    };
  let serialize: t => Raw.t =
    value => {
      let mutationWithError = {
        let value = value##mutationWithError;
        let errors = {
          let value = value##errors;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   let field = {
                     let value = value##field;
                     switch (value) {
                     | \`FIRST => \\"FIRST\\"
                     | \`SECOND => \\"SECOND\\"
                     | \`THIRD => \\"THIRD\\"
                     };
                   }
                   and message = {
                     let value = value##message;
                     value;
                   };
                   {\\"message\\": message, \\"field\\": field};
                 ),
            )
          | None => Js.Nullable.null
          };
        };
        {\\"errors\\": errors};
      };
      {\\"mutationWithError\\": mutationWithError};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByConfig {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByDirective = {
  module Raw = {
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      .
      \\"message\\": string,
      \\"field\\": t_mutationWithError_errors_field,
    };
    type t_mutationWithError = {
      .
      \\"errors\\": Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {. \\"mutationWithError\\": t_mutationWithError};
    type t_variables = Js.Json.t;
  };
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield @ppxOmitFutureValue \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_mutationWithError_errors_field = [ | \`FIRST | \`SECOND | \`THIRD];
  type t_mutationWithError_errors = {
    .
    \\"message\\": string,
    \\"field\\": t_mutationWithError_errors_field,
  };
  type t_mutationWithError = {
    .
    \\"errors\\": option(array(t_mutationWithError_errors)),
  };
  type t = {. \\"mutationWithError\\": t_mutationWithError};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let mutationWithError = {
        let value = value##mutationWithError;
        let errors = {
          let value = value##errors;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   let field = {
                     let value = value##field;
                     switch (Obj.magic(value: string)) {
                     | \\"FIRST\\" => \`FIRST
                     | \\"SECOND\\" => \`SECOND
                     | \\"THIRD\\" => \`THIRD
                     | _ => raise(Not_found)
                     };
                   }
                   and message = {
                     let value = value##message;
                     value;
                   };
                   {\\"message\\": message, \\"field\\": field};
                 ),
            )
          | None => None
          };
        };
        {\\"errors\\": errors};
      };
      {\\"mutationWithError\\": mutationWithError};
    };
  let serialize: t => Raw.t =
    value => {
      let mutationWithError = {
        let value = value##mutationWithError;
        let errors = {
          let value = value##errors;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   let field = {
                     let value = value##field;
                     switch (value) {
                     | \`FIRST => \\"FIRST\\"
                     | \`SECOND => \\"SECOND\\"
                     | \`THIRD => \\"THIRD\\"
                     };
                   }
                   and message = {
                     let value = value##message;
                     value;
                   };
                   {\\"message\\": message, \\"field\\": field};
                 ),
            )
          | None => Js.Nullable.null
          };
        };
        {\\"errors\\": errors};
      };
      {\\"mutationWithError\\": mutationWithError};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByDirective {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects omitFutureValueUnion.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Normal = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman_Human = {. \\"name\\": string};
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {\\"name\\": name, \\"barkVolume\\": barkVolume};
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                let name = {
                  let value = value##name;
                  value;
                };
                {\\"name\\": name};
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
  let serialize: t => Raw.t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {\\"__typename\\": \\"Dog\\", \\"name\\": name, \\"barkVolume\\": barkVolume};
              },
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = value##name;
                  value;
                };
                {\\"__typename\\": \\"Human\\", \\"name\\": name};
              },
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module Normal {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByConfig = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman_Human = {. \\"name\\": string};
  type t_dogOrHuman = [
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {\\"name\\": name, \\"barkVolume\\": barkVolume};
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                let name = {
                  let value = value##name;
                  value;
                };
                {\\"name\\": name};
              },
            )
          | _ => raise(Not_found)
          }: t_dogOrHuman
        );
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
  let serialize: t => Raw.t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {\\"__typename\\": \\"Dog\\", \\"name\\": name, \\"barkVolume\\": barkVolume};
              },
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = value##name;
                  value;
                };
                {\\"__typename\\": \\"Human\\", \\"name\\": name};
              },
            ): Raw.t_dogOrHuman
          )
        };
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByConfig {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByDirective = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndogOrHuman @ppxOmitFutureValue {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman_Human = {. \\"name\\": string};
  type t_dogOrHuman = [
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {\\"name\\": name, \\"barkVolume\\": barkVolume};
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                let name = {
                  let value = value##name;
                  value;
                };
                {\\"name\\": name};
              },
            )
          | _ => raise(Not_found)
          }: t_dogOrHuman
        );
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
  let serialize: t => Raw.t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {\\"__typename\\": \\"Dog\\", \\"name\\": name, \\"barkVolume\\": barkVolume};
              },
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = value##name;
                  value;
                };
                {\\"__typename\\": \\"Human\\", \\"name\\": name};
              },
            ): Raw.t_dogOrHuman
          )
        };
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByDirective {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects pokedexApolloMode.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_pokemon = {
      .
      \\"id\\": string,
      \\"name\\": Js.Nullable.t(string),
    };
    type t = {. \\"pokemon\\": Js.Nullable.t(t_pokemon)};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\npokemon(name: \\\\\\"Pikachu\\\\\\")  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_pokemon = {
    .
    \\"id\\": string,
    \\"name\\": option(string),
  };
  type t = {. \\"pokemon\\": option(t_pokemon)};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let pokemon = {
        let value = value##pokemon;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            {
              let name = {
                let value = value##name;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and id = {
                let value = value##id;
                value;
              };
              {\\"id\\": id, \\"name\\": name};
            },
          )
        | None => None
        };
      };
      {\\"pokemon\\": pokemon};
    };
  let serialize: t => Raw.t =
    value => {
      let pokemon = {
        let value = value##pokemon;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            {
              let name = {
                let value = value##name;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and id = {
                let value = value##id;
                value;
              };
              {\\"id\\": id, \\"name\\": name};
            },
          )
        | None => Js.Nullable.null
        };
      };
      {\\"pokemon\\": pokemon};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects pokedexScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_pokemon = {
      .
      \\"id\\": string,
      \\"name\\": Js.Nullable.t(string),
    };
    type t = {. \\"pokemon\\": Js.Nullable.t(t_pokemon)};
    type t_variables = {
      .
      \\"id\\": Js.Nullable.t(string),
      \\"name\\": Js.Nullable.t(string),
    };
  };
  let query = \\"query pokemon($id: String, $name: String)  {\\\\npokemon(name: $name, id: $id)  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_pokemon = {
    .
    \\"id\\": string,
    \\"name\\": option(string),
  };
  type t = {. \\"pokemon\\": option(t_pokemon)};
  type t_variables = {
    .
    \\"id\\": option(string),
    \\"name\\": option(string),
  };
  let parse: Raw.t => t =
    value => {
      let pokemon = {
        let value = value##pokemon;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            {
              let name = {
                let value = value##name;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and id = {
                let value = value##id;
                value;
              };
              {\\"id\\": id, \\"name\\": name};
            },
          )
        | None => None
        };
      };
      {\\"pokemon\\": pokemon};
    };
  let serialize: t => Raw.t =
    value => {
      let pokemon = {
        let value = value##pokemon;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            {
              let name = {
                let value = value##name;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and id = {
                let value = value##id;
                value;
              };
              {\\"id\\": id, \\"name\\": name};
            },
          )
        | None => Js.Nullable.null
        };
      };
      {\\"pokemon\\": pokemon};
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"id\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##id,
        ),
      \\"name\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##name,
        ),
    };
  let makeVariables = (~id=?, ~name=?, ()) =>
    serializeVariables({\\"id\\": id, \\"name\\": name}: t_variables);
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type scalars = {
  string,
  int,
};

type dog = {
  name: string,
  barkVolume: float,
};

type oneFieldQuery = {nullableString: option(string)};
module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      .
      \\"string\\": string,
      \\"int\\": int,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"variousScalars\\": scalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        (
          {
            let int = {
              let value = value##int;
              value;
            }
            and string = {
              let value = value##string;
              value;
            };
            {string, int};
          }: scalars
        );
      };
      {\\"variousScalars\\": variousScalars};
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let int = {
          let value = (value: scalars).int;
          value;
        }
        and string = {
          let value = (value: scalars).string;
          value;
        };
        {\\"string\\": string, \\"int\\": int};
      };
      {\\"variousScalars\\": variousScalars};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module OneFieldQuery = {
  module Raw = {
    type t_variousScalars = {. \\"nullableString\\": Js.Nullable.t(string)};
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {nullableString: option(string)};
  type t = {. \\"variousScalars\\": t_variousScalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        (
          {
            let nullableString = {
              let value = value##nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            };
            {nullableString: nullableString};
          }: t_variousScalars
        );
      };
      {\\"variousScalars\\": variousScalars};
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let nullableString = {
          let value = (value: t_variousScalars).nullableString;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {\\"nullableString\\": nullableString};
      };
      {\\"variousScalars\\": variousScalars};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module OneFieldQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ExternalFragmentQuery = {
  module Fragment = {
    let query = \\"fragment Fragment on VariousScalars   {\\\\nstring  \\\\nint  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        .
        \\"string\\": string,
        \\"int\\": int,
      };
      type nonrec t_VariousScalars = t;
    };
    type t = {
      string,
      int,
    };
    type nonrec t_VariousScalars = t;
    let parse = (value: Raw.t): t => {
      let int = {
        let value = value##int;
        value;
      }
      and string = {
        let value = value##string;
        value;
      };
      {string, int};
    };
    let serialize: t => Raw.t =
      value => {
        let int = {
          let value = (value: t).int;
          value;
        }
        and string = {
          let value = (value: t).string;
          value;
        };
        {\\"string\\": string, \\"int\\": int};
      };
    let name = \\"Fragment\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql;
      /**\`\`\`
VariousScalars {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}
\`\`\`*/
      let graphql: graphql = Obj.magic(0);
      type nonrec graphql_module;
      /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ExternalFragmentQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  module Untitled1 = {
    module Raw = {
      type t = {. \\"variousScalars\\": Fragment.Raw.t};
      type t_variables = Js.Json.t;
    };
    let query =
      (
        (\\"query   {\\\\nvariousScalars  {\\\\n...\\" ++ Fragment.name)
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ Fragment.query;
    type t = {. \\"variousScalars\\": Fragment.t};
    type t_variables = Js.Json.t;
    let parse: Raw.t => t =
      value => {
        let variousScalars = {
          let value = value##variousScalars;
          Fragment.parse(value);
        };
        {\\"variousScalars\\": variousScalars};
      };
    let serialize: t => Raw.t =
      value => {
        let variousScalars = {
          let value = value##variousScalars;
          Fragment.serialize(value);
        };
        {\\"variousScalars\\": variousScalars};
      };
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql_module;
      /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ExternalFragmentQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
};
module InlineFragmentQuery = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                (
                  {
                    let barkVolume = {
                      let value = value##barkVolume;
                      value;
                    }
                    and name = {
                      let value = value##name;
                      value;
                    };
                    {name, barkVolume};
                  }: t_dogOrHuman_Dog
                );
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
  let serialize: t => Raw.t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = (value: t_dogOrHuman_Dog).barkVolume;
                  value;
                }
                and name = {
                  let value = (value: t_dogOrHuman_Dog).name;
                  value;
                };
                {\\"__typename\\": \\"Dog\\", \\"name\\": name, \\"barkVolume\\": barkVolume};
              },
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module InlineFragmentQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module UnionExternalFragmentQuery = {
  module DogFragment = {
    let query = \\"fragment DogFragment on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        .
        \\"name\\": string,
        \\"barkVolume\\": float,
      };
      type nonrec t_Dog = t;
    };
    type t = {
      name: string,
      barkVolume: float,
    };
    type nonrec t_Dog = t;
    let parse = (value: Raw.t): t => {
      let barkVolume = {
        let value = value##barkVolume;
        value;
      }
      and name = {
        let value = value##name;
        value;
      };
      {name, barkVolume};
    };
    let serialize: t => Raw.t =
      value => {
        let barkVolume = {
          let value = (value: t).barkVolume;
          value;
        }
        and name = {
          let value = (value: t).name;
          value;
        };
        {\\"name\\": name, \\"barkVolume\\": barkVolume};
      };
    let name = \\"DogFragment\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql;
      /**\`\`\`
Dog {
  name: String!
  barkVolume: Float!
}
\`\`\`*/
      let graphql: graphql = Obj.magic(0);
      type nonrec graphql_module;
      /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module UnionExternalFragmentQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  module Untitled1 = {
    module Raw = {
      type t_dogOrHuman;
      type t = {. \\"dogOrHuman\\": t_dogOrHuman};
      type t_variables = Js.Json.t;
    };
    let query =
      (
        (
          \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n...\\"
          ++ DogFragment.name
        )
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ DogFragment.query;
    type t_dogOrHuman = [
      | \`FutureAddedValue(Js.Json.t)
      | \`Dog(DogFragment.t)
    ];
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = Js.Json.t;
    let parse: Raw.t => t =
      value => {
        let dogOrHuman = {
          let value = value##dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: DogFragment.Raw.t = Obj.magic(value);
                  DogFragment.parse(value);
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        };
        {\\"dogOrHuman\\": dogOrHuman};
      };
    let serialize: t => Raw.t =
      value => {
        let dogOrHuman = {
          let value = value##dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(DogFragment.serialize(value)): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        };
        {\\"dogOrHuman\\": dogOrHuman};
      };
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql_module;
      /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module UnionExternalFragmentQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
};
"
`;

exports[`Objects recursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"recursiveInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_RecursiveInput}
    and t_variables_RecursiveInput = {
      .
      \\"otherField\\": Js.Nullable.t(string),
      \\"inner\\": Js.Nullable.t(t_variables_RecursiveInput),
      \\"enum\\": Js.Nullable.t(string),
    };
  };
  let query = \\"query ($arg: RecursiveInput!)  {\\\\nrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"recursiveInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_RecursiveInput}
  and t_variables_RecursiveInput = {
    .
    \\"otherField\\": option(string),
    \\"inner\\": option(t_variables_RecursiveInput),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  let parse: Raw.t => t =
    value => {
      let recursiveInput = {
        let value = value##recursiveInput;
        value;
      };
      {\\"recursiveInput\\": recursiveInput};
    };
  let serialize: t => Raw.t =
    value => {
      let recursiveInput = {
        let value = value##recursiveInput;
        value;
      };
      {\\"recursiveInput\\": recursiveInput};
    };
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"arg\\": (a => serializeInputObjectRecursiveInput(a))(inp##arg)}
  and serializeInputObjectRecursiveInput:
    t_variables_RecursiveInput => Raw.t_variables_RecursiveInput =
    inp => {
      \\"otherField\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##otherField,
        ),
      \\"inner\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (a => serializeInputObjectRecursiveInput(a))(b),
              )
            }
        )(
          inp##inner,
        ),
      \\"enum\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          inp##enum,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({\\"arg\\": arg}: t_variables)
  and makeInputObjectRecursiveInput =
      (~otherField=?, ~inner=?, ~enum=?, ()): t_variables_RecursiveInput => {
    \\"otherField\\": otherField,
    \\"inner\\": inner,
    \\"enum\\": enum,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec _graphql_RecursiveInput_47;
    /**\`\`\`
RecursiveInput {
  otherField: String
  inner: RecursiveInput
  enum: SampleField
}
\`\`\`*/
    let _graphql_RecursiveInput_47: _graphql_RecursiveInput_47 = Obj.magic(0);
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects scalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {
          \\"nullableString\\": nullableString,
          \\"string\\": string,
          \\"nullableInt\\": nullableInt,
          \\"int\\": int,
          \\"nullableFloat\\": nullableFloat,
          \\"float\\": float,
          \\"nullableBoolean\\": nullableBoolean,
          \\"boolean\\": boolean,
          \\"nullableID\\": nullableID,
          \\"id\\": id,
        };
      };
      {\\"variousScalars\\": variousScalars};
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {
          \\"nullableString\\": nullableString,
          \\"string\\": string,
          \\"nullableInt\\": nullableInt,
          \\"int\\": int,
          \\"nullableFloat\\": nullableFloat,
          \\"float\\": float,
          \\"nullableBoolean\\": nullableBoolean,
          \\"boolean\\": boolean,
          \\"nullableID\\": nullableID,
          \\"id\\": id,
        };
      };
      {\\"variousScalars\\": variousScalars};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects scalarsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"scalarsInput\\": string};
    type t_variables = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  let query = \\"query ($nullableString: String, $string: String!, $nullableInt: Int, $int: Int!, $nullableFloat: Float, $float: Float!, $nullableBoolean: Boolean, $boolean: Boolean!, $nullableID: ID, $id: ID!)  {\\\\nscalarsInput(arg: {nullableString: $nullableString, string: $string, nullableInt: $nullableInt, int: $int, nullableFloat: $nullableFloat, float: $float, nullableBoolean: $nullableBoolean, boolean: $boolean, nullableID: $nullableID, id: $id})  \\\\n}\\\\n\\";
  type t = {. \\"scalarsInput\\": string};
  type t_variables = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {
      let scalarsInput = {
        let value = value##scalarsInput;
        value;
      };
      {\\"scalarsInput\\": scalarsInput};
    };
  let serialize: t => Raw.t =
    value => {
      let scalarsInput = {
        let value = value##scalarsInput;
        value;
      };
      {\\"scalarsInput\\": scalarsInput};
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"nullableString\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableString,
        ),
      \\"string\\": (a => a)(inp##string),
      \\"nullableInt\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableInt,
        ),
      \\"int\\": (a => a)(inp##int),
      \\"nullableFloat\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableFloat,
        ),
      \\"float\\": (a => a)(inp##float),
      \\"nullableBoolean\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableBoolean,
        ),
      \\"boolean\\": (a => a)(inp##boolean),
      \\"nullableID\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableID,
        ),
      \\"id\\": (a => a)(inp##id),
    };
  let makeVariables =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      ) =>
    serializeVariables(
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      }: t_variables,
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects scalarsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"scalarsInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_VariousScalarsInput}
    and t_variables_VariousScalarsInput = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  let query = \\"query ($arg: VariousScalarsInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"scalarsInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_VariousScalarsInput}
  and t_variables_VariousScalarsInput = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {
      let scalarsInput = {
        let value = value##scalarsInput;
        value;
      };
      {\\"scalarsInput\\": scalarsInput};
    };
  let serialize: t => Raw.t =
    value => {
      let scalarsInput = {
        let value = value##scalarsInput;
        value;
      };
      {\\"scalarsInput\\": scalarsInput};
    };
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"arg\\": (a => serializeInputObjectVariousScalarsInput(a))(inp##arg),
    }
  and serializeInputObjectVariousScalarsInput:
    t_variables_VariousScalarsInput => Raw.t_variables_VariousScalarsInput =
    inp => {
      \\"nullableString\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableString,
        ),
      \\"string\\": (a => a)(inp##string),
      \\"nullableInt\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableInt,
        ),
      \\"int\\": (a => a)(inp##int),
      \\"nullableFloat\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableFloat,
        ),
      \\"float\\": (a => a)(inp##float),
      \\"nullableBoolean\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableBoolean,
        ),
      \\"boolean\\": (a => a)(inp##boolean),
      \\"nullableID\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableID,
        ),
      \\"id\\": (a => a)(inp##id),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({\\"arg\\": arg}: t_variables)
  and makeInputObjectVariousScalarsInput =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      )
      : t_variables_VariousScalarsInput => {
    \\"nullableString\\": nullableString,
    \\"string\\": string,
    \\"nullableInt\\": nullableInt,
    \\"int\\": int,
    \\"nullableFloat\\": nullableFloat,
    \\"float\\": float,
    \\"nullableBoolean\\": nullableBoolean,
    \\"boolean\\": boolean,
    \\"nullableID\\": nullableID,
    \\"id\\": id,
  };
  module Z__INTERNAL = {
    type root = t;
    type nonrec _graphql_VariousScalarsInput_47;
    /**\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}
\`\`\`*/
    let _graphql_VariousScalarsInput_47: _graphql_VariousScalarsInput_47 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects skipDirectives.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_v1 = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": Js.Nullable.t(string),
    };
    type t_v2 = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": Js.Nullable.t(string),
    };
    type t = {
      .
      \\"v1\\": t_v1,
      \\"v2\\": t_v2,
    };
    type t_variables = {. \\"var\\": bool};
  };
  let query = \\"query ($var: Boolean!)  {\\\\nv1: variousScalars  {\\\\nnullableString @skip(if: $var) \\\\nstring @skip(if: $var) \\\\n}\\\\n\\\\nv2: variousScalars  {\\\\nnullableString @include(if: $var) \\\\nstring @include(if: $var) \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_v1 = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": option(string),
  };
  type t_v2 = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": option(string),
  };
  type t = {
    .
    \\"v1\\": t_v1,
    \\"v2\\": t_v2,
  };
  type t_variables = {. \\"var\\": bool};
  let parse: Raw.t => t =
    value => {
      let v2 = {
        let value = value##v2;
        let string = {
          let value = value##string;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and nullableString = {
          let value = value##nullableString;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {\\"nullableString\\": nullableString, \\"string\\": string};
      }
      and v1 = {
        let value = value##v1;
        let string = {
          let value = value##string;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and nullableString = {
          let value = value##nullableString;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {\\"nullableString\\": nullableString, \\"string\\": string};
      };
      {\\"v1\\": v1, \\"v2\\": v2};
    };
  let serialize: t => Raw.t =
    value => {
      let v2 = {
        let value = value##v2;
        let string = {
          let value = value##string;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and nullableString = {
          let value = value##nullableString;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {\\"nullableString\\": nullableString, \\"string\\": string};
      }
      and v1 = {
        let value = value##v1;
        let string = {
          let value = value##string;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and nullableString = {
          let value = value##nullableString;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {\\"nullableString\\": nullableString, \\"string\\": string};
      };
      {\\"v1\\": v1, \\"v2\\": v2};
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"var\\": (a => a)(inp##var)};
  let makeVariables = (~var, ()) =>
    serializeVariables({\\"var\\": var}: t_variables);
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects subscription.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_simpleSubscription_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_simpleSubscription_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_simpleSubscription;
    type t = {. \\"simpleSubscription\\": t_simpleSubscription};
    type t_variables = Js.Json.t;
  };
  let query = \\"subscription   {\\\\nsimpleSubscription  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_simpleSubscription_Dog = {. \\"name\\": string};
  type t_simpleSubscription_Human = {. \\"name\\": string};
  type t_simpleSubscription = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_simpleSubscription_Dog)
    | \`Human(t_simpleSubscription_Human)
  ];
  type t = {. \\"simpleSubscription\\": t_simpleSubscription};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let simpleSubscription = {
        let value = value##simpleSubscription;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_simpleSubscription_Dog = Obj.magic(value);
                let name = {
                  let value = value##name;
                  value;
                };
                {\\"name\\": name};
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_simpleSubscription_Human = Obj.magic(value);
                let name = {
                  let value = value##name;
                  value;
                };
                {\\"name\\": name};
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_simpleSubscription
        );
      };
      {\\"simpleSubscription\\": simpleSubscription};
    };
  let serialize: t => Raw.t =
    value => {
      let simpleSubscription = {
        let value = value##simpleSubscription;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let name = {
                  let value = value##name;
                  value;
                };
                {\\"__typename\\": \\"Dog\\", \\"name\\": name};
              },
            ): Raw.t_simpleSubscription
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = value##name;
                  value;
                };
                {\\"__typename\\": \\"Human\\", \\"name\\": name};
              },
            ): Raw.t_simpleSubscription
          )
        | \`FutureAddedValue(value) => (
            Obj.magic(value): Raw.t_simpleSubscription
          )
        };
      };
      {\\"simpleSubscription\\": simpleSubscription};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects tagged_template.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {
          \\"nullableString\\": nullableString,
          \\"string\\": string,
          \\"nullableInt\\": nullableInt,
          \\"int\\": int,
          \\"nullableFloat\\": nullableFloat,
          \\"float\\": float,
          \\"nullableBoolean\\": nullableBoolean,
          \\"boolean\\": boolean,
          \\"nullableID\\": nullableID,
          \\"id\\": id,
        };
      };
      {\\"variousScalars\\": variousScalars};
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {
          \\"nullableString\\": nullableString,
          \\"string\\": string,
          \\"nullableInt\\": nullableInt,
          \\"int\\": int,
          \\"nullableFloat\\": nullableFloat,
          \\"float\\": float,
          \\"nullableBoolean\\": nullableBoolean,
          \\"boolean\\": boolean,
          \\"nullableID\\": nullableID,
          \\"id\\": id,
        };
      };
      {\\"variousScalars\\": variousScalars};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery2 = {
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = Js.Json.t;
  };
  %raw
  \\"let { graphql } = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {
          \\"nullableString\\": nullableString,
          \\"string\\": string,
          \\"nullableInt\\": nullableInt,
          \\"int\\": int,
          \\"nullableFloat\\": nullableFloat,
          \\"float\\": float,
          \\"nullableBoolean\\": nullableBoolean,
          \\"boolean\\": boolean,
          \\"nullableID\\": nullableID,
          \\"id\\": id,
        };
      };
      {\\"variousScalars\\": variousScalars};
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {
          \\"nullableString\\": nullableString,
          \\"string\\": string,
          \\"nullableInt\\": nullableInt,
          \\"int\\": int,
          \\"nullableFloat\\": nullableFloat,
          \\"float\\": float,
          \\"nullableBoolean\\": nullableBoolean,
          \\"boolean\\": boolean,
          \\"nullableID\\": nullableID,
          \\"id\\": id,
        };
      };
      {\\"variousScalars\\": variousScalars};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery2 {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery3 = {
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = Js.Json.t;
  };
  %raw
  \\"let { graphql } = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {
          \\"nullableString\\": nullableString,
          \\"string\\": string,
          \\"nullableInt\\": nullableInt,
          \\"int\\": int,
          \\"nullableFloat\\": nullableFloat,
          \\"float\\": float,
          \\"nullableBoolean\\": nullableBoolean,
          \\"boolean\\": boolean,
          \\"nullableID\\": nullableID,
          \\"id\\": id,
        };
      };
      {\\"variousScalars\\": variousScalars};
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {
          \\"nullableString\\": nullableString,
          \\"string\\": string,
          \\"nullableInt\\": nullableInt,
          \\"int\\": int,
          \\"nullableFloat\\": nullableFloat,
          \\"float\\": float,
          \\"nullableBoolean\\": nullableBoolean,
          \\"boolean\\": boolean,
          \\"nullableID\\": nullableID,
          \\"id\\": id,
        };
      };
      {\\"variousScalars\\": variousScalars};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery3 {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery4 = {
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = Js.Json.t;
  };
  %raw
  \\"let graphql = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {
          \\"nullableString\\": nullableString,
          \\"string\\": string,
          \\"nullableInt\\": nullableInt,
          \\"int\\": int,
          \\"nullableFloat\\": nullableFloat,
          \\"float\\": float,
          \\"nullableBoolean\\": nullableBoolean,
          \\"boolean\\": boolean,
          \\"nullableID\\": nullableID,
          \\"id\\": id,
        };
      };
      {\\"variousScalars\\": variousScalars};
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {
          \\"nullableString\\": nullableString,
          \\"string\\": string,
          \\"nullableInt\\": nullableInt,
          \\"int\\": int,
          \\"nullableFloat\\": nullableFloat,
          \\"float\\": float,
          \\"nullableBoolean\\": nullableBoolean,
          \\"boolean\\": boolean,
          \\"nullableID\\": nullableID,
          \\"id\\": id,
        };
      };
      {\\"variousScalars\\": variousScalars};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery4 {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects typename.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_first_inner_inner = {
      .
      \\"__typename\\": string,
      \\"field\\": string,
    };
    type t_first_inner = {
      .
      \\"__typename\\": string,
      \\"inner\\": Js.Nullable.t(t_first_inner_inner),
    };
    type t_first = {
      .
      \\"__typename\\": string,
      \\"inner\\": Js.Nullable.t(t_first_inner),
    };
    type t = {. \\"first\\": t_first};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_first_inner_inner = {
    .
    \\"__typename\\": string,
    \\"field\\": string,
  };
  type t_first_inner = {
    .
    \\"__typename\\": string,
    \\"inner\\": option(t_first_inner_inner),
  };
  type t_first = {
    .
    \\"__typename\\": string,
    \\"inner\\": option(t_first_inner),
  };
  type t = {. \\"first\\": t_first};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let first = {
        let value = value##first;
        let inner = {
          let value = value##inner;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {
                let inner = {
                  let value = value##inner;
                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some(
                      {
                        let field = {
                          let value = value##field;
                          value;
                        }
                        and __typename = {
                          let value = value##__typename;
                          value;
                        };
                        {\\"__typename\\": __typename, \\"field\\": field};
                      },
                    )
                  | None => None
                  };
                }
                and __typename = {
                  let value = value##__typename;
                  value;
                };
                {\\"__typename\\": __typename, \\"inner\\": inner};
              },
            )
          | None => None
          };
        }
        and __typename = {
          let value = value##__typename;
          value;
        };
        {\\"__typename\\": __typename, \\"inner\\": inner};
      };
      {\\"first\\": first};
    };
  let serialize: t => Raw.t =
    value => {
      let first = {
        let value = value##first;
        let inner = {
          let value = value##inner;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {
                let inner = {
                  let value = value##inner;
                  switch (value) {
                  | Some(value) =>
                    Js.Nullable.return(
                      {
                        let field = {
                          let value = value##field;
                          value;
                        }
                        and __typename = {
                          let value = value##__typename;
                          value;
                        };
                        {\\"__typename\\": __typename, \\"field\\": field};
                      },
                    )
                  | None => Js.Nullable.null
                  };
                }
                and __typename = {
                  let value = value##__typename;
                  value;
                };
                {\\"__typename\\": __typename, \\"inner\\": inner};
              },
            )
          | None => Js.Nullable.null
          };
        }
        and __typename = {
          let value = value##__typename;
          value;
        };
        {\\"__typename\\": __typename, \\"inner\\": inner};
      };
      {\\"first\\": first};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects union.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman_Human = {. \\"name\\": string};
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {\\"name\\": name, \\"barkVolume\\": barkVolume};
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                let name = {
                  let value = value##name;
                  value;
                };
                {\\"name\\": name};
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
  let serialize: t => Raw.t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {\\"__typename\\": \\"Dog\\", \\"name\\": name, \\"barkVolume\\": barkVolume};
              },
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = value##name;
                  value;
                };
                {\\"__typename\\": \\"Human\\", \\"name\\": name};
              },
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQueryNoError = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman_Human = {. \\"name\\": string};
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {\\"name\\": name, \\"barkVolume\\": barkVolume};
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                let name = {
                  let value = value##name;
                  value;
                };
                {\\"name\\": name};
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
  let serialize: t => Raw.t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {\\"__typename\\": \\"Dog\\", \\"name\\": name, \\"barkVolume\\": barkVolume};
              },
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = value##name;
                  value;
                };
                {\\"__typename\\": \\"Human\\", \\"name\\": name};
              },
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQueryNoError {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects unionPartial.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {\\"name\\": name, \\"barkVolume\\": barkVolume};
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
  let serialize: t => Raw.t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {\\"__typename\\": \\"Dog\\", \\"name\\": name, \\"barkVolume\\": barkVolume};
              },
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects variant.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_mutationForVariant_dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_mutationForVariant_human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_mutationForVariant_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_mutationForVariant_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_mutationForVariant_dogOrHuman;
    type t_mutationForVariant;
    type t = {. \\"mutationForVariant\\": t_mutationForVariant};
    type t_variables = Js.Json.t;
  };
  let query = \\"mutation   {\\\\nmutationForVariant  {\\\\nbaseType  \\\\nbaseTypeList  \\\\ndog  {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\nhuman  {\\\\nname  \\\\n}\\\\n\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_mutationForVariant_dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_mutationForVariant_human = {. \\"name\\": string};
  type t_mutationForVariant_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_mutationForVariant_dogOrHuman_Human = {. \\"name\\": string};
  type t_mutationForVariant_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_mutationForVariant_dogOrHuman_Dog)
    | \`Human(t_mutationForVariant_dogOrHuman_Human)
  ];
  type t_mutationForVariant = [
    | \`BaseType(string)
    | \`BaseTypeList(array(string))
    | \`Dog(t_mutationForVariant_dog)
    | \`Human(t_mutationForVariant_human)
    | \`DogOrHuman(t_mutationForVariant_dogOrHuman)
  ];
  type t = {. \\"mutationForVariant\\": t_mutationForVariant};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let mutationForVariant = {
        let value = value##mutationForVariant;
        switch (Js.Json.decodeObject(Obj.magic(value): Js.Json.t)) {
        | None =>
          Js.Exn.raiseError(
            \\"graphql_ppx: \\"
            ++ \\"Expected type \\"
            ++ \\"VariantTestResult\\"
            ++ \\" to be an object\\",
          )
        | Some(value) =>
          let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"baseType\\");
          switch (Js.Json.decodeNull(temp)) {
          | None =>
            let value = temp;
            \`BaseType(value);
          | Some(_) =>
            let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"baseTypeList\\");
            switch (Js.Json.decodeNull(temp)) {
            | None =>
              let value = temp;
              \`BaseTypeList(value |> Js.Array.map(value => value));
            | Some(_) =>
              let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"dog\\");
              switch (Js.Json.decodeNull(temp)) {
              | None =>
                let value = temp;
                \`Dog(
                  {
                    let barkVolume = {
                      let value = value##barkVolume;
                      value;
                    }
                    and name = {
                      let value = value##name;
                      value;
                    };
                    {\\"name\\": name, \\"barkVolume\\": barkVolume};
                  },
                );
              | Some(_) =>
                let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"human\\");
                switch (Js.Json.decodeNull(temp)) {
                | None =>
                  let value = temp;
                  \`Human(
                    {
                      let name = {
                        let value = value##name;
                        value;
                      };
                      {\\"name\\": name};
                    },
                  );
                | Some(_) =>
                  let temp =
                    Js.Dict.unsafeGet(Obj.magic(value), \\"dogOrHuman\\");
                  switch (Js.Json.decodeNull(temp)) {
                  | None =>
                    let value = temp;
                    \`DogOrHuman(
                      {
                        let typename: string =
                          Obj.magic(
                            Js.Dict.unsafeGet(
                              Obj.magic(value),
                              \\"__typename\\",
                            ),
                          );
                        (
                          switch (typename) {
                          | \\"Dog\\" =>
                            \`Dog(
                              {
                                let value: Raw.t_mutationForVariant_dogOrHuman_Dog =
                                  Obj.magic(value);
                                let barkVolume = {
                                  let value = value##barkVolume;
                                  value;
                                }
                                and name = {
                                  let value = value##name;
                                  value;
                                };
                                {\\"name\\": name, \\"barkVolume\\": barkVolume};
                              },
                            )
                          | \\"Human\\" =>
                            \`Human(
                              {
                                let value: Raw.t_mutationForVariant_dogOrHuman_Human =
                                  Obj.magic(value);
                                let name = {
                                  let value = value##name;
                                  value;
                                };
                                {\\"name\\": name};
                              },
                            )
                          | _ =>
                            \`FutureAddedValue(Obj.magic(value): Js.Json.t)
                          }: t_mutationForVariant_dogOrHuman
                        );
                      },
                    );
                  | Some(_) =>
                    Js.Exn.raiseError(
                      \\"graphql_ppx: \\"
                      ++ \\"All fields on variant selection set on type \\"
                      ++ \\"VariantTestResult\\"
                      ++ \\" were null\\",
                    )
                  };
                };
              };
            };
          };
        };
      };
      {\\"mutationForVariant\\": mutationForVariant};
    };
  let serialize: t => Raw.t =
    value => {
      let mutationForVariant = {
        let value = value##mutationForVariant;
        Obj.magic(Js.Json.null);
      };
      {\\"mutationForVariant\\": mutationForVariant};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records argNamedQuery.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {argNamedQuery: int};
    type t_variables = {query: int};
  };
  let query = \\"query ($query: Int!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\";
  type t = {argNamedQuery: int};
  type t_variables = {query: int};
  let parse: Raw.t => t =
    (value) => (
      {
        argNamedQuery: {
          let value = (value: Raw.t).argNamedQuery;
          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let argNamedQuery = {
          let value = (value: t).argNamedQuery;
          value;
        };
        {argNamedQuery: argNamedQuery};
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {query: (a => a)((inp: t_variables).query)};
  let makeVariables = (~query, ()) =>
    serializeVariables({query: query}: t_variables);
  module Z__INTERNAL = {
    type nonrec _graphql_query_82;
    /**Variable **$query** has the following graphql type:

\`\`\`
Int!
\`\`\`*/
    let _graphql_query_82: _graphql_query_82 = Obj.magic(0);
    type nonrec _graphql_query_75;
    /**Argument **query** on field **argNamedQuery** has the following graphql type:

\`\`\`
Int!
\`\`\`*/
    let _graphql_query_75: _graphql_query_75 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records comment.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {nonrecursiveInput: string};
    type t_variables = {arg: t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      nonNullableField: string,
      nullableArray: Js.Nullable.t(array(Js.Nullable.t(string))),
      field: Js.Nullable.t(string),
      enum: Js.Nullable.t(string),
      embeddedInput:
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
      custom: Js.Nullable.t(Js.Json.t),
    }
    and t_variables_EmbeddedInput = {field: Js.Nullable.t(string)};
  };
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {nonrecursiveInput: string};
  type t_variables = {arg: t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    nonNullableField: string,
    nullableArray: option(array(option(string))),
    field: option(string),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
    embeddedInput: option(array(option(t_variables_EmbeddedInput))),
    custom: option(Js.Json.t),
  }
  and t_variables_EmbeddedInput = {field: option(string)};
  let parse: Raw.t => t =
    (value) => (
      {
        nonrecursiveInput: {
          let value = (value: Raw.t).nonrecursiveInput;
          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let nonrecursiveInput = {
          let value = (value: t).nonrecursiveInput;
          value;
        };
        {nonrecursiveInput: nonrecursiveInput};
      }: Raw.t
    );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (a => serializeInputObjectNonrecursiveInput(a))(
          (inp: t_variables).arg,
        ),
    }
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {
      nonNullableField:
        (a => a)((inp: t_variables_NonrecursiveInput).nonNullableField),
      nullableArray:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).nullableArray,
        ),
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).field,
        ),
      enum:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).enum,
        ),
      embeddedInput:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).embeddedInput,
        ),
      custom:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).custom,
        ),
    }
  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_EmbeddedInput).field,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables)
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        ~custom=?,
        (),
      )
      : t_variables_NonrecursiveInput => {
    nonNullableField,
    nullableArray,
    field,
    enum,
    embeddedInput,
    custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {
    field: field,
  };
  module Z__INTERNAL = {
    type nonrec _graphql_arg_100;
    /**Variable **$arg** has the following graphql type:

\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}!
\`\`\`*/
    let _graphql_arg_100: _graphql_arg_100 = Obj.magic(0);
    type nonrec _graphql_arg_95;
    /**Argument **arg** on field **nonrecursiveInput** has the following graphql type:

\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}!
\`\`\`*/
    let _graphql_arg_95: _graphql_arg_95 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_NonrecursiveInput_49;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_49: _graphql_NonrecursiveInput_49 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records customDecoder.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module StringOfInt = {
  let parse = string_of_int;
  let serialize = int_of_string;
  type t = string;
};
module IntOfString = {
  let parse = int_of_string;
  let serialize = string_of_int;
  type t = int;
};
module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      string,
      int,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {
    string: IntOfString.t,
    int: StringOfInt.t,
  };
  type t = {variousScalars: t_variousScalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {
              string: {
                let value = (value: Raw.t_variousScalars).string;
                IntOfString.parse(value);
              },
              int: {
                let value = (value: Raw.t_variousScalars).int;
                StringOfInt.parse(value);
              },
            }: t_variousScalars
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let int = {
                let value = (value: t_variousScalars).int;
                StringOfInt.serialize(value);
              }
              and string = {
                let value = (value: t_variousScalars).string;
                IntOfString.serialize(value);
              };
              {string, int};
            }: Raw.t_variousScalars
          );
        };
        {variousScalars: variousScalars};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records customScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_customScalarField = {
      nullable: Js.Nullable.t(Js.Json.t),
      nonNullable: Js.Json.t,
    };
    type t = {customScalarField: t_customScalarField};
    type t_variables = {
      opt: Js.Nullable.t(Js.Json.t),
      req: Js.Json.t,
    };
  };
  let query = \\"query ($opt: CustomScalar, $req: CustomScalar!)  {\\\\ncustomScalarField(argOptional: $opt, argRequired: $req)  {\\\\nnullable  \\\\nnonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_customScalarField = {
    nullable: option(Js.Json.t),
    nonNullable: Js.Json.t,
  };
  type t = {customScalarField: t_customScalarField};
  type t_variables = {
    opt: option(Js.Json.t),
    req: Js.Json.t,
  };
  let parse: Raw.t => t =
    (value) => (
      {
        customScalarField: {
          let value = (value: Raw.t).customScalarField;
          (
            {
              nullable: {
                let value = (value: Raw.t_customScalarField).nullable;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              nonNullable: {
                let value = (value: Raw.t_customScalarField).nonNullable;
                value;
              },
            }: t_customScalarField
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let customScalarField = {
          let value = (value: t).customScalarField;
          (
            {
              let nonNullable = {
                let value = (value: t_customScalarField).nonNullable;
                value;
              }
              and nullable = {
                let value = (value: t_customScalarField).nullable;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              };
              {nullable, nonNullable};
            }: Raw.t_customScalarField
          );
        };
        {customScalarField: customScalarField};
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      opt:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).opt,
        ),
      req: (a => a)((inp: t_variables).req),
    };
  let makeVariables = (~opt=?, ~req, ()) =>
    serializeVariables({opt, req}: t_variables);
  module Z__INTERNAL = {
    type nonrec _graphql_opt_119;
    /**Variable **$opt** has the following graphql type:

\`\`\`
CustomScalar
\`\`\`*/
    let _graphql_opt_119: _graphql_opt_119 = Obj.magic(0);
    type nonrec _graphql_argOptional_106;
    /**Argument **argOptional** on field **customScalarField** has the following graphql type:

\`\`\`
CustomScalar
\`\`\`*/
    let _graphql_argOptional_106: _graphql_argOptional_106 = Obj.magic(0);
    type nonrec _graphql_req_138;
    /**Variable **$req** has the following graphql type:

\`\`\`
CustomScalar!
\`\`\`*/
    let _graphql_req_138: _graphql_req_138 = Obj.magic(0);
    type nonrec _graphql_argRequired_125;
    /**Argument **argRequired** on field **customScalarField** has the following graphql type:

\`\`\`
CustomScalar!
\`\`\`*/
    let _graphql_argRequired_125: _graphql_argRequired_125 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records customTypes.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Color = {
  type t =
    | Red
    | Green
    | Blue;
  let parse = json =>
    switch (json |> Js.Json.decodeString) {
    | Some(\\"green\\") => Green
    | Some(\\"blue\\") => Blue
    | Some(\\"red\\")
    | Some(_)
    | None => Red
    };
  let serialize = color =>
    (
      switch (color) {
      | Red => \\"red\\"
      | Green => \\"green\\"
      | Blue => \\"blue\\"
      }
    )
    |> Js.Json.string;
};
module DateTime = {
  type t = Js.Date.t;
  let parse = json =>
    switch (json |> Js.Json.decodeString) {
    | Some(str) => str |> Js.Date.fromString
    | None => Js.Date.make()
    };
  let serialize = date => date |> Js.Date.toISOString |> Js.Json.string;
};
module MyQuery = {
  module Raw = {
    type t_customFields = {
      currentTime: Js.Json.t,
      favoriteColor: Js.Json.t,
      futureTime: Js.Nullable.t(Js.Json.t),
      nullableColor: Js.Nullable.t(Js.Json.t),
    };
    type t = {customFields: t_customFields};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ncustomFields  {\\\\ncurrentTime  \\\\nfavoriteColor  \\\\nfutureTime  \\\\nnullableColor  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_customFields = {
    currentTime: DateTime.t,
    favoriteColor: Color.t,
    futureTime: option(DateTime.t),
    nullableColor: option(Color.t),
  };
  type t = {customFields: t_customFields};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        customFields: {
          let value = (value: Raw.t).customFields;
          (
            {
              currentTime: {
                let value = (value: Raw.t_customFields).currentTime;
                DateTime.parse(value);
              },
              favoriteColor: {
                let value = (value: Raw.t_customFields).favoriteColor;
                Color.parse(value);
              },
              futureTime: {
                let value = (value: Raw.t_customFields).futureTime;
                switch (Js.toOption(value)) {
                | Some(value) => Some(DateTime.parse(value))
                | None => None
                };
              },
              nullableColor: {
                let value = (value: Raw.t_customFields).nullableColor;
                switch (Js.toOption(value)) {
                | Some(value) => Some(Color.parse(value))
                | None => None
                };
              },
            }: t_customFields
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let customFields = {
          let value = (value: t).customFields;
          (
            {
              let nullableColor = {
                let value = (value: t_customFields).nullableColor;
                switch (value) {
                | Some(value) => Js.Nullable.return(Color.serialize(value))
                | None => Js.Nullable.null
                };
              }
              and futureTime = {
                let value = (value: t_customFields).futureTime;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(DateTime.serialize(value))
                | None => Js.Nullable.null
                };
              }
              and favoriteColor = {
                let value = (value: t_customFields).favoriteColor;
                Color.serialize(value);
              }
              and currentTime = {
                let value = (value: t_customFields).currentTime;
                DateTime.serialize(value);
              };
              {currentTime, favoriteColor, futureTime, nullableColor};
            }: Raw.t_customFields
          );
        };
        {customFields: customFields};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records defaultObjectValueOnScalar.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {defaultObjectValueOnScalar: string};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndefaultObjectValueOnScalar(filter: {some: {json: \\\\\\"value\\\\\\"}}, arg: {field: \\\\\\"otherValue\\\\\\"})  \\\\n}\\\\n\\";
  type t = {defaultObjectValueOnScalar: string};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        defaultObjectValueOnScalar: {
          let value = (value: Raw.t).defaultObjectValueOnScalar;
          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let defaultObjectValueOnScalar = {
          let value = (value: t).defaultObjectValueOnScalar;
          value;
        };
        {defaultObjectValueOnScalar: defaultObjectValueOnScalar};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type nonrec _graphql_filter_92;
    /**Argument **filter** on field **defaultObjectValueOnScalar** has the following graphql type:

\`\`\`
JsonScalar!
\`\`\`*/
    let _graphql_filter_92: _graphql_filter_92 = Obj.magic(0);
    type nonrec _graphql_arg_140;
    /**Argument **arg** on field **defaultObjectValueOnScalar** has the following graphql type:

\`\`\`
EmbeddedInput {
  field: String
}!
\`\`\`*/
    let _graphql_arg_140: _graphql_arg_140 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records enumInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {enumInput: string};
    type t_variables = {arg: string};
  };
  let query = \\"query ($arg: SampleField!)  {\\\\nenumInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {enumInput: string};
  type t_variables = {arg: [ | \`FIRST | \`SECOND | \`THIRD]};
  let parse: Raw.t => t =
    (value) => (
      {
        enumInput: {
          let value = (value: Raw.t).enumInput;
          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let enumInput = {
          let value = (value: t).enumInput;
          value;
        };
        {enumInput: enumInput};
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (
          a =>
            switch (a) {
            | \`FIRST => \\"FIRST\\"
            | \`SECOND => \\"SECOND\\"
            | \`THIRD => \\"THIRD\\"
            }
        )(
          (inp: t_variables).arg,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables);
  module Z__INTERNAL = {
    type nonrec _graphql_arg_82;
    /**Variable **$arg** has the following graphql type:

\`\`\`
SampleField {
  FIRST
  SECOND
  THIRD
}!
\`\`\`*/
    let _graphql_arg_82: _graphql_arg_82 = Obj.magic(0);
    type nonrec _graphql_arg_77;
    /**Argument **arg** on field **enumInput** has the following graphql type:

\`\`\`
SampleField {
  FIRST
  SECOND
  THIRD
}!
\`\`\`*/
    let _graphql_arg_77: _graphql_arg_77 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_SampleField_47;
    /**\`\`\`
SampleField {
  FIRST
  SECOND
  THIRD
}
\`\`\`*/
    let _graphql_SampleField_47: _graphql_SampleField_47 = Obj.magic(0);
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records explicit_object_record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module RecordsQuery = {
  module Raw = {
    type t_lists = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
    type t = {lists: t_lists};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_lists = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  type t = {lists: t_lists};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        lists: {
          let value = (value: Raw.t).lists;
          (
            {
              nullableOfNullable: {
                let value = (value: Raw.t_lists).nullableOfNullable;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              },
              nullableOfNonNullable: {
                let value = (value: Raw.t_lists).nullableOfNonNullable;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value |> Js.Array.map(value => value))
                | None => None
                };
              },
              nonNullableOfNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNullable;
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   );
              },
              nonNullableOfNonNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNonNullable;
                value |> Js.Array.map(value => value);
              },
            }: t_lists
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let lists = {
          let value = (value: t).lists;
          (
            {
              let nonNullableOfNonNullable = {
                let value = (value: t_lists).nonNullableOfNonNullable;
                value |> Js.Array.map(value => value);
              }
              and nonNullableOfNullable = {
                let value = (value: t_lists).nonNullableOfNullable;
                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   );
              }
              and nullableOfNonNullable = {
                let value = (value: t_lists).nullableOfNonNullable;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(value |> Js.Array.map(value => value))
                | None => Js.Nullable.null
                };
              }
              and nullableOfNullable = {
                let value = (value: t_lists).nullableOfNullable;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map(value =>
                         switch (value) {
                         | Some(value) => Js.Nullable.return(value)
                         | None => Js.Nullable.null
                         }
                       ),
                  )
                | None => Js.Nullable.null
                };
              };
              {
                nullableOfNullable,
                nullableOfNonNullable,
                nonNullableOfNullable,
                nonNullableOfNonNullable,
              };
            }: Raw.t_lists
          );
        };
        {lists: lists};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module RecordsQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ObjectsQuery = {
  module Raw = {
    type t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
    type t = {. \\"lists\\": t_lists};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  type t = {. \\"lists\\": t_lists};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    value => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;
          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;
          value
          |> Js.Array.map(value =>
               switch (Js.toOption(value)) {
               | Some(value) => Some(value)
               | None => None
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value |> Js.Array.map(value => value))
          | None => None
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 ),
            )
          | None => None
          };
        };
        {
          \\"nullableOfNullable\\": nullableOfNullable,
          \\"nullableOfNonNullable\\": nullableOfNonNullable,
          \\"nonNullableOfNullable\\": nonNullableOfNullable,
          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {\\"lists\\": lists};
    };
  let serialize: t => Raw.t =
    value => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;
          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;
          value
          |> Js.Array.map(value =>
               switch (value) {
               | Some(value) => Js.Nullable.return(value)
               | None => Js.Nullable.null
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(value |> Js.Array.map(value => value))
          | None => Js.Nullable.null
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 ),
            )
          | None => Js.Nullable.null
          };
        };
        {
          \\"nullableOfNullable\\": nullableOfNullable,
          \\"nullableOfNonNullable\\": nullableOfNonNullable,
          \\"nonNullableOfNullable\\": nonNullableOfNullable,
          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {\\"lists\\": lists};
    };
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ObjectsQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records extensions.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module type GraphQLQuery = {
  module Raw: {
    type t;
    type t_variables;
  };
  type t;
  type t_variables;

  let query: string;
  let parse: Raw.t => t;
  let serialize: t => Raw.t;
};

module ExtendQuery = (M: GraphQLQuery) => {
  let use = () => ();
};
module Bla' = {
  module Raw = {
    type t_lists = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
    type t = {lists: t_lists};
    type t_variables = Js.Json.t;
  };
  let query = \\"query Bla  {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_lists = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  type t = {lists: t_lists};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        lists: {
          let value = (value: Raw.t).lists;
          (
            {
              nullableOfNullable: {
                let value = (value: Raw.t_lists).nullableOfNullable;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              },
              nullableOfNonNullable: {
                let value = (value: Raw.t_lists).nullableOfNonNullable;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value |> Js.Array.map(value => value))
                | None => None
                };
              },
              nonNullableOfNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNullable;
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   );
              },
              nonNullableOfNonNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNonNullable;
                value |> Js.Array.map(value => value);
              },
            }: t_lists
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let lists = {
          let value = (value: t).lists;
          (
            {
              let nonNullableOfNonNullable = {
                let value = (value: t_lists).nonNullableOfNonNullable;
                value |> Js.Array.map(value => value);
              }
              and nonNullableOfNullable = {
                let value = (value: t_lists).nonNullableOfNullable;
                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   );
              }
              and nullableOfNonNullable = {
                let value = (value: t_lists).nullableOfNonNullable;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(value |> Js.Array.map(value => value))
                | None => Js.Nullable.null
                };
              }
              and nullableOfNullable = {
                let value = (value: t_lists).nullableOfNullable;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map(value =>
                         switch (value) {
                         | Some(value) => Js.Nullable.return(value)
                         | None => Js.Nullable.null
                         }
                       ),
                  )
                | None => Js.Nullable.null
                };
              };
              {
                nullableOfNullable,
                nullableOfNonNullable,
                nonNullableOfNullable,
                nonNullableOfNonNullable,
              };
            }: Raw.t_lists
          );
        };
        {lists: lists};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module Bla = {
  include Bla';
  include ExtendQuery(Bla');
};
"
`;

exports[`Records fragmentDefinition.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Fragments = {
  module ListFragment = {
    let query = \\"fragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
        nullableOfNonNullable: Js.Nullable.t(array(string)),
      };
      type nonrec t_Lists = t;
    };
    type t = {
      nullableOfNullable: option(array(option(string))),
      nullableOfNonNullable: option(array(string)),
    };
    type nonrec t_Lists = t;
    let parse = (value: Raw.t): t => {
      nullableOfNullable: {
        let value = (value: Raw.t).nullableOfNullable;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      },
      nullableOfNonNullable: {
        let value = (value: Raw.t).nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      },
    };
    let serialize: t => Raw.t =
      (value) => (
        {
          let nullableOfNonNullable = {
            let value = (value: t).nullableOfNonNullable;
            switch (value) {
            | Some(value) =>
              Js.Nullable.return(value |> Js.Array.map(value => value))
            | None => Js.Nullable.null
            };
          }
          and nullableOfNullable = {
            let value = (value: t).nullableOfNullable;
            switch (value) {
            | Some(value) =>
              Js.Nullable.return(
                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   ),
              )
            | None => Js.Nullable.null
            };
          };
          {nullableOfNullable, nullableOfNonNullable};
        }: Raw.t
      );
    let name = \\"ListFragment\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql;
      /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}
\`\`\`*/
      let graphql: graphql = Obj.magic(0);
      type nonrec graphql_module;
      /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module Fragments {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  module Another = {
    let query = \\"fragment Another on Lists   {\\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
    module Raw = {
      type t = {nullableOfNonNullable: Js.Nullable.t(array(string))};
      type nonrec t_Lists = t;
    };
    type t = {nullableOfNonNullable: option(array(string))};
    type nonrec t_Lists = t;
    let parse = (value: Raw.t): t => {
      nullableOfNonNullable: {
        let value = (value: Raw.t).nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      },
    };
    let serialize: t => Raw.t =
      (value) => (
        {
          let nullableOfNonNullable = {
            let value = (value: t).nullableOfNonNullable;
            switch (value) {
            | Some(value) =>
              Js.Nullable.return(value |> Js.Array.map(value => value))
            | None => Js.Nullable.null
            };
          };
          {nullableOfNonNullable: nullableOfNonNullable};
        }: Raw.t
      );
    let name = \\"Another\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql;
      /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}
\`\`\`*/
      let graphql: graphql = Obj.magic(0);
      type nonrec graphql_module;
      /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module Fragments {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
};
module MyQuery = {
  module Raw = {
    type t_l2;
    type t_l3;
    type t_l4;
    type t = {
      l1: Fragments.ListFragment.Raw.t,
      l2: t_l2,
      l3: t_l3,
      l4: t_l4,
    };
    type t_variables = Js.Json.t;
  };
  let query =
    (
      (
        (
          (
            (
              (
                (
                  (
                    (
                      (
                        (
                          (
                            \\"query   {\\\\nl1: lists  {\\\\n...\\"
                            ++ Fragments.ListFragment.name
                          )
                          ++ \\"   \\\\n}\\\\n\\\\nl2: lists  {\\\\n...\\"
                        )
                        ++ Fragments.ListFragment.name
                      )
                      ++ \\"   \\\\n...\\"
                    )
                    ++ Fragments.ListFragment.name
                  )
                  ++ \\"   \\\\n}\\\\n\\\\nl3: lists  {\\\\nnullableOfNullable  \\\\n...\\"
                )
                ++ Fragments.ListFragment.name
              )
              ++ \\"   \\\\n...\\"
            )
            ++ Fragments.ListFragment.name
          )
          ++ \\"   \\\\n}\\\\n\\\\nl4: lists  {\\\\nnullableOfNullable  \\\\n...\\"
        )
        ++ Fragments.ListFragment.name
      )
      ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
    )
    ++ Fragments.ListFragment.query;
  type t_l2 = {
    frag1: Fragments.ListFragment.t_Lists,
    frag2: Fragments.ListFragment.t_Lists,
  };
  type t_l3 = {
    nullableOfNullable: option(array(option(string))),
    frag1: Fragments.ListFragment.t_Lists,
    frag2: Fragments.ListFragment.t_Lists,
  };
  type t_l4 = {
    nullableOfNullable: option(array(option(string))),
    listFragment: Fragments.ListFragment.t_Lists,
  };
  type t = {
    l1: Fragments.ListFragment.t,
    l2: t_l2,
    l3: t_l3,
    l4: t_l4,
  };
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        l1: {
          let value = (value: Raw.t).l1;
          Fragments.ListFragment.parse(value);
        },
        l2: {
          let value = (value: Raw.t).l2;
          (
            {
              frag1: {
                let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
                Fragments.ListFragment.parse(value);
              },
              frag2: {
                let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
                Fragments.ListFragment.parse(value);
              },
            }: t_l2
          );
        },
        l3: {
          let value = (value: Raw.t).l3;
          (
            {
              nullableOfNullable: {
                let value =
                  Obj.magic(
                    Js.Dict.unsafeGet(
                      Obj.magic(value),
                      \\"nullableOfNullable\\",
                    ),
                  );
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              },
              frag1: {
                let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
                Fragments.ListFragment.parse(value);
              },
              frag2: {
                let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
                Fragments.ListFragment.parse(value);
              },
            }: t_l3
          );
        },
        l4: {
          let value = (value: Raw.t).l4;
          (
            {
              nullableOfNullable: {
                let value =
                  Obj.magic(
                    Js.Dict.unsafeGet(
                      Obj.magic(value),
                      \\"nullableOfNullable\\",
                    ),
                  );
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              },
              listFragment: {
                let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
                Fragments.ListFragment.parse(value);
              },
            }: t_l4
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let l4 = {
          let value = (value: t).l4;
          (
            Obj.magic(
              Js.Array.reduce(
                GraphQL_PPX.deepMerge,
                Obj.magic(
                  {
                    let nullableOfNullable = {
                      let value = (value: t_l4).nullableOfNullable;
                      switch (value) {
                      | Some(value) =>
                        Js.Nullable.return(
                          value
                          |> Js.Array.map(value =>
                               switch (value) {
                               | Some(value) => Js.Nullable.return(value)
                               | None => Js.Nullable.null
                               }
                             ),
                        )
                      | None => Js.Nullable.null
                      };
                    };
                    {\\"nullableOfNullable\\": nullableOfNullable};
                  },
                ): Js.Json.t,
                [|
                  (
                    Obj.magic(
                      Fragments.ListFragment.serialize(
                        (value: t_l4).listFragment,
                      ),
                    ): Js.Json.t
                  ),
                |],
              ),
            ): Raw.t_l4
          );
        }
        and l3 = {
          let value = (value: t).l3;
          (
            Obj.magic(
              Js.Array.reduce(
                GraphQL_PPX.deepMerge,
                Obj.magic(
                  {
                    let nullableOfNullable = {
                      let value = (value: t_l3).nullableOfNullable;
                      switch (value) {
                      | Some(value) =>
                        Js.Nullable.return(
                          value
                          |> Js.Array.map(value =>
                               switch (value) {
                               | Some(value) => Js.Nullable.return(value)
                               | None => Js.Nullable.null
                               }
                             ),
                        )
                      | None => Js.Nullable.null
                      };
                    };
                    {\\"nullableOfNullable\\": nullableOfNullable};
                  },
                ): Js.Json.t,
                [|
                  (
                    Obj.magic(
                      Fragments.ListFragment.serialize((value: t_l3).frag1),
                    ): Js.Json.t
                  ),
                  (
                    Obj.magic(
                      Fragments.ListFragment.serialize((value: t_l3).frag2),
                    ): Js.Json.t
                  ),
                |],
              ),
            ): Raw.t_l3
          );
        }
        and l2 = {
          let value = (value: t).l2;
          (
            Obj.magic(
              Js.Array.reduce(
                GraphQL_PPX.deepMerge,
                Obj.magic(Js.Dict.empty): Js.Json.t,
                [|
                  (
                    Obj.magic(
                      Fragments.ListFragment.serialize((value: t_l2).frag1),
                    ): Js.Json.t
                  ),
                  (
                    Obj.magic(
                      Fragments.ListFragment.serialize((value: t_l2).frag2),
                    ): Js.Json.t
                  ),
                |],
              ),
            ): Raw.t_l2
          );
        }
        and l1 = {
          let value = (value: t).l1;
          Fragments.ListFragment.serialize(value);
        };
        {l1, l2, l3, l4};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery2 = {
  module Raw = {
    type t = {lists: Fragments.ListFragment.Raw.t};
    type t_variables = Js.Json.t;
  };
  let query =
    (
      (\\"query   {\\\\nlists  {\\\\n...\\" ++ Fragments.ListFragment.name)
      ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
    )
    ++ Fragments.ListFragment.query;
  type t = {lists: Fragments.ListFragment.t};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        lists: {
          let value = (value: Raw.t).lists;
          Fragments.ListFragment.parse(value);
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let lists = {
          let value = (value: t).lists;
          Fragments.ListFragment.serialize(value);
        };
        {lists: lists};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery2 {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records interface.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
"
`;

exports[`Records lists.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_lists = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
    type t = {lists: t_lists};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_lists = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  type t = {lists: t_lists};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        lists: {
          let value = (value: Raw.t).lists;
          (
            {
              nullableOfNullable: {
                let value = (value: Raw.t_lists).nullableOfNullable;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              },
              nullableOfNonNullable: {
                let value = (value: Raw.t_lists).nullableOfNonNullable;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value |> Js.Array.map(value => value))
                | None => None
                };
              },
              nonNullableOfNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNullable;
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   );
              },
              nonNullableOfNonNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNonNullable;
                value |> Js.Array.map(value => value);
              },
            }: t_lists
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let lists = {
          let value = (value: t).lists;
          (
            {
              let nonNullableOfNonNullable = {
                let value = (value: t_lists).nonNullableOfNonNullable;
                value |> Js.Array.map(value => value);
              }
              and nonNullableOfNullable = {
                let value = (value: t_lists).nonNullableOfNullable;
                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   );
              }
              and nullableOfNonNullable = {
                let value = (value: t_lists).nullableOfNonNullable;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(value |> Js.Array.map(value => value))
                | None => Js.Nullable.null
                };
              }
              and nullableOfNullable = {
                let value = (value: t_lists).nullableOfNullable;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map(value =>
                         switch (value) {
                         | Some(value) => Js.Nullable.return(value)
                         | None => Js.Nullable.null
                         }
                       ),
                  )
                | None => Js.Nullable.null
                };
              };
              {
                nullableOfNullable,
                nullableOfNonNullable,
                nonNullableOfNullable,
                nonNullableOfNonNullable,
              };
            }: Raw.t_lists
          );
        };
        {lists: lists};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records listsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {listsInput: string};
    type t_variables = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
  };
  let query = \\"query ($nullableOfNullable: [String], $nullableOfNonNullable: [String!], $nonNullableOfNullable: [String]!, $nonNullableOfNonNullable: [String!]!)  {\\\\nlistsInput(arg: {nullableOfNullable: $nullableOfNullable, nullableOfNonNullable: $nullableOfNonNullable, nonNullableOfNullable: $nonNullableOfNullable, nonNullableOfNonNullable: $nonNullableOfNonNullable})  \\\\n}\\\\n\\";
  type t = {listsInput: string};
  type t_variables = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  let parse: Raw.t => t =
    (value) => (
      {
        listsInput: {
          let value = (value: Raw.t).listsInput;
          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let listsInput = {
          let value = (value: t).listsInput;
          value;
        };
        {listsInput: listsInput};
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      nullableOfNullable:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables).nullableOfNullable,
        ),
      nullableOfNonNullable:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return((a => Array.map(b => (a => a)(b), a))(b))
            }
        )(
          (inp: t_variables).nullableOfNonNullable,
        ),
      nonNullableOfNullable:
        (
          a =>
            Array.map(
              b =>
                (
                  a =>
                    switch (a) {
                    | None => Js.Nullable.undefined
                    | Some(b) => Js.Nullable.return((a => a)(b))
                    }
                )(
                  b,
                ),
              a,
            )
        )(
          (inp: t_variables).nonNullableOfNullable,
        ),
      nonNullableOfNonNullable:
        (a => Array.map(b => (a => a)(b), a))(
          (inp: t_variables).nonNullableOfNonNullable,
        ),
    };
  let makeVariables =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      ) =>
    serializeVariables(
      {
        nullableOfNullable,
        nullableOfNonNullable,
        nonNullableOfNullable,
        nonNullableOfNonNullable,
      }: t_variables,
    );
  module Z__INTERNAL = {
    type nonrec _graphql_arg_219;
    /**Argument **arg** on field **listsInput** has the following graphql type:

\`\`\`
ListsInput {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}!
\`\`\`*/
    let _graphql_arg_219: _graphql_arg_219 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records listsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {listsInput: string};
    type t_variables = {arg: t_variables_ListsInput}
    and t_variables_ListsInput = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
  };
  let query = \\"query ($arg: ListsInput!)  {\\\\nlistsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {listsInput: string};
  type t_variables = {arg: t_variables_ListsInput}
  and t_variables_ListsInput = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  let parse: Raw.t => t =
    (value) => (
      {
        listsInput: {
          let value = (value: Raw.t).listsInput;
          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let listsInput = {
          let value = (value: t).listsInput;
          value;
        };
        {listsInput: listsInput};
      }: Raw.t
    );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg: (a => serializeInputObjectListsInput(a))((inp: t_variables).arg),
    }
  and serializeInputObjectListsInput:
    t_variables_ListsInput => Raw.t_variables_ListsInput =
    inp => {
      nullableOfNullable:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_ListsInput).nullableOfNullable,
        ),
      nullableOfNonNullable:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return((a => Array.map(b => (a => a)(b), a))(b))
            }
        )(
          (inp: t_variables_ListsInput).nullableOfNonNullable,
        ),
      nonNullableOfNullable:
        (
          a =>
            Array.map(
              b =>
                (
                  a =>
                    switch (a) {
                    | None => Js.Nullable.undefined
                    | Some(b) => Js.Nullable.return((a => a)(b))
                    }
                )(
                  b,
                ),
              a,
            )
        )(
          (inp: t_variables_ListsInput).nonNullableOfNullable,
        ),
      nonNullableOfNonNullable:
        (a => Array.map(b => (a => a)(b), a))(
          (inp: t_variables_ListsInput).nonNullableOfNonNullable,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables)
  and makeInputObjectListsInput =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      )
      : t_variables_ListsInput => {
    nullableOfNullable,
    nullableOfNonNullable,
    nonNullableOfNullable,
    nonNullableOfNonNullable,
  };
  module Z__INTERNAL = {
    type nonrec _graphql_arg_82;
    /**Variable **$arg** has the following graphql type:

\`\`\`
ListsInput {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}!
\`\`\`*/
    let _graphql_arg_82: _graphql_arg_82 = Obj.magic(0);
    type nonrec _graphql_arg_77;
    /**Argument **arg** on field **listsInput** has the following graphql type:

\`\`\`
ListsInput {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}!
\`\`\`*/
    let _graphql_arg_77: _graphql_arg_77 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_ListsInput_47;
    /**\`\`\`
ListsInput {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}
\`\`\`*/
    let _graphql_ListsInput_47: _graphql_ListsInput_47 = Obj.magic(0);
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records mutation.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_mutationWithError_value = {stringField: string};
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      field: t_mutationWithError_errors_field,
      message: string,
    };
    type t_mutationWithError = {
      value: Js.Nullable.t(t_mutationWithError_value),
      errors: Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {mutationWithError: t_mutationWithError};
    type t_variables = Js.Json.t;
  };
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nvalue  {\\\\nstringField  \\\\n}\\\\n\\\\nerrors  {\\\\nfield  \\\\nmessage  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_mutationWithError_value = {stringField: string};
  type t_mutationWithError_errors_field = [
    | \`FutureAddedValue(string)
    | \`FIRST
    | \`SECOND
    | \`THIRD
  ];
  type t_mutationWithError_errors = {
    field: t_mutationWithError_errors_field,
    message: string,
  };
  type t_mutationWithError = {
    value: option(t_mutationWithError_value),
    errors: option(array(t_mutationWithError_errors)),
  };
  type t = {mutationWithError: t_mutationWithError};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        mutationWithError: {
          let value = (value: Raw.t).mutationWithError;
          (
            {
              value: {
                let value = (value: Raw.t_mutationWithError).value;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {
                      stringField: {
                        let value =
                          (value: Raw.t_mutationWithError_value).stringField;
                        value;
                      },
                    }: t_mutationWithError_value,
                  )
                | None => None
                };
              },
              errors: {
                let value = (value: Raw.t_mutationWithError).errors;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map((value) =>
                         (
                           {
                             field: {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).field;
                               switch (Obj.magic(value: string)) {
                               | \\"FIRST\\" => \`FIRST
                               | \\"SECOND\\" => \`SECOND
                               | \\"THIRD\\" => \`THIRD
                               | other => \`FutureAddedValue(other)
                               };
                             },
                             message: {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).
                                   message;
                               value;
                             },
                           }: t_mutationWithError_errors
                         )
                       ),
                  )
                | None => None
                };
              },
            }: t_mutationWithError
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let mutationWithError = {
          let value = (value: t).mutationWithError;
          (
            {
              let errors = {
                let value = (value: t_mutationWithError).errors;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map((value) =>
                         (
                           {
                             let message = {
                               let value =
                                 (value: t_mutationWithError_errors).message;
                               value;
                             }
                             and field = {
                               let value =
                                 (value: t_mutationWithError_errors).field;
                               switch (value) {
                               | \`FIRST => \\"FIRST\\"
                               | \`SECOND => \\"SECOND\\"
                               | \`THIRD => \\"THIRD\\"
                               | \`FutureAddedValue(other) => other
                               };
                             };
                             {field, message};
                           }: Raw.t_mutationWithError_errors
                         )
                       ),
                  )
                | None => Js.Nullable.null
                };
              }
              and value = {
                let value = (value: t_mutationWithError).value;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {
                      let stringField = {
                        let value =
                          (value: t_mutationWithError_value).stringField;
                        value;
                      };
                      {stringField: stringField};
                    }: Raw.t_mutationWithError_value,
                  )
                | None => Js.Nullable.null
                };
              };
              {value, errors};
            }: Raw.t_mutationWithError
          );
        };
        {mutationWithError: mutationWithError};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records mutationWithArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {optionalInputArgs: string};
    type t_variables = {required: string};
  };
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t = {optionalInputArgs: string};
  type t_variables = {required: string};
  let parse: Raw.t => t =
    (value) => (
      {
        optionalInputArgs: {
          let value = (value: Raw.t).optionalInputArgs;
          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let optionalInputArgs = {
          let value = (value: t).optionalInputArgs;
          value;
        };
        {optionalInputArgs: optionalInputArgs};
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {required: (a => a)((inp: t_variables).required)};
  let makeVariables = (~required, ()) =>
    serializeVariables({required: required}: t_variables);
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records mutationWithArgsAndNoRecords.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"optionalInputArgs\\": string};
    type t_variables = {. \\"required\\": string};
  };
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t = {. \\"optionalInputArgs\\": string};
  type t_variables = {. \\"required\\": string};
  let parse: Raw.t => t =
    value => {
      let optionalInputArgs = {
        let value = value##optionalInputArgs;
        value;
      };
      {\\"optionalInputArgs\\": optionalInputArgs};
    };
  let serialize: t => Raw.t =
    value => {
      let optionalInputArgs = {
        let value = value##optionalInputArgs;
        value;
      };
      {\\"optionalInputArgs\\": optionalInputArgs};
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"required\\": (a => a)(inp##required)};
  let makeVariables = (~required, ()) =>
    serializeVariables({\\"required\\": required}: t_variables);
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records nested.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type record = {
  f1: string,
  f2: string,
};
module MyQuery = {
  module Raw = {
    type t_first_inner_inner = {field: string};
    type t_first_inner = {inner: Js.Nullable.t(t_first_inner_inner)};
    type t_first = {inner: Js.Nullable.t(t_first_inner)};
    type t_second_inner_inner = {
      f1: string,
      f2: string,
    };
    type t_second_inner = {inner: Js.Nullable.t(t_second_inner_inner)};
    type t_second = {inner: Js.Nullable.t(t_second_inner)};
    type t_let_inner_inner = {field: string};
    type t_let_inner = {inner: Js.Nullable.t(t_let_inner_inner)};
    type t_let = {inner: Js.Nullable.t(t_let_inner)};
    type t = {
      first: t_first,
      second: t_second,
      let_: t_let,
    };
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nsecond: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nf1: field  \\\\nf2: field  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nlet: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_first_inner_inner = {field: string};
  type t_first_inner = {inner: option(t_first_inner_inner)};
  type t_first = {inner: option(t_first_inner)};
  type t_second_inner_inner = {
    f1: string,
    f2: string,
  };
  type t_second_inner = {inner: option(t_second_inner_inner)};
  type t_second = {inner: option(t_second_inner)};
  type t_let_inner_inner = {field: string};
  type t_let_inner = {inner: option(t_let_inner_inner)};
  type t_let = {inner: option(t_let_inner)};
  type t = {
    first: t_first,
    second: t_second,
    let_: t_let,
  };
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        first: {
          let value = (value: Raw.t).first;
          (
            {
              inner: {
                let value = (value: Raw.t_first).inner;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {
                      inner: {
                        let value = (value: Raw.t_first_inner).inner;
                        switch (Js.toOption(value)) {
                        | Some(value) =>
                          Some(
                            {
                              field: {
                                let value =
                                  (value: Raw.t_first_inner_inner).field;
                                value;
                              },
                            }: t_first_inner_inner,
                          )
                        | None => None
                        };
                      },
                    }: t_first_inner,
                  )
                | None => None
                };
              },
            }: t_first
          );
        },
        second: {
          let value = (value: Raw.t).second;
          (
            {
              inner: {
                let value = (value: Raw.t_second).inner;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {
                      inner: {
                        let value = (value: Raw.t_second_inner).inner;
                        switch (Js.toOption(value)) {
                        | Some(value) =>
                          Some(
                            {
                              f1: {
                                let value =
                                  (value: Raw.t_second_inner_inner).f1;
                                value;
                              },
                              f2: {
                                let value =
                                  (value: Raw.t_second_inner_inner).f2;
                                value;
                              },
                            }: t_second_inner_inner,
                          )
                        | None => None
                        };
                      },
                    }: t_second_inner,
                  )
                | None => None
                };
              },
            }: t_second
          );
        },
        let_: {
          let value = (value: Raw.t).let_;
          (
            {
              inner: {
                let value = (value: Raw.t_let).inner;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {
                      inner: {
                        let value = (value: Raw.t_let_inner).inner;
                        switch (Js.toOption(value)) {
                        | Some(value) =>
                          Some(
                            {
                              field: {
                                let value =
                                  (value: Raw.t_let_inner_inner).field;
                                value;
                              },
                            }: t_let_inner_inner,
                          )
                        | None => None
                        };
                      },
                    }: t_let_inner,
                  )
                | None => None
                };
              },
            }: t_let
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let let_ = {
          let value = (value: t).let_;
          (
            {
              let inner = {
                let value = (value: t_let).inner;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {
                      let inner = {
                        let value = (value: t_let_inner).inner;
                        switch (value) {
                        | Some(value) =>
                          Js.Nullable.return(
                            {
                              let field = {
                                let value = (value: t_let_inner_inner).field;
                                value;
                              };
                              {field: field};
                            }: Raw.t_let_inner_inner,
                          )
                        | None => Js.Nullable.null
                        };
                      };
                      {inner: inner};
                    }: Raw.t_let_inner,
                  )
                | None => Js.Nullable.null
                };
              };
              {inner: inner};
            }: Raw.t_let
          );
        }
        and second = {
          let value = (value: t).second;
          (
            {
              let inner = {
                let value = (value: t_second).inner;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {
                      let inner = {
                        let value = (value: t_second_inner).inner;
                        switch (value) {
                        | Some(value) =>
                          Js.Nullable.return(
                            {
                              let f2 = {
                                let value = (value: t_second_inner_inner).f2;
                                value;
                              }
                              and f1 = {
                                let value = (value: t_second_inner_inner).f1;
                                value;
                              };
                              {f1, f2};
                            }: Raw.t_second_inner_inner,
                          )
                        | None => Js.Nullable.null
                        };
                      };
                      {inner: inner};
                    }: Raw.t_second_inner,
                  )
                | None => Js.Nullable.null
                };
              };
              {inner: inner};
            }: Raw.t_second
          );
        }
        and first = {
          let value = (value: t).first;
          (
            {
              let inner = {
                let value = (value: t_first).inner;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {
                      let inner = {
                        let value = (value: t_first_inner).inner;
                        switch (value) {
                        | Some(value) =>
                          Js.Nullable.return(
                            {
                              let field = {
                                let value = (value: t_first_inner_inner).field;
                                value;
                              };
                              {field: field};
                            }: Raw.t_first_inner_inner,
                          )
                        | None => Js.Nullable.null
                        };
                      };
                      {inner: inner};
                    }: Raw.t_first_inner,
                  )
                | None => Js.Nullable.null
                };
              };
              {inner: inner};
            }: Raw.t_first
          );
        };
        {first, second, let_};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records nonrecursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {nonrecursiveInput: string};
    type t_variables = {arg: t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      nonNullableField: string,
      nullableArray: Js.Nullable.t(array(Js.Nullable.t(string))),
      field: Js.Nullable.t(string),
      enum: Js.Nullable.t(string),
      embeddedInput:
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
      custom: Js.Nullable.t(Js.Json.t),
    }
    and t_variables_EmbeddedInput = {field: Js.Nullable.t(string)};
  };
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {nonrecursiveInput: string};
  type t_variables = {arg: t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    nonNullableField: string,
    nullableArray: option(array(option(string))),
    field: option(string),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
    embeddedInput: option(array(option(t_variables_EmbeddedInput))),
    custom: option(Js.Json.t),
  }
  and t_variables_EmbeddedInput = {field: option(string)};
  let parse: Raw.t => t =
    (value) => (
      {
        nonrecursiveInput: {
          let value = (value: Raw.t).nonrecursiveInput;
          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let nonrecursiveInput = {
          let value = (value: t).nonrecursiveInput;
          value;
        };
        {nonrecursiveInput: nonrecursiveInput};
      }: Raw.t
    );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (a => serializeInputObjectNonrecursiveInput(a))(
          (inp: t_variables).arg,
        ),
    }
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {
      nonNullableField:
        (a => a)((inp: t_variables_NonrecursiveInput).nonNullableField),
      nullableArray:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).nullableArray,
        ),
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).field,
        ),
      enum:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).enum,
        ),
      embeddedInput:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).embeddedInput,
        ),
      custom:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).custom,
        ),
    }
  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_EmbeddedInput).field,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables)
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        ~custom=?,
        (),
      )
      : t_variables_NonrecursiveInput => {
    nonNullableField,
    nullableArray,
    field,
    enum,
    embeddedInput,
    custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {
    field: field,
  };
  module Z__INTERNAL = {
    type nonrec _graphql_arg_100;
    /**Variable **$arg** has the following graphql type:

\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}!
\`\`\`*/
    let _graphql_arg_100: _graphql_arg_100 = Obj.magic(0);
    type nonrec _graphql_arg_95;
    /**Argument **arg** on field **nonrecursiveInput** has the following graphql type:

\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}!
\`\`\`*/
    let _graphql_arg_95: _graphql_arg_95 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_NonrecursiveInput_49;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_49: _graphql_NonrecursiveInput_49 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery2 = {
  module Raw = {
    type t = {
      scalarsInput: string,
      more: string,
    };
    type t_variables = {
      arg: t_variables_NonrecursiveInput,
      arg2: t_variables_NonrecursiveInput,
    }
    and t_variables_NonrecursiveInput = {
      nonNullableField: string,
      nullableArray: Js.Nullable.t(array(Js.Nullable.t(string))),
      field: Js.Nullable.t(string),
      enum: Js.Nullable.t(string),
      embeddedInput:
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
      custom: Js.Nullable.t(Js.Json.t),
    }
    and t_variables_EmbeddedInput = {field: Js.Nullable.t(string)};
  };
  let query = \\"query ($arg: NonrecursiveInput!, $arg2: NonrecursiveInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\nmore: scalarsInput(arg: $arg2)  \\\\n}\\\\n\\";
  type t = {
    scalarsInput: string,
    more: string,
  };
  type t_variables = {
    arg: t_variables_NonrecursiveInput,
    arg2: t_variables_NonrecursiveInput,
  }
  and t_variables_NonrecursiveInput = {
    nonNullableField: string,
    nullableArray: option(array(option(string))),
    field: option(string),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
    embeddedInput: option(array(option(t_variables_EmbeddedInput))),
    custom: option(Js.Json.t),
  }
  and t_variables_EmbeddedInput = {field: option(string)};
  let parse: Raw.t => t =
    (value) => (
      {
        scalarsInput: {
          let value = (value: Raw.t).scalarsInput;
          value;
        },
        more: {
          let value = (value: Raw.t).more;
          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let more = {
          let value = (value: t).more;
          value;
        }
        and scalarsInput = {
          let value = (value: t).scalarsInput;
          value;
        };
        {scalarsInput, more};
      }: Raw.t
    );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (a => serializeInputObjectNonrecursiveInput(a))(
          (inp: t_variables).arg,
        ),
      arg2:
        (a => serializeInputObjectNonrecursiveInput(a))(
          (inp: t_variables).arg2,
        ),
    }
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {
      nonNullableField:
        (a => a)((inp: t_variables_NonrecursiveInput).nonNullableField),
      nullableArray:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).nullableArray,
        ),
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).field,
        ),
      enum:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).enum,
        ),
      embeddedInput:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).embeddedInput,
        ),
      custom:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).custom,
        ),
    }
  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_EmbeddedInput).field,
        ),
    };
  let makeVariables = (~arg, ~arg2, ()) =>
    serializeVariables({arg, arg2}: t_variables)
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        ~custom=?,
        (),
      )
      : t_variables_NonrecursiveInput => {
    nonNullableField,
    nullableArray,
    field,
    enum,
    embeddedInput,
    custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {
    field: field,
  };
  module Z__INTERNAL = {
    type nonrec _graphql_arg_240;
    /**Variable **$arg** has the following graphql type:

\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}!
\`\`\`*/
    let _graphql_arg_240: _graphql_arg_240 = Obj.magic(0);
    type nonrec _graphql_arg_235;
    /**Argument **arg** on field **scalarsInput** has the following graphql type:

\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}!
\`\`\`*/
    let _graphql_arg_235: _graphql_arg_235 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_NonrecursiveInput_169;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_169: _graphql_NonrecursiveInput_169 =
      Obj.magic(0);
    type nonrec _graphql_NonrecursiveInput_196;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_196: _graphql_NonrecursiveInput_196 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery2 {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records omitFutureValueEnum.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Normal = {
  module Raw = {
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      message: string,
      field: t_mutationWithError_errors_field,
    };
    type t_mutationWithError = {
      errors: Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {mutationWithError: t_mutationWithError};
    type t_variables = Js.Json.t;
  };
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_mutationWithError_errors_field = [
    | \`FutureAddedValue(string)
    | \`FIRST
    | \`SECOND
    | \`THIRD
  ];
  type t_mutationWithError_errors = {
    message: string,
    field: t_mutationWithError_errors_field,
  };
  type t_mutationWithError = {
    errors: option(array(t_mutationWithError_errors)),
  };
  type t = {mutationWithError: t_mutationWithError};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        mutationWithError: {
          let value = (value: Raw.t).mutationWithError;
          (
            {
              errors: {
                let value = (value: Raw.t_mutationWithError).errors;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map((value) =>
                         (
                           {
                             message: {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).
                                   message;
                               value;
                             },
                             field: {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).field;
                               switch (Obj.magic(value: string)) {
                               | \\"FIRST\\" => \`FIRST
                               | \\"SECOND\\" => \`SECOND
                               | \\"THIRD\\" => \`THIRD
                               | other => \`FutureAddedValue(other)
                               };
                             },
                           }: t_mutationWithError_errors
                         )
                       ),
                  )
                | None => None
                };
              },
            }: t_mutationWithError
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let mutationWithError = {
          let value = (value: t).mutationWithError;
          (
            {
              let errors = {
                let value = (value: t_mutationWithError).errors;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map((value) =>
                         (
                           {
                             let field = {
                               let value =
                                 (value: t_mutationWithError_errors).field;
                               switch (value) {
                               | \`FIRST => \\"FIRST\\"
                               | \`SECOND => \\"SECOND\\"
                               | \`THIRD => \\"THIRD\\"
                               | \`FutureAddedValue(other) => other
                               };
                             }
                             and message = {
                               let value =
                                 (value: t_mutationWithError_errors).message;
                               value;
                             };
                             {message, field};
                           }: Raw.t_mutationWithError_errors
                         )
                       ),
                  )
                | None => Js.Nullable.null
                };
              };
              {errors: errors};
            }: Raw.t_mutationWithError
          );
        };
        {mutationWithError: mutationWithError};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module Normal {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByConfig = {
  module Raw = {
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      message: string,
      field: t_mutationWithError_errors_field,
    };
    type t_mutationWithError = {
      errors: Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {mutationWithError: t_mutationWithError};
    type t_variables = Js.Json.t;
  };
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_mutationWithError_errors_field = [ | \`FIRST | \`SECOND | \`THIRD];
  type t_mutationWithError_errors = {
    message: string,
    field: t_mutationWithError_errors_field,
  };
  type t_mutationWithError = {
    errors: option(array(t_mutationWithError_errors)),
  };
  type t = {mutationWithError: t_mutationWithError};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        mutationWithError: {
          let value = (value: Raw.t).mutationWithError;
          (
            {
              errors: {
                let value = (value: Raw.t_mutationWithError).errors;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map((value) =>
                         (
                           {
                             message: {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).
                                   message;
                               value;
                             },
                             field: {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).field;
                               switch (Obj.magic(value: string)) {
                               | \\"FIRST\\" => \`FIRST
                               | \\"SECOND\\" => \`SECOND
                               | \\"THIRD\\" => \`THIRD
                               | _ => raise(Not_found)
                               };
                             },
                           }: t_mutationWithError_errors
                         )
                       ),
                  )
                | None => None
                };
              },
            }: t_mutationWithError
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let mutationWithError = {
          let value = (value: t).mutationWithError;
          (
            {
              let errors = {
                let value = (value: t_mutationWithError).errors;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map((value) =>
                         (
                           {
                             let field = {
                               let value =
                                 (value: t_mutationWithError_errors).field;
                               switch (value) {
                               | \`FIRST => \\"FIRST\\"
                               | \`SECOND => \\"SECOND\\"
                               | \`THIRD => \\"THIRD\\"
                               };
                             }
                             and message = {
                               let value =
                                 (value: t_mutationWithError_errors).message;
                               value;
                             };
                             {message, field};
                           }: Raw.t_mutationWithError_errors
                         )
                       ),
                  )
                | None => Js.Nullable.null
                };
              };
              {errors: errors};
            }: Raw.t_mutationWithError
          );
        };
        {mutationWithError: mutationWithError};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByConfig {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByDirective = {
  module Raw = {
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      message: string,
      field: t_mutationWithError_errors_field,
    };
    type t_mutationWithError = {
      errors: Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {mutationWithError: t_mutationWithError};
    type t_variables = Js.Json.t;
  };
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield @ppxOmitFutureValue \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_mutationWithError_errors_field = [ | \`FIRST | \`SECOND | \`THIRD];
  type t_mutationWithError_errors = {
    message: string,
    field: t_mutationWithError_errors_field,
  };
  type t_mutationWithError = {
    errors: option(array(t_mutationWithError_errors)),
  };
  type t = {mutationWithError: t_mutationWithError};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        mutationWithError: {
          let value = (value: Raw.t).mutationWithError;
          (
            {
              errors: {
                let value = (value: Raw.t_mutationWithError).errors;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map((value) =>
                         (
                           {
                             message: {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).
                                   message;
                               value;
                             },
                             field: {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).field;
                               switch (Obj.magic(value: string)) {
                               | \\"FIRST\\" => \`FIRST
                               | \\"SECOND\\" => \`SECOND
                               | \\"THIRD\\" => \`THIRD
                               | _ => raise(Not_found)
                               };
                             },
                           }: t_mutationWithError_errors
                         )
                       ),
                  )
                | None => None
                };
              },
            }: t_mutationWithError
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let mutationWithError = {
          let value = (value: t).mutationWithError;
          (
            {
              let errors = {
                let value = (value: t_mutationWithError).errors;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map((value) =>
                         (
                           {
                             let field = {
                               let value =
                                 (value: t_mutationWithError_errors).field;
                               switch (value) {
                               | \`FIRST => \\"FIRST\\"
                               | \`SECOND => \\"SECOND\\"
                               | \`THIRD => \\"THIRD\\"
                               };
                             }
                             and message = {
                               let value =
                                 (value: t_mutationWithError_errors).message;
                               value;
                             };
                             {message, field};
                           }: Raw.t_mutationWithError_errors
                         )
                       ),
                  )
                | None => Js.Nullable.null
                };
              };
              {errors: errors};
            }: Raw.t_mutationWithError
          );
        };
        {mutationWithError: mutationWithError};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByDirective {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records omitFutureValueUnion.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Normal = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {name: string};
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        dogOrHuman: {
          let value = (value: Raw.t).dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                  (
                    {
                      name: {
                        let value = (value: Raw.t_dogOrHuman_Dog).name;
                        value;
                      },
                      barkVolume: {
                        let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                        value;
                      },
                    }: t_dogOrHuman_Dog
                  );
                },
              )
            | \\"Human\\" =>
              \`Human(
                {
                  let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                  (
                    {
                      name: {
                        let value = (value: Raw.t_dogOrHuman_Human).name;
                        value;
                      },
                    }: t_dogOrHuman_Human
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: t).dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {
                  let barkVolume = {
                    let value = (value: t_dogOrHuman_Dog).barkVolume;
                    value;
                  }
                  and name = {
                    let value = (value: t_dogOrHuman_Dog).name;
                    value;
                  };
                  {__typename: \\"Dog\\", name, barkVolume};
                }: Raw.t_dogOrHuman_Dog,
              ): Raw.t_dogOrHuman
            )
          | \`Human(value) => (
              Obj.magic(
                {
                  let name = {
                    let value = (value: t_dogOrHuman_Human).name;
                    value;
                  };
                  {__typename: \\"Human\\", name};
                }: Raw.t_dogOrHuman_Human,
              ): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        };
        {dogOrHuman: dogOrHuman};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module Normal {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByConfig = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {name: string};
  type t_dogOrHuman = [
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        dogOrHuman: {
          let value = (value: Raw.t).dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                  (
                    {
                      name: {
                        let value = (value: Raw.t_dogOrHuman_Dog).name;
                        value;
                      },
                      barkVolume: {
                        let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                        value;
                      },
                    }: t_dogOrHuman_Dog
                  );
                },
              )
            | \\"Human\\" =>
              \`Human(
                {
                  let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                  (
                    {
                      name: {
                        let value = (value: Raw.t_dogOrHuman_Human).name;
                        value;
                      },
                    }: t_dogOrHuman_Human
                  );
                },
              )
            | _ => raise(Not_found)
            }: t_dogOrHuman
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: t).dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {
                  let barkVolume = {
                    let value = (value: t_dogOrHuman_Dog).barkVolume;
                    value;
                  }
                  and name = {
                    let value = (value: t_dogOrHuman_Dog).name;
                    value;
                  };
                  {__typename: \\"Dog\\", name, barkVolume};
                }: Raw.t_dogOrHuman_Dog,
              ): Raw.t_dogOrHuman
            )
          | \`Human(value) => (
              Obj.magic(
                {
                  let name = {
                    let value = (value: t_dogOrHuman_Human).name;
                    value;
                  };
                  {__typename: \\"Human\\", name};
                }: Raw.t_dogOrHuman_Human,
              ): Raw.t_dogOrHuman
            )
          };
        };
        {dogOrHuman: dogOrHuman};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByConfig {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByDirective = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndogOrHuman @ppxOmitFutureValue {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {name: string};
  type t_dogOrHuman = [
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        dogOrHuman: {
          let value = (value: Raw.t).dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                  (
                    {
                      name: {
                        let value = (value: Raw.t_dogOrHuman_Dog).name;
                        value;
                      },
                      barkVolume: {
                        let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                        value;
                      },
                    }: t_dogOrHuman_Dog
                  );
                },
              )
            | \\"Human\\" =>
              \`Human(
                {
                  let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                  (
                    {
                      name: {
                        let value = (value: Raw.t_dogOrHuman_Human).name;
                        value;
                      },
                    }: t_dogOrHuman_Human
                  );
                },
              )
            | _ => raise(Not_found)
            }: t_dogOrHuman
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: t).dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {
                  let barkVolume = {
                    let value = (value: t_dogOrHuman_Dog).barkVolume;
                    value;
                  }
                  and name = {
                    let value = (value: t_dogOrHuman_Dog).name;
                    value;
                  };
                  {__typename: \\"Dog\\", name, barkVolume};
                }: Raw.t_dogOrHuman_Dog,
              ): Raw.t_dogOrHuman
            )
          | \`Human(value) => (
              Obj.magic(
                {
                  let name = {
                    let value = (value: t_dogOrHuman_Human).name;
                    value;
                  };
                  {__typename: \\"Human\\", name};
                }: Raw.t_dogOrHuman_Human,
              ): Raw.t_dogOrHuman
            )
          };
        };
        {dogOrHuman: dogOrHuman};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByDirective {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records pokedexApolloMode.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_pokemon = {
      id: string,
      name: Js.Nullable.t(string),
    };
    type t = {pokemon: Js.Nullable.t(t_pokemon)};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\npokemon(name: \\\\\\"Pikachu\\\\\\")  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_pokemon = {
    id: string,
    name: option(string),
  };
  type t = {pokemon: option(t_pokemon)};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        pokemon: {
          let value = (value: Raw.t).pokemon;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {
                id: {
                  let value = (value: Raw.t_pokemon).id;
                  value;
                },
                name: {
                  let value = (value: Raw.t_pokemon).name;
                  switch (Js.toOption(value)) {
                  | Some(value) => Some(value)
                  | None => None
                  };
                },
              }: t_pokemon,
            )
          | None => None
          };
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let pokemon = {
          let value = (value: t).pokemon;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {
                let name = {
                  let value = (value: t_pokemon).name;
                  switch (value) {
                  | Some(value) => Js.Nullable.return(value)
                  | None => Js.Nullable.null
                  };
                }
                and id = {
                  let value = (value: t_pokemon).id;
                  value;
                };
                {id, name};
              }: Raw.t_pokemon,
            )
          | None => Js.Nullable.null
          };
        };
        {pokemon: pokemon};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type nonrec _graphql_name_52;
    /**Argument **name** on field **pokemon** has the following graphql type:

\`\`\`
String
\`\`\`*/
    let _graphql_name_52: _graphql_name_52 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records pokedexScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_pokemon = {
      id: string,
      name: Js.Nullable.t(string),
    };
    type t = {pokemon: Js.Nullable.t(t_pokemon)};
    type t_variables = {
      id: Js.Nullable.t(string),
      name: Js.Nullable.t(string),
    };
  };
  let query = \\"query pokemon($id: String, $name: String)  {\\\\npokemon(name: $name, id: $id)  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_pokemon = {
    id: string,
    name: option(string),
  };
  type t = {pokemon: option(t_pokemon)};
  type t_variables = {
    id: option(string),
    name: option(string),
  };
  let parse: Raw.t => t =
    (value) => (
      {
        pokemon: {
          let value = (value: Raw.t).pokemon;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {
                id: {
                  let value = (value: Raw.t_pokemon).id;
                  value;
                },
                name: {
                  let value = (value: Raw.t_pokemon).name;
                  switch (Js.toOption(value)) {
                  | Some(value) => Some(value)
                  | None => None
                  };
                },
              }: t_pokemon,
            )
          | None => None
          };
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let pokemon = {
          let value = (value: t).pokemon;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {
                let name = {
                  let value = (value: t_pokemon).name;
                  switch (value) {
                  | Some(value) => Js.Nullable.return(value)
                  | None => Js.Nullable.null
                  };
                }
                and id = {
                  let value = (value: t_pokemon).id;
                  value;
                };
                {id, name};
              }: Raw.t_pokemon,
            )
          | None => Js.Nullable.null
          };
        };
        {pokemon: pokemon};
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      id:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).id,
        ),
      name:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).name,
        ),
    };
  let makeVariables = (~id=?, ~name=?, ()) =>
    serializeVariables({id, name}: t_variables);
  module Z__INTERNAL = {
    type nonrec _graphql_name_100;
    /**Variable **$name** has the following graphql type:

\`\`\`
String
\`\`\`*/
    let _graphql_name_100: _graphql_name_100 = Obj.magic(0);
    type nonrec _graphql_name_94;
    /**Argument **name** on field **pokemon** has the following graphql type:

\`\`\`
String
\`\`\`*/
    let _graphql_name_94: _graphql_name_94 = Obj.magic(0);
    type nonrec _graphql_id_111;
    /**Variable **$id** has the following graphql type:

\`\`\`
String
\`\`\`*/
    let _graphql_id_111: _graphql_id_111 = Obj.magic(0);
    type nonrec _graphql_id_107;
    /**Argument **id** on field **pokemon** has the following graphql type:

\`\`\`
String
\`\`\`*/
    let _graphql_id_107: _graphql_id_107 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type scalars = {
  string,
  int,
};

type dog = {
  name: string,
  barkVolume: float,
};

type oneFieldQuery = {nullableString: option(string)};
module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      string,
      int,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {variousScalars: scalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {
              string: {
                let value = (value: Raw.t_variousScalars).string;
                value;
              },
              int: {
                let value = (value: Raw.t_variousScalars).int;
                value;
              },
            }: scalars
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let int = {
                let value = (value: scalars).int;
                value;
              }
              and string = {
                let value = (value: scalars).string;
                value;
              };
              {string, int};
            }: Raw.t_variousScalars
          );
        };
        {variousScalars: variousScalars};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module OneFieldQuery = {
  module Raw = {
    type t_variousScalars = {nullableString: Js.Nullable.t(string)};
    type t = {variousScalars: t_variousScalars};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {nullableString: option(string)};
  type t = {variousScalars: t_variousScalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {
              nullableString: {
                let value = (value: Raw.t_variousScalars).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
            }: t_variousScalars
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let nullableString = {
                let value = (value: t_variousScalars).nullableString;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              };
              {nullableString: nullableString};
            }: Raw.t_variousScalars
          );
        };
        {variousScalars: variousScalars};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module OneFieldQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ExternalFragmentQuery = {
  module Fragment = {
    let query = \\"fragment Fragment on VariousScalars   {\\\\nstring  \\\\nint  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        string,
        int,
      };
      type nonrec t_VariousScalars = t;
    };
    type t = {
      string,
      int,
    };
    type nonrec t_VariousScalars = t;
    let parse = (value: Raw.t): t => {
      string: {
        let value = (value: Raw.t).string;
        value;
      },
      int: {
        let value = (value: Raw.t).int;
        value;
      },
    };
    let serialize: t => Raw.t =
      (value) => (
        {
          let int = {
            let value = (value: t).int;
            value;
          }
          and string = {
            let value = (value: t).string;
            value;
          };
          {string, int};
        }: Raw.t
      );
    let name = \\"Fragment\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql;
      /**\`\`\`
VariousScalars {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}
\`\`\`*/
      let graphql: graphql = Obj.magic(0);
      type nonrec graphql_module;
      /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ExternalFragmentQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  module Untitled1 = {
    module Raw = {
      type t = {variousScalars: Fragment.Raw.t};
      type t_variables = Js.Json.t;
    };
    let query =
      (
        (\\"query   {\\\\nvariousScalars  {\\\\n...\\" ++ Fragment.name)
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ Fragment.query;
    type t = {variousScalars: Fragment.t};
    type t_variables = Js.Json.t;
    let parse: Raw.t => t =
      (value) => (
        {
          variousScalars: {
            let value = (value: Raw.t).variousScalars;
            Fragment.parse(value);
          },
        }: t
      );
    let serialize: t => Raw.t =
      (value) => (
        {
          let variousScalars = {
            let value = (value: t).variousScalars;
            Fragment.serialize(value);
          };
          {variousScalars: variousScalars};
        }: Raw.t
      );
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql_module;
      /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ExternalFragmentQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
};
module InlineFragmentQuery = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        dogOrHuman: {
          let value = (value: Raw.t).dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                  (
                    {
                      name: {
                        let value = (value: Raw.t_dogOrHuman_Dog).name;
                        value;
                      },
                      barkVolume: {
                        let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                        value;
                      },
                    }: t_dogOrHuman_Dog
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: t).dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {
                  let barkVolume = {
                    let value = (value: t_dogOrHuman_Dog).barkVolume;
                    value;
                  }
                  and name = {
                    let value = (value: t_dogOrHuman_Dog).name;
                    value;
                  };
                  {__typename: \\"Dog\\", name, barkVolume};
                }: Raw.t_dogOrHuman_Dog,
              ): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        };
        {dogOrHuman: dogOrHuman};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module InlineFragmentQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module UnionExternalFragmentQuery = {
  module DogFragment = {
    let query = \\"fragment DogFragment on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        name: string,
        barkVolume: float,
      };
      type nonrec t_Dog = t;
    };
    type t = {
      name: string,
      barkVolume: float,
    };
    type nonrec t_Dog = t;
    let parse = (value: Raw.t): t => {
      name: {
        let value = (value: Raw.t).name;
        value;
      },
      barkVolume: {
        let value = (value: Raw.t).barkVolume;
        value;
      },
    };
    let serialize: t => Raw.t =
      (value) => (
        {
          let barkVolume = {
            let value = (value: t).barkVolume;
            value;
          }
          and name = {
            let value = (value: t).name;
            value;
          };
          {name, barkVolume};
        }: Raw.t
      );
    let name = \\"DogFragment\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql;
      /**\`\`\`
Dog {
  name: String!
  barkVolume: Float!
}
\`\`\`*/
      let graphql: graphql = Obj.magic(0);
      type nonrec graphql_module;
      /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module UnionExternalFragmentQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  module Untitled1 = {
    module Raw = {
      type t_dogOrHuman;
      type t = {dogOrHuman: t_dogOrHuman};
      type t_variables = Js.Json.t;
    };
    let query =
      (
        (
          \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n...\\"
          ++ DogFragment.name
        )
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ DogFragment.query;
    type t_dogOrHuman = [
      | \`FutureAddedValue(Js.Json.t)
      | \`Dog(DogFragment.t)
    ];
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = Js.Json.t;
    let parse: Raw.t => t =
      (value) => (
        {
          dogOrHuman: {
            let value = (value: Raw.t).dogOrHuman;
            let typename: string =
              Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
            (
              switch (typename) {
              | \\"Dog\\" =>
                \`Dog(
                  {
                    let value: DogFragment.Raw.t = Obj.magic(value);
                    DogFragment.parse(value);
                  },
                )
              | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
              }: t_dogOrHuman
            );
          },
        }: t
      );
    let serialize: t => Raw.t =
      (value) => (
        {
          let dogOrHuman = {
            let value = (value: t).dogOrHuman;
            switch (value) {
            | \`Dog(value) => (
                Obj.magic(DogFragment.serialize(value)): Raw.t_dogOrHuman
              )
            | \`FutureAddedValue(value) => (
                Obj.magic(value): Raw.t_dogOrHuman
              )
            };
          };
          {dogOrHuman: dogOrHuman};
        }: Raw.t
      );
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql_module;
      /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module UnionExternalFragmentQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
};
"
`;

exports[`Records recursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {recursiveInput: string};
    type t_variables = {arg: t_variables_RecursiveInput}
    and t_variables_RecursiveInput = {
      otherField: Js.Nullable.t(string),
      inner: Js.Nullable.t(t_variables_RecursiveInput),
      enum: Js.Nullable.t(string),
    };
  };
  let query = \\"query ($arg: RecursiveInput!)  {\\\\nrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {recursiveInput: string};
  type t_variables = {arg: t_variables_RecursiveInput}
  and t_variables_RecursiveInput = {
    otherField: option(string),
    inner: option(t_variables_RecursiveInput),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  let parse: Raw.t => t =
    (value) => (
      {
        recursiveInput: {
          let value = (value: Raw.t).recursiveInput;
          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let recursiveInput = {
          let value = (value: t).recursiveInput;
          value;
        };
        {recursiveInput: recursiveInput};
      }: Raw.t
    );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (a => serializeInputObjectRecursiveInput(a))((inp: t_variables).arg),
    }
  and serializeInputObjectRecursiveInput:
    t_variables_RecursiveInput => Raw.t_variables_RecursiveInput =
    inp => {
      otherField:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_RecursiveInput).otherField,
        ),
      inner:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (a => serializeInputObjectRecursiveInput(a))(b),
              )
            }
        )(
          (inp: t_variables_RecursiveInput).inner,
        ),
      enum:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_RecursiveInput).enum,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables)
  and makeInputObjectRecursiveInput =
      (~otherField=?, ~inner=?, ~enum=?, ()): t_variables_RecursiveInput => {
    otherField,
    inner,
    enum,
  };
  module Z__INTERNAL = {
    type nonrec _graphql_arg_90;
    /**Variable **$arg** has the following graphql type:

\`\`\`
RecursiveInput {
  otherField: String
  inner: RecursiveInput
  enum: SampleField
}!
\`\`\`*/
    let _graphql_arg_90: _graphql_arg_90 = Obj.magic(0);
    type nonrec _graphql_arg_85;
    /**Argument **arg** on field **recursiveInput** has the following graphql type:

\`\`\`
RecursiveInput {
  otherField: String
  inner: RecursiveInput
  enum: SampleField
}!
\`\`\`*/
    let _graphql_arg_85: _graphql_arg_85 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_RecursiveInput_47;
    /**\`\`\`
RecursiveInput {
  otherField: String
  inner: RecursiveInput
  enum: SampleField
}
\`\`\`*/
    let _graphql_RecursiveInput_47: _graphql_RecursiveInput_47 = Obj.magic(0);
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records scalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {
              nullableString: {
                let value = (value: Raw.t_variousScalars).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              string: {
                let value = (value: Raw.t_variousScalars).string;
                value;
              },
              nullableInt: {
                let value = (value: Raw.t_variousScalars).nullableInt;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              int: {
                let value = (value: Raw.t_variousScalars).int;
                value;
              },
              nullableFloat: {
                let value = (value: Raw.t_variousScalars).nullableFloat;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              float: {
                let value = (value: Raw.t_variousScalars).float;
                value;
              },
              nullableBoolean: {
                let value = (value: Raw.t_variousScalars).nullableBoolean;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              boolean: {
                let value = (value: Raw.t_variousScalars).boolean;
                value;
              },
              nullableID: {
                let value = (value: Raw.t_variousScalars).nullableID;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              id: {
                let value = (value: Raw.t_variousScalars).id;
                value;
              },
            }: t_variousScalars
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let id = {
                let value = (value: t_variousScalars).id;
                value;
              }
              and nullableID = {
                let value = (value: t_variousScalars).nullableID;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and boolean = {
                let value = (value: t_variousScalars).boolean;
                value;
              }
              and nullableBoolean = {
                let value = (value: t_variousScalars).nullableBoolean;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and float = {
                let value = (value: t_variousScalars).float;
                value;
              }
              and nullableFloat = {
                let value = (value: t_variousScalars).nullableFloat;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and int = {
                let value = (value: t_variousScalars).int;
                value;
              }
              and nullableInt = {
                let value = (value: t_variousScalars).nullableInt;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and string = {
                let value = (value: t_variousScalars).string;
                value;
              }
              and nullableString = {
                let value = (value: t_variousScalars).nullableString;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              };
              {
                nullableString,
                string,
                nullableInt,
                int,
                nullableFloat,
                float,
                nullableBoolean,
                boolean,
                nullableID,
                id,
              };
            }: Raw.t_variousScalars
          );
        };
        {variousScalars: variousScalars};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records scalarsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {scalarsInput: string};
    type t_variables = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
  };
  let query = \\"query ($nullableString: String, $string: String!, $nullableInt: Int, $int: Int!, $nullableFloat: Float, $float: Float!, $nullableBoolean: Boolean, $boolean: Boolean!, $nullableID: ID, $id: ID!)  {\\\\nscalarsInput(arg: {nullableString: $nullableString, string: $string, nullableInt: $nullableInt, int: $int, nullableFloat: $nullableFloat, float: $float, nullableBoolean: $nullableBoolean, boolean: $boolean, nullableID: $nullableID, id: $id})  \\\\n}\\\\n\\";
  type t = {scalarsInput: string};
  type t_variables = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  let parse: Raw.t => t =
    (value) => (
      {
        scalarsInput: {
          let value = (value: Raw.t).scalarsInput;
          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let scalarsInput = {
          let value = (value: t).scalarsInput;
          value;
        };
        {scalarsInput: scalarsInput};
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      nullableString:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableString,
        ),
      string: (a => a)((inp: t_variables).string),
      nullableInt:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableInt,
        ),
      int: (a => a)((inp: t_variables).int),
      nullableFloat:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableFloat,
        ),
      float: (a => a)((inp: t_variables).float),
      nullableBoolean:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableBoolean,
        ),
      boolean: (a => a)((inp: t_variables).boolean),
      nullableID:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableID,
        ),
      id: (a => a)((inp: t_variables).id),
    };
  let makeVariables =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      ) =>
    serializeVariables(
      {
        nullableString,
        string,
        nullableInt,
        int,
        nullableFloat,
        float,
        nullableBoolean,
        boolean,
        nullableID,
        id,
      }: t_variables,
    );
  module Z__INTERNAL = {
    type nonrec _graphql_arg_292;
    /**Argument **arg** on field **scalarsInput** has the following graphql type:

\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}!
\`\`\`*/
    let _graphql_arg_292: _graphql_arg_292 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records scalarsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {scalarsInput: string};
    type t_variables = {arg: t_variables_VariousScalarsInput}
    and t_variables_VariousScalarsInput = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
  };
  let query = \\"query ($arg: VariousScalarsInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {scalarsInput: string};
  type t_variables = {arg: t_variables_VariousScalarsInput}
  and t_variables_VariousScalarsInput = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  let parse: Raw.t => t =
    (value) => (
      {
        scalarsInput: {
          let value = (value: Raw.t).scalarsInput;
          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let scalarsInput = {
          let value = (value: t).scalarsInput;
          value;
        };
        {scalarsInput: scalarsInput};
      }: Raw.t
    );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (a => serializeInputObjectVariousScalarsInput(a))(
          (inp: t_variables).arg,
        ),
    }
  and serializeInputObjectVariousScalarsInput:
    t_variables_VariousScalarsInput => Raw.t_variables_VariousScalarsInput =
    inp => {
      nullableString:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableString,
        ),
      string: (a => a)((inp: t_variables_VariousScalarsInput).string),
      nullableInt:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableInt,
        ),
      int: (a => a)((inp: t_variables_VariousScalarsInput).int),
      nullableFloat:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableFloat,
        ),
      float: (a => a)((inp: t_variables_VariousScalarsInput).float),
      nullableBoolean:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableBoolean,
        ),
      boolean: (a => a)((inp: t_variables_VariousScalarsInput).boolean),
      nullableID:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableID,
        ),
      id: (a => a)((inp: t_variables_VariousScalarsInput).id),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables)
  and makeInputObjectVariousScalarsInput =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      )
      : t_variables_VariousScalarsInput => {
    nullableString,
    string,
    nullableInt,
    int,
    nullableFloat,
    float,
    nullableBoolean,
    boolean,
    nullableID,
    id,
  };
  module Z__INTERNAL = {
    type nonrec _graphql_arg_93;
    /**Variable **$arg** has the following graphql type:

\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}!
\`\`\`*/
    let _graphql_arg_93: _graphql_arg_93 = Obj.magic(0);
    type nonrec _graphql_arg_88;
    /**Argument **arg** on field **scalarsInput** has the following graphql type:

\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}!
\`\`\`*/
    let _graphql_arg_88: _graphql_arg_88 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_VariousScalarsInput_47;
    /**\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}
\`\`\`*/
    let _graphql_VariousScalarsInput_47: _graphql_VariousScalarsInput_47 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records skipDirectives.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_v1 = {
      nullableString: Js.Nullable.t(string),
      string: Js.Nullable.t(string),
    };
    type t_v2 = {
      nullableString: Js.Nullable.t(string),
      string: Js.Nullable.t(string),
    };
    type t = {
      v1: t_v1,
      v2: t_v2,
    };
    type t_variables = {var: bool};
  };
  let query = \\"query ($var: Boolean!)  {\\\\nv1: variousScalars  {\\\\nnullableString @skip(if: $var) \\\\nstring @skip(if: $var) \\\\n}\\\\n\\\\nv2: variousScalars  {\\\\nnullableString @include(if: $var) \\\\nstring @include(if: $var) \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_v1 = {
    nullableString: option(string),
    string: option(string),
  };
  type t_v2 = {
    nullableString: option(string),
    string: option(string),
  };
  type t = {
    v1: t_v1,
    v2: t_v2,
  };
  type t_variables = {var: bool};
  let parse: Raw.t => t =
    (value) => (
      {
        v1: {
          let value = (value: Raw.t).v1;
          (
            {
              nullableString: {
                let value = (value: Raw.t_v1).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              string: {
                let value = (value: Raw.t_v1).string;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
            }: t_v1
          );
        },
        v2: {
          let value = (value: Raw.t).v2;
          (
            {
              nullableString: {
                let value = (value: Raw.t_v2).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              string: {
                let value = (value: Raw.t_v2).string;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
            }: t_v2
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let v2 = {
          let value = (value: t).v2;
          (
            {
              let string = {
                let value = (value: t_v2).string;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and nullableString = {
                let value = (value: t_v2).nullableString;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              };
              {nullableString, string};
            }: Raw.t_v2
          );
        }
        and v1 = {
          let value = (value: t).v1;
          (
            {
              let string = {
                let value = (value: t_v1).string;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and nullableString = {
                let value = (value: t_v1).nullableString;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              };
              {nullableString, string};
            }: Raw.t_v1
          );
        };
        {v1, v2};
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {var: (a => a)((inp: t_variables).var)};
  let makeVariables = (~var, ()) =>
    serializeVariables({var: var}: t_variables);
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records subscription.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_simpleSubscription_Dog = {
      __typename: string,
      name: string,
    };
    type t_simpleSubscription_Human = {
      __typename: string,
      name: string,
    };
    type t_simpleSubscription;
    type t = {simpleSubscription: t_simpleSubscription};
    type t_variables = Js.Json.t;
  };
  let query = \\"subscription   {\\\\nsimpleSubscription  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_simpleSubscription_Dog = {name: string};
  type t_simpleSubscription_Human = {name: string};
  type t_simpleSubscription = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_simpleSubscription_Dog)
    | \`Human(t_simpleSubscription_Human)
  ];
  type t = {simpleSubscription: t_simpleSubscription};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        simpleSubscription: {
          let value = (value: Raw.t).simpleSubscription;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_simpleSubscription_Dog = Obj.magic(value);
                  (
                    {
                      name: {
                        let value = (value: Raw.t_simpleSubscription_Dog).name;
                        value;
                      },
                    }: t_simpleSubscription_Dog
                  );
                },
              )
            | \\"Human\\" =>
              \`Human(
                {
                  let value: Raw.t_simpleSubscription_Human = Obj.magic(value);
                  (
                    {
                      name: {
                        let value =
                          (value: Raw.t_simpleSubscription_Human).name;
                        value;
                      },
                    }: t_simpleSubscription_Human
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_simpleSubscription
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let simpleSubscription = {
          let value = (value: t).simpleSubscription;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {
                  let name = {
                    let value = (value: t_simpleSubscription_Dog).name;
                    value;
                  };
                  {__typename: \\"Dog\\", name};
                }: Raw.t_simpleSubscription_Dog,
              ): Raw.t_simpleSubscription
            )
          | \`Human(value) => (
              Obj.magic(
                {
                  let name = {
                    let value = (value: t_simpleSubscription_Human).name;
                    value;
                  };
                  {__typename: \\"Human\\", name};
                }: Raw.t_simpleSubscription_Human,
              ): Raw.t_simpleSubscription
            )
          | \`FutureAddedValue(value) => (
              Obj.magic(value): Raw.t_simpleSubscription
            )
          };
        };
        {simpleSubscription: simpleSubscription};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records tagged_template.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {
              nullableString: {
                let value = (value: Raw.t_variousScalars).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              string: {
                let value = (value: Raw.t_variousScalars).string;
                value;
              },
              nullableInt: {
                let value = (value: Raw.t_variousScalars).nullableInt;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              int: {
                let value = (value: Raw.t_variousScalars).int;
                value;
              },
              nullableFloat: {
                let value = (value: Raw.t_variousScalars).nullableFloat;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              float: {
                let value = (value: Raw.t_variousScalars).float;
                value;
              },
              nullableBoolean: {
                let value = (value: Raw.t_variousScalars).nullableBoolean;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              boolean: {
                let value = (value: Raw.t_variousScalars).boolean;
                value;
              },
              nullableID: {
                let value = (value: Raw.t_variousScalars).nullableID;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              id: {
                let value = (value: Raw.t_variousScalars).id;
                value;
              },
            }: t_variousScalars
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let id = {
                let value = (value: t_variousScalars).id;
                value;
              }
              and nullableID = {
                let value = (value: t_variousScalars).nullableID;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and boolean = {
                let value = (value: t_variousScalars).boolean;
                value;
              }
              and nullableBoolean = {
                let value = (value: t_variousScalars).nullableBoolean;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and float = {
                let value = (value: t_variousScalars).float;
                value;
              }
              and nullableFloat = {
                let value = (value: t_variousScalars).nullableFloat;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and int = {
                let value = (value: t_variousScalars).int;
                value;
              }
              and nullableInt = {
                let value = (value: t_variousScalars).nullableInt;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and string = {
                let value = (value: t_variousScalars).string;
                value;
              }
              and nullableString = {
                let value = (value: t_variousScalars).nullableString;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              };
              {
                nullableString,
                string,
                nullableInt,
                int,
                nullableFloat,
                float,
                nullableBoolean,
                boolean,
                nullableID,
                id,
              };
            }: Raw.t_variousScalars
          );
        };
        {variousScalars: variousScalars};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery2 = {
  module Raw = {
    type t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = Js.Json.t;
  };
  %raw
  \\"let { graphql } = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {
              nullableString: {
                let value = (value: Raw.t_variousScalars).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              string: {
                let value = (value: Raw.t_variousScalars).string;
                value;
              },
              nullableInt: {
                let value = (value: Raw.t_variousScalars).nullableInt;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              int: {
                let value = (value: Raw.t_variousScalars).int;
                value;
              },
              nullableFloat: {
                let value = (value: Raw.t_variousScalars).nullableFloat;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              float: {
                let value = (value: Raw.t_variousScalars).float;
                value;
              },
              nullableBoolean: {
                let value = (value: Raw.t_variousScalars).nullableBoolean;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              boolean: {
                let value = (value: Raw.t_variousScalars).boolean;
                value;
              },
              nullableID: {
                let value = (value: Raw.t_variousScalars).nullableID;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              id: {
                let value = (value: Raw.t_variousScalars).id;
                value;
              },
            }: t_variousScalars
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let id = {
                let value = (value: t_variousScalars).id;
                value;
              }
              and nullableID = {
                let value = (value: t_variousScalars).nullableID;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and boolean = {
                let value = (value: t_variousScalars).boolean;
                value;
              }
              and nullableBoolean = {
                let value = (value: t_variousScalars).nullableBoolean;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and float = {
                let value = (value: t_variousScalars).float;
                value;
              }
              and nullableFloat = {
                let value = (value: t_variousScalars).nullableFloat;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and int = {
                let value = (value: t_variousScalars).int;
                value;
              }
              and nullableInt = {
                let value = (value: t_variousScalars).nullableInt;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and string = {
                let value = (value: t_variousScalars).string;
                value;
              }
              and nullableString = {
                let value = (value: t_variousScalars).nullableString;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              };
              {
                nullableString,
                string,
                nullableInt,
                int,
                nullableFloat,
                float,
                nullableBoolean,
                boolean,
                nullableID,
                id,
              };
            }: Raw.t_variousScalars
          );
        };
        {variousScalars: variousScalars};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery2 {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery3 = {
  module Raw = {
    type t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = Js.Json.t;
  };
  %raw
  \\"let { graphql } = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {
              nullableString: {
                let value = (value: Raw.t_variousScalars).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              string: {
                let value = (value: Raw.t_variousScalars).string;
                value;
              },
              nullableInt: {
                let value = (value: Raw.t_variousScalars).nullableInt;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              int: {
                let value = (value: Raw.t_variousScalars).int;
                value;
              },
              nullableFloat: {
                let value = (value: Raw.t_variousScalars).nullableFloat;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              float: {
                let value = (value: Raw.t_variousScalars).float;
                value;
              },
              nullableBoolean: {
                let value = (value: Raw.t_variousScalars).nullableBoolean;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              boolean: {
                let value = (value: Raw.t_variousScalars).boolean;
                value;
              },
              nullableID: {
                let value = (value: Raw.t_variousScalars).nullableID;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              id: {
                let value = (value: Raw.t_variousScalars).id;
                value;
              },
            }: t_variousScalars
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let id = {
                let value = (value: t_variousScalars).id;
                value;
              }
              and nullableID = {
                let value = (value: t_variousScalars).nullableID;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and boolean = {
                let value = (value: t_variousScalars).boolean;
                value;
              }
              and nullableBoolean = {
                let value = (value: t_variousScalars).nullableBoolean;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and float = {
                let value = (value: t_variousScalars).float;
                value;
              }
              and nullableFloat = {
                let value = (value: t_variousScalars).nullableFloat;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and int = {
                let value = (value: t_variousScalars).int;
                value;
              }
              and nullableInt = {
                let value = (value: t_variousScalars).nullableInt;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and string = {
                let value = (value: t_variousScalars).string;
                value;
              }
              and nullableString = {
                let value = (value: t_variousScalars).nullableString;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              };
              {
                nullableString,
                string,
                nullableInt,
                int,
                nullableFloat,
                float,
                nullableBoolean,
                boolean,
                nullableID,
                id,
              };
            }: Raw.t_variousScalars
          );
        };
        {variousScalars: variousScalars};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery3 {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery4 = {
  module Raw = {
    type t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = Js.Json.t;
  };
  %raw
  \\"let graphql = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {
              nullableString: {
                let value = (value: Raw.t_variousScalars).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              string: {
                let value = (value: Raw.t_variousScalars).string;
                value;
              },
              nullableInt: {
                let value = (value: Raw.t_variousScalars).nullableInt;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              int: {
                let value = (value: Raw.t_variousScalars).int;
                value;
              },
              nullableFloat: {
                let value = (value: Raw.t_variousScalars).nullableFloat;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              float: {
                let value = (value: Raw.t_variousScalars).float;
                value;
              },
              nullableBoolean: {
                let value = (value: Raw.t_variousScalars).nullableBoolean;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              boolean: {
                let value = (value: Raw.t_variousScalars).boolean;
                value;
              },
              nullableID: {
                let value = (value: Raw.t_variousScalars).nullableID;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
              id: {
                let value = (value: Raw.t_variousScalars).id;
                value;
              },
            }: t_variousScalars
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let id = {
                let value = (value: t_variousScalars).id;
                value;
              }
              and nullableID = {
                let value = (value: t_variousScalars).nullableID;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and boolean = {
                let value = (value: t_variousScalars).boolean;
                value;
              }
              and nullableBoolean = {
                let value = (value: t_variousScalars).nullableBoolean;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and float = {
                let value = (value: t_variousScalars).float;
                value;
              }
              and nullableFloat = {
                let value = (value: t_variousScalars).nullableFloat;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and int = {
                let value = (value: t_variousScalars).int;
                value;
              }
              and nullableInt = {
                let value = (value: t_variousScalars).nullableInt;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and string = {
                let value = (value: t_variousScalars).string;
                value;
              }
              and nullableString = {
                let value = (value: t_variousScalars).nullableString;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              };
              {
                nullableString,
                string,
                nullableInt,
                int,
                nullableFloat,
                float,
                nullableBoolean,
                boolean,
                nullableID,
                id,
              };
            }: Raw.t_variousScalars
          );
        };
        {variousScalars: variousScalars};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery4 {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records typename.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_first_inner_inner = {
      __typename: string,
      field: string,
    };
    type t_first_inner = {
      __typename: string,
      inner: Js.Nullable.t(t_first_inner_inner),
    };
    type t_first = {
      __typename: string,
      inner: Js.Nullable.t(t_first_inner),
    };
    type t = {first: t_first};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_first_inner_inner = {
    __typename: string,
    field: string,
  };
  type t_first_inner = {
    __typename: string,
    inner: option(t_first_inner_inner),
  };
  type t_first = {
    __typename: string,
    inner: option(t_first_inner),
  };
  type t = {first: t_first};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        first: {
          let value = (value: Raw.t).first;
          (
            {
              __typename: {
                let value = (value: Raw.t_first).__typename;
                value;
              },
              inner: {
                let value = (value: Raw.t_first).inner;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {
                      __typename: {
                        let value = (value: Raw.t_first_inner).__typename;
                        value;
                      },
                      inner: {
                        let value = (value: Raw.t_first_inner).inner;
                        switch (Js.toOption(value)) {
                        | Some(value) =>
                          Some(
                            {
                              __typename: {
                                let value =
                                  (value: Raw.t_first_inner_inner).__typename;
                                value;
                              },
                              field: {
                                let value =
                                  (value: Raw.t_first_inner_inner).field;
                                value;
                              },
                            }: t_first_inner_inner,
                          )
                        | None => None
                        };
                      },
                    }: t_first_inner,
                  )
                | None => None
                };
              },
            }: t_first
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let first = {
          let value = (value: t).first;
          (
            {
              let inner = {
                let value = (value: t_first).inner;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {
                      let inner = {
                        let value = (value: t_first_inner).inner;
                        switch (value) {
                        | Some(value) =>
                          Js.Nullable.return(
                            {
                              let field = {
                                let value = (value: t_first_inner_inner).field;
                                value;
                              }
                              and __typename = {
                                let value =
                                  (value: t_first_inner_inner).__typename;
                                value;
                              };
                              {__typename, field};
                            }: Raw.t_first_inner_inner,
                          )
                        | None => Js.Nullable.null
                        };
                      }
                      and __typename = {
                        let value = (value: t_first_inner).__typename;
                        value;
                      };
                      {__typename, inner};
                    }: Raw.t_first_inner,
                  )
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_first).__typename;
                value;
              };
              {__typename, inner};
            }: Raw.t_first
          );
        };
        {first: first};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records union.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {name: string};
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        dogOrHuman: {
          let value = (value: Raw.t).dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                  (
                    {
                      name: {
                        let value = (value: Raw.t_dogOrHuman_Dog).name;
                        value;
                      },
                      barkVolume: {
                        let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                        value;
                      },
                    }: t_dogOrHuman_Dog
                  );
                },
              )
            | \\"Human\\" =>
              \`Human(
                {
                  let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                  (
                    {
                      name: {
                        let value = (value: Raw.t_dogOrHuman_Human).name;
                        value;
                      },
                    }: t_dogOrHuman_Human
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: t).dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {
                  let barkVolume = {
                    let value = (value: t_dogOrHuman_Dog).barkVolume;
                    value;
                  }
                  and name = {
                    let value = (value: t_dogOrHuman_Dog).name;
                    value;
                  };
                  {__typename: \\"Dog\\", name, barkVolume};
                }: Raw.t_dogOrHuman_Dog,
              ): Raw.t_dogOrHuman
            )
          | \`Human(value) => (
              Obj.magic(
                {
                  let name = {
                    let value = (value: t_dogOrHuman_Human).name;
                    value;
                  };
                  {__typename: \\"Human\\", name};
                }: Raw.t_dogOrHuman_Human,
              ): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        };
        {dogOrHuman: dogOrHuman};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQueryNoError = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {name: string};
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        dogOrHuman: {
          let value = (value: Raw.t).dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                  (
                    {
                      name: {
                        let value = (value: Raw.t_dogOrHuman_Dog).name;
                        value;
                      },
                      barkVolume: {
                        let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                        value;
                      },
                    }: t_dogOrHuman_Dog
                  );
                },
              )
            | \\"Human\\" =>
              \`Human(
                {
                  let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                  (
                    {
                      name: {
                        let value = (value: Raw.t_dogOrHuman_Human).name;
                        value;
                      },
                    }: t_dogOrHuman_Human
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: t).dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {
                  let barkVolume = {
                    let value = (value: t_dogOrHuman_Dog).barkVolume;
                    value;
                  }
                  and name = {
                    let value = (value: t_dogOrHuman_Dog).name;
                    value;
                  };
                  {__typename: \\"Dog\\", name, barkVolume};
                }: Raw.t_dogOrHuman_Dog,
              ): Raw.t_dogOrHuman
            )
          | \`Human(value) => (
              Obj.magic(
                {
                  let name = {
                    let value = (value: t_dogOrHuman_Human).name;
                    value;
                  };
                  {__typename: \\"Human\\", name};
                }: Raw.t_dogOrHuman_Human,
              ): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        };
        {dogOrHuman: dogOrHuman};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQueryNoError {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records unionPartial.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = Js.Json.t;
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        dogOrHuman: {
          let value = (value: Raw.t).dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                  (
                    {
                      name: {
                        let value = (value: Raw.t_dogOrHuman_Dog).name;
                        value;
                      },
                      barkVolume: {
                        let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                        value;
                      },
                    }: t_dogOrHuman_Dog
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: t).dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {
                  let barkVolume = {
                    let value = (value: t_dogOrHuman_Dog).barkVolume;
                    value;
                  }
                  and name = {
                    let value = (value: t_dogOrHuman_Dog).name;
                    value;
                  };
                  {__typename: \\"Dog\\", name, barkVolume};
                }: Raw.t_dogOrHuman_Dog,
              ): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        };
        {dogOrHuman: dogOrHuman};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records variant.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_mutationForVariant_dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_mutationForVariant_human = {
      __typename: string,
      name: string,
    };
    type t_mutationForVariant_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_mutationForVariant_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_mutationForVariant_dogOrHuman;
    type t_mutationForVariant;
    type t = {mutationForVariant: t_mutationForVariant};
    type t_variables = Js.Json.t;
  };
  let query = \\"mutation   {\\\\nmutationForVariant  {\\\\nbaseType  \\\\nbaseTypeList  \\\\ndog  {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\nhuman  {\\\\nname  \\\\n}\\\\n\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_mutationForVariant_dog = {
    name: string,
    barkVolume: float,
  };
  type t_mutationForVariant_human = {name: string};
  type t_mutationForVariant_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_mutationForVariant_dogOrHuman_Human = {name: string};
  type t_mutationForVariant_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_mutationForVariant_dogOrHuman_Dog)
    | \`Human(t_mutationForVariant_dogOrHuman_Human)
  ];
  type t_mutationForVariant = [
    | \`BaseType(string)
    | \`BaseTypeList(array(string))
    | \`Dog(t_mutationForVariant_dog)
    | \`Human(t_mutationForVariant_human)
    | \`DogOrHuman(t_mutationForVariant_dogOrHuman)
  ];
  type t = {mutationForVariant: t_mutationForVariant};
  type t_variables = Js.Json.t;
  let parse: Raw.t => t =
    (value) => (
      {
        mutationForVariant: {
          let value = (value: Raw.t).mutationForVariant;
          switch (Js.Json.decodeObject(Obj.magic(value): Js.Json.t)) {
          | None =>
            Js.Exn.raiseError(
              \\"graphql_ppx: \\"
              ++ \\"Expected type \\"
              ++ \\"VariantTestResult\\"
              ++ \\" to be an object\\",
            )
          | Some(value) =>
            let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"baseType\\");
            switch (Js.Json.decodeNull(temp)) {
            | None =>
              let value = temp;
              \`BaseType(value);
            | Some(_) =>
              let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"baseTypeList\\");
              switch (Js.Json.decodeNull(temp)) {
              | None =>
                let value = temp;
                \`BaseTypeList(value |> Js.Array.map(value => value));
              | Some(_) =>
                let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"dog\\");
                switch (Js.Json.decodeNull(temp)) {
                | None =>
                  let value = temp;
                  \`Dog(
                    {
                      name: {
                        let value = (value: Raw.t_mutationForVariant_dog).name;
                        value;
                      },
                      barkVolume: {
                        let value =
                          (value: Raw.t_mutationForVariant_dog).barkVolume;
                        value;
                      },
                    }: t_mutationForVariant_dog,
                  );
                | Some(_) =>
                  let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"human\\");
                  switch (Js.Json.decodeNull(temp)) {
                  | None =>
                    let value = temp;
                    \`Human(
                      {
                        name: {
                          let value =
                            (value: Raw.t_mutationForVariant_human).name;
                          value;
                        },
                      }: t_mutationForVariant_human,
                    );
                  | Some(_) =>
                    let temp =
                      Js.Dict.unsafeGet(Obj.magic(value), \\"dogOrHuman\\");
                    switch (Js.Json.decodeNull(temp)) {
                    | None =>
                      let value = temp;
                      \`DogOrHuman(
                        {
                          let typename: string =
                            Obj.magic(
                              Js.Dict.unsafeGet(
                                Obj.magic(value),
                                \\"__typename\\",
                              ),
                            );
                          (
                            switch (typename) {
                            | \\"Dog\\" =>
                              \`Dog(
                                {
                                  let value: Raw.t_mutationForVariant_dogOrHuman_Dog =
                                    Obj.magic(value);
                                  (
                                    {
                                      name: {
                                        let value =
                                          (
                                            value: Raw.t_mutationForVariant_dogOrHuman_Dog
                                          ).
                                            name;
                                        value;
                                      },
                                      barkVolume: {
                                        let value =
                                          (
                                            value: Raw.t_mutationForVariant_dogOrHuman_Dog
                                          ).
                                            barkVolume;
                                        value;
                                      },
                                    }: t_mutationForVariant_dogOrHuman_Dog
                                  );
                                },
                              )
                            | \\"Human\\" =>
                              \`Human(
                                {
                                  let value: Raw.t_mutationForVariant_dogOrHuman_Human =
                                    Obj.magic(value);
                                  (
                                    {
                                      name: {
                                        let value =
                                          (
                                            value: Raw.t_mutationForVariant_dogOrHuman_Human
                                          ).
                                            name;
                                        value;
                                      },
                                    }: t_mutationForVariant_dogOrHuman_Human
                                  );
                                },
                              )
                            | _ =>
                              \`FutureAddedValue(Obj.magic(value): Js.Json.t)
                            }: t_mutationForVariant_dogOrHuman
                          );
                        },
                      );
                    | Some(_) =>
                      Js.Exn.raiseError(
                        \\"graphql_ppx: \\"
                        ++ \\"All fields on variant selection set on type \\"
                        ++ \\"VariantTestResult\\"
                        ++ \\" were null\\",
                      )
                    };
                  };
                };
              };
            };
          };
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let mutationForVariant = {
          let value = (value: t).mutationForVariant;
          Obj.magic(Js.Json.null);
        };
        {mutationForVariant: mutationForVariant};
      }: Raw.t
    );
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- GraphQL PPX Module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  // This is the stringified representation of your query, which gets sent to the server.
  let query: string;

  // This is the main type of the result you will get back.
  // You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  type t;

  // This function turns your raw result from the server into the reason/ocaml representation of that result.
  // Depending on your graphql client library, this process should happen automatically for you.
  let parse: Raw.t => t;

  // This function will prepare your data for sending it back to the server.
  // Depending on your graphql client library, this process should happen automatically for you.
  let serialize: t => Raw.t;

  // The definition tuple is primarily used to interact with client libraries.
  // The types are equivalent to: (parse, query, serialize).
  // Your client library will use these values to provide the properly parsed / serialized data for you.
  let definition: (
    Raw.t => t,
    string,
    t => Raw.t
  );

  // This is the representation of your raw result coming from the server.
  // It should not be necessary to access the types inside for normal use cases.
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;
