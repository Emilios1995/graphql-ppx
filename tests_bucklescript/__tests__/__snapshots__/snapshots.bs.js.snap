// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Legacy argNamedQuery.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"argNamedQuery\\": int};
  };
  let query = \\"query ($query: String!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\";
  type t = {. \\"argNamedQuery\\": int};
  type t_variables = {. \\"query\\": string};
  let parse: Raw.t => t =
    value => {

      \\"argNamedQuery\\": {
        let value = value##argNamedQuery;

        value;
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"argNamedQuery\\": {
        let value = value##argNamedQuery;

        value;
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|(\\"query\\", (a => Some(Js.Json.string(a)))(inp##query))|]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~query, ()) =>
    f(
      serializeVariables(
        {

          \\"query\\": query,
        }: t_variables,
      ),
    );
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Legacy bug1.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module GraphQL_PPX = {
  let%private clone: Js.Dict.t('a) => Js.Dict.t('a) =
    a => Obj.magic(Js.Obj.assign(Obj.magic(Js.Obj.empty()), Obj.magic(a)));

  let rec deepMerge = (json1: Js.Json.t, json2: Js.Json.t) =>
    switch (
      (
        Obj.magic(json1) == Js.null,
        Js_array2.isArray(json1),
        Js.typeof(json1) == \\"object\\",
      ),
      (
        Obj.magic(json2) == Js.null,
        Js_array2.isArray(json2),
        Js.typeof(json2) == \\"object\\",
      ),
    ) {
    | ((_, true, _), (_, true, _)) => (
        Obj.magic(
          Js.Array.mapi(
            (el1, idx) => {
              let el2 = Js.Array.unsafe_get(Obj.magic(json2), idx);

              Js.typeof(el2) == \\"object\\" ? deepMerge(el1, el2) : el2;
            },
            Obj.magic(json1),
          ),
        ): Js.Json.t
      )

    | ((false, false, true), (false, false, true)) =>
      let obj1 = clone(Obj.magic(json1));
      let obj2 = Obj.magic(json2);
      Js.Dict.keys(obj2)
      |> Js.Array.forEach(key =>
           let existingVal: Js.Json.t = Js.Dict.unsafeGet(obj1, key);
           let newVal: Js.Json.t = Js.Dict.unsafeGet(obj1, key);
           Js.Dict.set(
             obj1,
             key,
             Js.typeof(existingVal) != \\"object\\"
               ? newVal : Obj.magic(deepMerge(existingVal, newVal)),
           );
         );
      Obj.magic(obj1);

    | ((_, _, _), (_, _, _)) => json2
    };
};

module LargeAvatars_User = {
  let query = \\"fragment LargeAvatars_User on User   {\\\\nid  \\\\nname  \\\\ngeneralStatistics  {\\\\nactivityCount  \\\\n}\\\\n\\\\n}\\\\n\\";
  module Raw = {
    type t = {
      id: string,
      name: string,
      generalStatistics: t_generalStatistics,
    }
    and t_generalStatistics = {activityCount: int};
    type t_User = t;
  };
  type t = {
    id: string,
    name: string,
    generalStatistics: t_generalStatistics,
  }
  and t_generalStatistics = {activityCount: int};
  type t_User = t;

  let parse = (value: Raw.t): t => {

    id: {
      let value = (value: Raw.t).id;

      value;
    },

    name: {
      let value = (value: Raw.t).name;

      value;
    },

    generalStatistics: {
      let value = (value: Raw.t).generalStatistics;
      (
        {

          activityCount: {
            let value = (value: Raw.t_generalStatistics).activityCount;

            value;
          },
        }: t_generalStatistics
      );
    },
  };
  let serialize: t => Raw.t =
    (value) => (
      {

        id: {
          let value = (value: t).id;

          value;
        },

        name: {
          let value = (value: t).name;

          value;
        },

        generalStatistics: {
          let value = (value: t).generalStatistics;
          (
            {

              activityCount: {
                let value = (value: t_generalStatistics).activityCount;

                value;
              },
            }: Raw.t_generalStatistics
          );
        },
      }: Raw.t
    );
  let name = \\"LargeAvatars_User\\";
};
module Small_Avatar_User = {
  let query = \\"fragment Small_Avatar_User on User   {\\\\nid  \\\\nname  \\\\nsmallAvatar: avatar(scaleFactor: $pixelRatio, width: 60, height: 60)  {\\\\nurl  \\\\ncolor  \\\\n}\\\\n\\\\n}\\\\n\\";
  module Raw = {
    type t = {
      .
      \\"id\\": string,
      \\"name\\": string,
      \\"smallAvatar\\": Js.Nullable.t(t_smallAvatar),
    }
    and t_smallAvatar = {
      .
      \\"url\\": string,
      \\"color\\": Js.Nullable.t(string),
    };
    type t_User = t;
  };
  type t = {
    .
    \\"id\\": string,
    \\"name\\": string,
    \\"smallAvatar\\": option(t_smallAvatar),
  }
  and t_smallAvatar = {
    .
    \\"url\\": string,
    \\"color\\": option(string),
  };
  type t_User = t;

  let parse = (~pixelRatio as _pixelRatio: [ | \`Float_NonNull], value: Raw.t) => {

    \\"id\\": {
      let value = value##id;

      value;
    },

    \\"name\\": {
      let value = value##name;

      value;
    },

    \\"smallAvatar\\": {
      let value = value##smallAvatar;

      switch (Js.toOption(value)) {
      | Some(value) =>
        Some({

          \\"url\\": {
            let value = value##url;

            value;
          },

          \\"color\\": {
            let value = value##color;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },
        })
      | None => None
      };
    },
  };
  let serialize: t => Raw.t =
    value => {

      \\"id\\": {
        let value = value##id;

        value;
      },

      \\"name\\": {
        let value = value##name;

        value;
      },

      \\"smallAvatar\\": {
        let value = value##smallAvatar;

        switch (value) {
        | Some(value) =>
          Js.Nullable.return({

            \\"url\\": {
              let value = value##url;

              value;
            },

            \\"color\\": {
              let value = value##color;

              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            },
          })
        | None => Js.Nullable.null
        };
      },
    };
  let name = \\"Small_Avatar_User\\";
};

module Query = {
  module Raw = {
    type t = {. \\"activityFeedItem\\": Js.Nullable.t(t_activityFeedItem)}
    and t_activityFeedItem = {
      .
      \\"id\\": string,
      \\"duration\\": Js.Nullable.t(int),
      \\"rating\\": Js.Nullable.t(int),
      \\"activity\\": t_activityFeedItem_activity,
      \\"participants\\": array(t_activityFeedItem_participants),
    }
    and t_activityFeedItem_participants
    and t_activityFeedItem_participants_generalStatistics = {
      .
      \\"activityCount\\": int,
    }
    and t_activityFeedItem_activity = {
      .
      \\"id\\": string,
      \\"title\\": Js.Nullable.t(string),
      \\"description\\": Js.Nullable.t(string),
      \\"duration\\": Js.Nullable.t(int),
      \\"cognitiveAspects\\": array(t_activityFeedItem_activity_cognitiveAspects),
    }
    and t_activityFeedItem_activity_cognitiveAspects = {
      .
      \\"id\\": string,
      \\"name\\": Js.Nullable.t(string),
    };
  };
  let query =
    (
      (
        (
          (
            (
              \\"query ActivityOverviewQuery($id: ID!, $pixelRatio: Float!)  {\\\\nactivityFeedItem(id: $id)  {\\\\nid  \\\\nduration  \\\\nrating  \\\\nactivity  {\\\\nid  \\\\ntitle  \\\\ndescription  \\\\nduration  \\\\ncognitiveAspects  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\nparticipants  {\\\\nid  \\\\nname  \\\\ngeneralStatistics  {\\\\nactivityCount  \\\\n}\\\\n\\\\n...\\"
              ++ LargeAvatars_User.name
            )
            ++ \\"   \\\\n...\\"
          )
          ++ Small_Avatar_User.name
        )
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ LargeAvatars_User.query
    )
    ++ Small_Avatar_User.query;
  type t = {. \\"activityFeedItem\\": option(t_activityFeedItem)}
  and t_activityFeedItem = {
    .
    \\"id\\": string,
    \\"duration\\": option(int),
    \\"rating\\": option(int),
    \\"activity\\": t_activityFeedItem_activity,
    \\"participants\\": array(t_activityFeedItem_participants),
  }
  and t_activityFeedItem_participants = {
    .
    \\"id\\": string,
    \\"name\\": string,
    \\"generalStatistics\\": t_activityFeedItem_participants_generalStatistics,
    \\"largeAvatars_User\\": LargeAvatars_User.t_User,
    \\"small_Avatar_User\\": Small_Avatar_User.t_User,
  }
  and t_activityFeedItem_participants_generalStatistics = {
    .
    \\"activityCount\\": int,
  }
  and t_activityFeedItem_activity = {
    .
    \\"id\\": string,
    \\"title\\": option(string),
    \\"description\\": option(string),
    \\"duration\\": option(int),
    \\"cognitiveAspects\\": array(t_activityFeedItem_activity_cognitiveAspects),
  }
  and t_activityFeedItem_activity_cognitiveAspects = {
    .
    \\"id\\": string,
    \\"name\\": option(string),
  };
  type t_variables = {
    .
    \\"id\\": string,
    \\"pixelRatio\\": float,
  };
  let parse: Raw.t => t =
    value => {

      \\"activityFeedItem\\": {
        let value = value##activityFeedItem;

        switch (Js.toOption(value)) {
        | Some(value) =>
          Some({

            \\"id\\": {
              let value = value##id;

              value;
            },

            \\"duration\\": {
              let value = value##duration;

              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },

            \\"rating\\": {
              let value = value##rating;

              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },

            \\"activity\\": {
              let value = value##activity;
              {

                \\"id\\": {
                  let value = value##id;

                  value;
                },

                \\"title\\": {
                  let value = value##title;

                  switch (Js.toOption(value)) {
                  | Some(value) => Some(value)
                  | None => None
                  };
                },

                \\"description\\": {
                  let value = value##description;

                  switch (Js.toOption(value)) {
                  | Some(value) => Some(value)
                  | None => None
                  };
                },

                \\"duration\\": {
                  let value = value##duration;

                  switch (Js.toOption(value)) {
                  | Some(value) => Some(value)
                  | None => None
                  };
                },

                \\"cognitiveAspects\\": {
                  let value = value##cognitiveAspects;

                  value
                  |> Js.Array.map(value =>
                       {

                         \\"id\\": {
                           let value = value##id;

                           value;
                         },

                         \\"name\\": {
                           let value = value##name;

                           switch (Js.toOption(value)) {
                           | Some(value) => Some(value)
                           | None => None
                           };
                         },
                       }
                     );
                },
              };
            },

            \\"participants\\": {
              let value = value##participants;

              value
              |> Js.Array.map(value =>
                   {

                     \\"id\\": {
                       let value =
                         Obj.magic(
                           Js.Dict.unsafeGet(Obj.magic(value), \\"id\\"),
                         );

                       value;
                     },

                     \\"name\\": {
                       let value =
                         Obj.magic(
                           Js.Dict.unsafeGet(Obj.magic(value), \\"name\\"),
                         );

                       value;
                     },

                     \\"generalStatistics\\": {
                       let value =
                         Obj.magic(
                           Js.Dict.unsafeGet(
                             Obj.magic(value),
                             \\"generalStatistics\\",
                           ),
                         );
                       {

                         \\"activityCount\\": {
                           let value = value##activityCount;

                           value;
                         },
                       };
                     },

                     \\"largeAvatars_User\\": {
                       let value: LargeAvatars_User.Raw.t = Obj.magic(value);

                       LargeAvatars_User.parse(value);
                     },

                     \\"small_Avatar_User\\": {
                       let value: Small_Avatar_User.Raw.t = Obj.magic(value);

                       Small_Avatar_User.parse(
                         ~pixelRatio=\`Float_NonNull,
                         value,
                       );
                     },
                   }
                 );
            },
          })
        | None => None
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"activityFeedItem\\": {
        let value = value##activityFeedItem;

        switch (value) {
        | Some(value) =>
          Js.Nullable.return({

            \\"id\\": {
              let value = value##id;

              value;
            },

            \\"duration\\": {
              let value = value##duration;

              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            },

            \\"rating\\": {
              let value = value##rating;

              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            },

            \\"activity\\": {
              let value = value##activity;
              {

                \\"id\\": {
                  let value = value##id;

                  value;
                },

                \\"title\\": {
                  let value = value##title;

                  switch (value) {
                  | Some(value) => Js.Nullable.return(value)
                  | None => Js.Nullable.null
                  };
                },

                \\"description\\": {
                  let value = value##description;

                  switch (value) {
                  | Some(value) => Js.Nullable.return(value)
                  | None => Js.Nullable.null
                  };
                },

                \\"duration\\": {
                  let value = value##duration;

                  switch (value) {
                  | Some(value) => Js.Nullable.return(value)
                  | None => Js.Nullable.null
                  };
                },

                \\"cognitiveAspects\\": {
                  let value = value##cognitiveAspects;

                  value
                  |> Js.Array.map(value =>
                       {

                         \\"id\\": {
                           let value = value##id;

                           value;
                         },

                         \\"name\\": {
                           let value = value##name;

                           switch (value) {
                           | Some(value) => Js.Nullable.return(value)
                           | None => Js.Nullable.null
                           };
                         },
                       }
                     );
                },
              };
            },

            \\"participants\\": {
              let value = value##participants;

              value
              |> Js.Array.map((value) =>
                   (
                     Obj.magic(
                       Js.Array.reduce(
                         GraphQL_PPX.deepMerge,
                         Obj.magic(Js.Dict.empty): Js.Json.t,
                         [|
                           (
                             Obj.magic(
                               LargeAvatars_User.serialize(
                                 value##largeAvatars_User,
                               ),
                             ): Js.Json.t
                           ),
                           (
                             Obj.magic(
                               Small_Avatar_User.serialize(
                                 value##small_Avatar_User,
                               ),
                             ): Js.Json.t
                           ),
                         |],
                       ),
                     ): Raw.t_activityFeedItem_participants
                   )
                 );
            },
          })
        | None => Js.Nullable.null
        };
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (\\"id\\", (a => Some(Js.Json.string(a)))(inp##id)),
        (\\"pixelRatio\\", (a => Some(Js.Json.number(a)))(inp##pixelRatio)),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~id, ~pixelRatio, ()) =>
    f(
      serializeVariables(
        {

          \\"id\\": id,

          \\"pixelRatio\\": pixelRatio,
        }: t_variables,
      ),
    );
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Legacy comment.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"nonrecursiveInput\\": string};
  };
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"nonrecursiveInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    .
    \\"field\\": option(string),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  let parse: Raw.t => t =
    value => {

      \\"nonrecursiveInput\\": {
        let value = value##nonrecursiveInput;

        value;
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"nonrecursiveInput\\": {
        let value = value##nonrecursiveInput;

        value;
      },
    };
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (a => Some(serializeInputObjectNonrecursiveInput(a)))(inp##arg),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Js.Json.t =
    inp =>
      [|
        (
          \\"field\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##field,
          ),
        ),
        (
          \\"enum\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      switch (a) {
                      | \`FIRST => Js.Json.string(\\"FIRST\\")
                      | \`SECOND => Js.Json.string(\\"SECOND\\")
                      | \`THIRD => Js.Json.string(\\"THIRD\\")
                      },
                    )
                )(
                  b,
                )
              }
          )(
            inp##enum,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    )
  and makeInputObjectNonrecursiveInput =
      (~field=?, ~enum=?, ()): t_variables_NonrecursiveInput => {

    \\"field\\": field,

    \\"enum\\": enum,
  };
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Legacy customDecoder.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module StringOfInt = {
  let parse = string_of_int;
  type t = string;
};
module IntOfString = {
  let parse = int_of_string;
  type t = int;
};

module MyQuery = {
  module Raw = {
    type t = {. \\"variousScalars\\": t_variousScalars}
    and t_variousScalars = {
      .
      \\"string\\": string,
      \\"int\\": int,
    };
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"variousScalars\\": t_variousScalars}
  and t_variousScalars = {
    .
    \\"string\\": IntOfString.t,
    \\"int\\": StringOfInt.t,
  };
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"string\\": {
            let value = value##string;

            IntOfString.parse(value);
          },

          \\"int\\": {
            let value = value##int;

            StringOfInt.parse(value);
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"string\\": {
            let value = value##string;

            IntOfString.serialize(value);
          },

          \\"int\\": {
            let value = value##int;

            StringOfInt.serialize(value);
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Legacy customScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"customScalarField\\": t_customScalarField}
    and t_customScalarField = {
      .
      \\"nullable\\": Js.Nullable.t(Js.Json.t),
      \\"nonNullable\\": Js.Json.t,
    };
  };
  let query = \\"query ($opt: CustomScalar, $req: CustomScalar!)  {\\\\ncustomScalarField(argOptional: $opt, argRequired: $req)  {\\\\nnullable  \\\\nnonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"customScalarField\\": t_customScalarField}
  and t_customScalarField = {
    .
    \\"nullable\\": option(Js.Json.t),
    \\"nonNullable\\": Js.Json.t,
  };
  type t_variables = {
    .
    \\"opt\\": option(Js.Json.t),
    \\"req\\": Js.Json.t,
  };
  let parse: Raw.t => t =
    value => {

      \\"customScalarField\\": {
        let value = value##customScalarField;
        {

          \\"nullable\\": {
            let value = value##nullable;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"nonNullable\\": {
            let value = value##nonNullable;

            value;
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"customScalarField\\": {
        let value = value##customScalarField;
        {

          \\"nullable\\": {
            let value = value##nullable;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"nonNullable\\": {
            let value = value##nonNullable;

            value;
          },
        };
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"opt\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(a))(b)
              }
          )(
            inp##opt,
          ),
        ),
        (\\"req\\", (a => Some(a))(inp##req)),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~opt=?, ~req, ()) =>
    f(
      serializeVariables(
        {

          \\"opt\\": opt,

          \\"req\\": req,
        }: t_variables,
      ),
    );
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Legacy enumInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"enumInput\\": string};
  };
  let query = \\"query ($arg: SampleField!)  {\\\\nenumInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"enumInput\\": string};
  type t_variables = {. \\"arg\\": [ | \`FIRST | \`SECOND | \`THIRD]};
  let parse: Raw.t => t =
    value => {

      \\"enumInput\\": {
        let value = value##enumInput;

        value;
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"enumInput\\": {
        let value = value##enumInput;

        value;
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (
            a =>
              Some(
                switch (a) {
                | \`FIRST => Js.Json.string(\\"FIRST\\")
                | \`SECOND => Js.Json.string(\\"SECOND\\")
                | \`THIRD => Js.Json.string(\\"THIRD\\")
                },
              )
          )(
            inp##arg,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    );
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Legacy explicit_object_record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module RecordsQuery = {
  module Raw = {
    type t = {lists: t_lists}
    and t_lists = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {lists: t_lists}
  and t_lists = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  let parse: Raw.t => t =
    (value) => (
      {

        lists: {
          let value = (value: Raw.t).lists;
          (
            {

              nullableOfNullable: {
                let value = (value: Raw.t_lists).nullableOfNullable;

                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              },

              nullableOfNonNullable: {
                let value = (value: Raw.t_lists).nullableOfNonNullable;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value |> Js.Array.map(value => value))
                | None => None
                };
              },

              nonNullableOfNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNullable;

                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   );
              },

              nonNullableOfNonNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNonNullable;

                value |> Js.Array.map(value => value);
              },
            }: t_lists
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        lists: {
          let value = (value: t).lists;
          (
            {

              nullableOfNullable: {
                let value = (value: t_lists).nullableOfNullable;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map(value =>
                         switch (value) {
                         | Some(value) => Js.Nullable.return(value)
                         | None => Js.Nullable.null
                         }
                       ),
                  )
                | None => Js.Nullable.null
                };
              },

              nullableOfNonNullable: {
                let value = (value: t_lists).nullableOfNonNullable;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(value |> Js.Array.map(value => value))
                | None => Js.Nullable.null
                };
              },

              nonNullableOfNullable: {
                let value = (value: t_lists).nonNullableOfNullable;

                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   );
              },

              nonNullableOfNonNullable: {
                let value = (value: t_lists).nonNullableOfNonNullable;

                value |> Js.Array.map(value => value);
              },
            }: Raw.t_lists
          );
        },
      }: Raw.t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};

module ObjectsQuery = {
  module Raw = {
    type t = {. \\"lists\\": t_lists}
    and t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"lists\\": t_lists}
  and t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  let parse: Raw.t => t =
    value => {

      \\"lists\\": {
        let value = value##lists;
        {

          \\"nullableOfNullable\\": {
            let value = value##nullableOfNullable;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some(
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   ),
              )
            | None => None
            };
          },

          \\"nullableOfNonNullable\\": {
            let value = value##nullableOfNonNullable;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value |> Js.Array.map(value => value))
            | None => None
            };
          },

          \\"nonNullableOfNullable\\": {
            let value = value##nonNullableOfNullable;

            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               );
          },

          \\"nonNullableOfNonNullable\\": {
            let value = value##nonNullableOfNonNullable;

            value |> Js.Array.map(value => value);
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"lists\\": {
        let value = value##lists;
        {

          \\"nullableOfNullable\\": {
            let value = value##nullableOfNullable;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return(
                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   ),
              )
            | None => Js.Nullable.null
            };
          },

          \\"nullableOfNonNullable\\": {
            let value = value##nullableOfNonNullable;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return(value |> Js.Array.map(value => value))
            | None => Js.Nullable.null
            };
          },

          \\"nonNullableOfNullable\\": {
            let value = value##nonNullableOfNullable;

            value
            |> Js.Array.map(value =>
                 switch (value) {
                 | Some(value) => Js.Nullable.return(value)
                 | None => Js.Nullable.null
                 }
               );
          },

          \\"nonNullableOfNonNullable\\": {
            let value = value##nonNullableOfNonNullable;

            value |> Js.Array.map(value => value);
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Legacy fragmentDefinition.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module GraphQL_PPX = {
  let%private clone: Js.Dict.t('a) => Js.Dict.t('a) =
    a => Obj.magic(Js.Obj.assign(Obj.magic(Js.Obj.empty()), Obj.magic(a)));

  let rec deepMerge = (json1: Js.Json.t, json2: Js.Json.t) =>
    switch (
      (
        Obj.magic(json1) == Js.null,
        Js_array2.isArray(json1),
        Js.typeof(json1) == \\"object\\",
      ),
      (
        Obj.magic(json2) == Js.null,
        Js_array2.isArray(json2),
        Js.typeof(json2) == \\"object\\",
      ),
    ) {
    | ((_, true, _), (_, true, _)) => (
        Obj.magic(
          Js.Array.mapi(
            (el1, idx) => {
              let el2 = Js.Array.unsafe_get(Obj.magic(json2), idx);

              Js.typeof(el2) == \\"object\\" ? deepMerge(el1, el2) : el2;
            },
            Obj.magic(json1),
          ),
        ): Js.Json.t
      )

    | ((false, false, true), (false, false, true)) =>
      let obj1 = clone(Obj.magic(json1));
      let obj2 = Obj.magic(json2);
      Js.Dict.keys(obj2)
      |> Js.Array.forEach(key =>
           let existingVal: Js.Json.t = Js.Dict.unsafeGet(obj1, key);
           let newVal: Js.Json.t = Js.Dict.unsafeGet(obj1, key);
           Js.Dict.set(
             obj1,
             key,
             Js.typeof(existingVal) != \\"object\\"
               ? newVal : Obj.magic(deepMerge(existingVal, newVal)),
           );
         );
      Obj.magic(obj1);

    | ((_, _, _), (_, _, _)) => json2
    };
};

module Fragments = {
  module ListFragment = {
    let query = \\"fragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        .
        \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
        \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      };
      type t_Lists = t;
    };
    type t = {
      .
      \\"nullableOfNullable\\": option(array(option(string))),
      \\"nullableOfNonNullable\\": option(array(string)),
    };
    type t_Lists = t;

    let parse = (value: Raw.t) => {

      \\"nullableOfNullable\\": {
        let value = value##nullableOfNullable;

        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      },

      \\"nullableOfNonNullable\\": {
        let value = value##nullableOfNonNullable;

        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      },
    };
    let serialize: t => Raw.t =
      value => {

        \\"nullableOfNullable\\": {
          let value = value##nullableOfNullable;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 ),
            )
          | None => Js.Nullable.null
          };
        },

        \\"nullableOfNonNullable\\": {
          let value = value##nullableOfNonNullable;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(value |> Js.Array.map(value => value))
          | None => Js.Nullable.null
          };
        },
      };
    let name = \\"ListFragment\\";
  };
  module Another = {
    let query = \\"fragment Another on Lists   {\\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
    module Raw = {
      type t = {. \\"nullableOfNonNullable\\": Js.Nullable.t(array(string))};
      type t_Lists = t;
    };
    type t = {. \\"nullableOfNonNullable\\": option(array(string))};
    type t_Lists = t;

    let parse = (value: Raw.t) => {

      \\"nullableOfNonNullable\\": {
        let value = value##nullableOfNonNullable;

        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      },
    };
    let serialize: t => Raw.t =
      value => {

        \\"nullableOfNonNullable\\": {
          let value = value##nullableOfNonNullable;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(value |> Js.Array.map(value => value))
          | None => Js.Nullable.null
          };
        },
      };
    let name = \\"Another\\";
  };
};

module MyQuery = {
  module Raw = {
    type t = {
      .
      \\"l1\\": Fragments.ListFragment.Raw.t,
      \\"l2\\": t_l2,
      \\"l3\\": t_l3,
      \\"l4\\": t_l4,
    }
    and t_l4
    and t_l3
    and t_l2;
  };
  let query =
    (
      (
        (
          (
            (
              (
                (
                  (
                    (
                      (
                        (
                          (
                            \\"query   {\\\\nl1: lists  {\\\\n...\\"
                            ++ Fragments.ListFragment.name
                          )
                          ++ \\"   \\\\n}\\\\n\\\\nl2: lists  {\\\\n...\\"
                        )
                        ++ Fragments.ListFragment.name
                      )
                      ++ \\"   \\\\n...\\"
                    )
                    ++ Fragments.ListFragment.name
                  )
                  ++ \\"   \\\\n}\\\\n\\\\nl3: lists  {\\\\nnullableOfNullable  \\\\n...\\"
                )
                ++ Fragments.ListFragment.name
              )
              ++ \\"   \\\\n...\\"
            )
            ++ Fragments.ListFragment.name
          )
          ++ \\"   \\\\n}\\\\n\\\\nl4: lists  {\\\\nnullableOfNullable  \\\\n...\\"
        )
        ++ Fragments.ListFragment.name
      )
      ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
    )
    ++ Fragments.ListFragment.query;
  type t = {
    .
    \\"l1\\": Fragments.ListFragment.t,
    \\"l2\\": t_l2,
    \\"l3\\": t_l3,
    \\"l4\\": t_l4,
  }
  and t_l4 = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"listFragment\\": Fragments.ListFragment.t_Lists,
  }
  and t_l3 = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"frag1\\": Fragments.ListFragment.t_Lists,
    \\"frag2\\": Fragments.ListFragment.t_Lists,
  }
  and t_l2 = {
    .
    \\"frag1\\": Fragments.ListFragment.t_Lists,
    \\"frag2\\": Fragments.ListFragment.t_Lists,
  };
  let parse: Raw.t => t =
    value => {

      \\"l1\\": {
        let value = value##l1;

        Fragments.ListFragment.parse(value);
      },

      \\"l2\\": {
        let value = value##l2;
        {

          \\"frag1\\": {
            let value: Fragments.ListFragment.Raw.t = Obj.magic(value);

            Fragments.ListFragment.parse(value);
          },

          \\"frag2\\": {
            let value: Fragments.ListFragment.Raw.t = Obj.magic(value);

            Fragments.ListFragment.parse(value);
          },
        };
      },

      \\"l3\\": {
        let value = value##l3;
        {

          \\"nullableOfNullable\\": {
            let value =
              Obj.magic(
                Js.Dict.unsafeGet(Obj.magic(value), \\"nullableOfNullable\\"),
              );

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some(
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   ),
              )
            | None => None
            };
          },

          \\"frag1\\": {
            let value: Fragments.ListFragment.Raw.t = Obj.magic(value);

            Fragments.ListFragment.parse(value);
          },

          \\"frag2\\": {
            let value: Fragments.ListFragment.Raw.t = Obj.magic(value);

            Fragments.ListFragment.parse(value);
          },
        };
      },

      \\"l4\\": {
        let value = value##l4;
        {

          \\"nullableOfNullable\\": {
            let value =
              Obj.magic(
                Js.Dict.unsafeGet(Obj.magic(value), \\"nullableOfNullable\\"),
              );

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some(
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   ),
              )
            | None => None
            };
          },

          \\"listFragment\\": {
            let value: Fragments.ListFragment.Raw.t = Obj.magic(value);

            Fragments.ListFragment.parse(value);
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"l1\\": {
        let value = value##l1;
        Fragments.ListFragment.serialize(value);
      },

      \\"l2\\": {
        let value = value##l2;
        (
          Obj.magic(
            Js.Array.reduce(
              GraphQL_PPX.deepMerge,
              Obj.magic(Js.Dict.empty): Js.Json.t,
              [|
                (
                  Obj.magic(Fragments.ListFragment.serialize(value##frag1)): Js.Json.t
                ),
                (
                  Obj.magic(Fragments.ListFragment.serialize(value##frag2)): Js.Json.t
                ),
              |],
            ),
          ): Raw.t_l2
        );
      },

      \\"l3\\": {
        let value = value##l3;
        (
          Obj.magic(
            Js.Array.reduce(
              GraphQL_PPX.deepMerge,
              Obj.magic(Js.Dict.empty): Js.Json.t,
              [|
                (
                  Obj.magic(Fragments.ListFragment.serialize(value##frag1)): Js.Json.t
                ),
                (
                  Obj.magic(Fragments.ListFragment.serialize(value##frag2)): Js.Json.t
                ),
              |],
            ),
          ): Raw.t_l3
        );
      },

      \\"l4\\": {
        let value = value##l4;
        (
          Obj.magic(
            Js.Array.reduce(
              GraphQL_PPX.deepMerge,
              Obj.magic(Js.Dict.empty): Js.Json.t,
              [|
                (
                  Obj.magic(
                    Fragments.ListFragment.serialize(value##listFragment),
                  ): Js.Json.t
                ),
              |],
            ),
          ): Raw.t_l4
        );
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Legacy interface.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
"
`;

exports[`Legacy lists.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"lists\\": t_lists}
    and t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"lists\\": t_lists}
  and t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  let parse: Raw.t => t =
    value => {

      \\"lists\\": {
        let value = value##lists;
        {

          \\"nullableOfNullable\\": {
            let value = value##nullableOfNullable;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some(
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   ),
              )
            | None => None
            };
          },

          \\"nullableOfNonNullable\\": {
            let value = value##nullableOfNonNullable;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value |> Js.Array.map(value => value))
            | None => None
            };
          },

          \\"nonNullableOfNullable\\": {
            let value = value##nonNullableOfNullable;

            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               );
          },

          \\"nonNullableOfNonNullable\\": {
            let value = value##nonNullableOfNonNullable;

            value |> Js.Array.map(value => value);
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"lists\\": {
        let value = value##lists;
        {

          \\"nullableOfNullable\\": {
            let value = value##nullableOfNullable;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return(
                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   ),
              )
            | None => Js.Nullable.null
            };
          },

          \\"nullableOfNonNullable\\": {
            let value = value##nullableOfNonNullable;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return(value |> Js.Array.map(value => value))
            | None => Js.Nullable.null
            };
          },

          \\"nonNullableOfNullable\\": {
            let value = value##nonNullableOfNullable;

            value
            |> Js.Array.map(value =>
                 switch (value) {
                 | Some(value) => Js.Nullable.return(value)
                 | None => Js.Nullable.null
                 }
               );
          },

          \\"nonNullableOfNonNullable\\": {
            let value = value##nonNullableOfNonNullable;

            value |> Js.Array.map(value => value);
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Legacy listsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"listsInput\\": string};
  };
  let query = \\"query ($nullableOfNullable: [String], $nullableOfNonNullable: [String!], $nonNullableOfNullable: [String]!, $nonNullableOfNonNullable: [String!]!)  {\\\\nlistsInput(arg: {nullableOfNullable: $nullableOfNullable, nullableOfNonNullable: $nullableOfNonNullable, nonNullableOfNullable: $nonNullableOfNullable, nonNullableOfNonNullable: $nonNullableOfNonNullable})  \\\\n}\\\\n\\";
  type t = {. \\"listsInput\\": string};
  type t_variables = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  let parse: Raw.t => t =
    value => {

      \\"listsInput\\": {
        let value = value##listsInput;

        value;
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"listsInput\\": {
        let value = value##listsInput;

        value;
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"nullableOfNullable\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      a
                      |> Array.map(b =>
                           switch (
                             (
                               a =>
                                 switch (a) {
                                 | None => None
                                 | Some(b) =>
                                   (a => Some(Js.Json.string(a)))(b)
                                 }
                             )(
                               b,
                             )
                           ) {
                           | Some(c) => c
                           | None => Js.Json.null
                           }
                         )
                      |> Js.Json.array,
                    )
                )(
                  b,
                )
              }
          )(
            inp##nullableOfNullable,
          ),
        ),
        (
          \\"nullableOfNonNullable\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      a
                      |> Array.map(b =>
                           switch ((a => Some(Js.Json.string(a)))(b)) {
                           | Some(c) => c
                           | None => Js.Json.null
                           }
                         )
                      |> Js.Json.array,
                    )
                )(
                  b,
                )
              }
          )(
            inp##nullableOfNonNullable,
          ),
        ),
        (
          \\"nonNullableOfNullable\\",
          (
            a =>
              Some(
                a
                |> Array.map(b =>
                     switch (
                       (
                         a =>
                           switch (a) {
                           | None => None
                           | Some(b) => (a => Some(Js.Json.string(a)))(b)
                           }
                       )(
                         b,
                       )
                     ) {
                     | Some(c) => c
                     | None => Js.Json.null
                     }
                   )
                |> Js.Json.array,
              )
          )(
            inp##nonNullableOfNullable,
          ),
        ),
        (
          \\"nonNullableOfNonNullable\\",
          (
            a =>
              Some(
                a
                |> Array.map(b =>
                     switch ((a => Some(Js.Json.string(a)))(b)) {
                     | Some(c) => c
                     | None => Js.Json.null
                     }
                   )
                |> Js.Json.array,
              )
          )(
            inp##nonNullableOfNonNullable,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar =
      (
        ~f,
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      ) =>
    f(
      serializeVariables(
        {

          \\"nullableOfNullable\\": nullableOfNullable,

          \\"nullableOfNonNullable\\": nullableOfNonNullable,

          \\"nonNullableOfNullable\\": nonNullableOfNullable,

          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        }: t_variables,
      ),
    );
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Legacy listsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"listsInput\\": string};
  };
  let query = \\"query ($arg: ListsInput!)  {\\\\nlistsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"listsInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_ListsInput}
  and t_variables_ListsInput = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  let parse: Raw.t => t =
    value => {

      \\"listsInput\\": {
        let value = value##listsInput;

        value;
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"listsInput\\": {
        let value = value##listsInput;

        value;
      },
    };
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (\\"arg\\", (a => Some(serializeInputObjectListsInput(a)))(inp##arg)),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectListsInput: t_variables_ListsInput => Js.Json.t =
    inp =>
      [|
        (
          \\"nullableOfNullable\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      a
                      |> Array.map(b =>
                           switch (
                             (
                               a =>
                                 switch (a) {
                                 | None => None
                                 | Some(b) =>
                                   (a => Some(Js.Json.string(a)))(b)
                                 }
                             )(
                               b,
                             )
                           ) {
                           | Some(c) => c
                           | None => Js.Json.null
                           }
                         )
                      |> Js.Json.array,
                    )
                )(
                  b,
                )
              }
          )(
            inp##nullableOfNullable,
          ),
        ),
        (
          \\"nullableOfNonNullable\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      a
                      |> Array.map(b =>
                           switch ((a => Some(Js.Json.string(a)))(b)) {
                           | Some(c) => c
                           | None => Js.Json.null
                           }
                         )
                      |> Js.Json.array,
                    )
                )(
                  b,
                )
              }
          )(
            inp##nullableOfNonNullable,
          ),
        ),
        (
          \\"nonNullableOfNullable\\",
          (
            a =>
              Some(
                a
                |> Array.map(b =>
                     switch (
                       (
                         a =>
                           switch (a) {
                           | None => None
                           | Some(b) => (a => Some(Js.Json.string(a)))(b)
                           }
                       )(
                         b,
                       )
                     ) {
                     | Some(c) => c
                     | None => Js.Json.null
                     }
                   )
                |> Js.Json.array,
              )
          )(
            inp##nonNullableOfNullable,
          ),
        ),
        (
          \\"nonNullableOfNonNullable\\",
          (
            a =>
              Some(
                a
                |> Array.map(b =>
                     switch ((a => Some(Js.Json.string(a)))(b)) {
                     | Some(c) => c
                     | None => Js.Json.null
                     }
                   )
                |> Js.Json.array,
              )
          )(
            inp##nonNullableOfNonNullable,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    )
  and makeInputObjectListsInput =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      )
      : t_variables_ListsInput => {

    \\"nullableOfNullable\\": nullableOfNullable,

    \\"nullableOfNonNullable\\": nullableOfNonNullable,

    \\"nonNullableOfNullable\\": nonNullableOfNullable,

    \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
  };
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Legacy mutation.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"mutationWithError\\": t_mutationWithError}
    and t_mutationWithError = {
      .
      \\"value\\": Js.Nullable.t(t_mutationWithError_value),
      \\"errors\\": Js.Nullable.t(array(t_mutationWithError_errors)),
    }
    and t_mutationWithError_errors = {
      .
      \\"field\\": t_mutationWithError_errors_field,
      \\"message\\": string,
    }
    and t_mutationWithError_errors_field = string
    and t_mutationWithError_value = {. \\"stringField\\": string};
  };
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nvalue  {\\\\nstringField  \\\\n}\\\\n\\\\nerrors  {\\\\nfield  \\\\nmessage  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"mutationWithError\\": t_mutationWithError}
  and t_mutationWithError = {
    .
    \\"value\\": option(t_mutationWithError_value),
    \\"errors\\": option(array(t_mutationWithError_errors)),
  }
  and t_mutationWithError_errors = {
    .
    \\"field\\": t_mutationWithError_errors_field,
    \\"message\\": string,
  }
  and t_mutationWithError_errors_field = [
    | \`FutureAddedValue(string)
    | \`FIRST
    | \`SECOND
    | \`THIRD
  ]
  and t_mutationWithError_value = {. \\"stringField\\": string};
  let parse: Raw.t => t =
    value => {

      \\"mutationWithError\\": {
        let value = value##mutationWithError;
        {

          \\"value\\": {
            let value = value##value;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some({

                \\"stringField\\": {
                  let value = value##stringField;

                  value;
                },
              })
            | None => None
            };
          },

          \\"errors\\": {
            let value = value##errors;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some(
                value
                |> Js.Array.map(value =>
                     {

                       \\"field\\": {
                         let value = value##field;
                         switch (Obj.magic(value: string)) {
                         | \\"FIRST\\" => \`FIRST
                         | \\"SECOND\\" => \`SECOND
                         | \\"THIRD\\" => \`THIRD
                         | other => \`FutureAddedValue(other)
                         };
                       },

                       \\"message\\": {
                         let value = value##message;

                         value;
                       },
                     }
                   ),
              )
            | None => None
            };
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"mutationWithError\\": {
        let value = value##mutationWithError;
        {

          \\"value\\": {
            let value = value##value;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return({

                \\"stringField\\": {
                  let value = value##stringField;

                  value;
                },
              })
            | None => Js.Nullable.null
            };
          },

          \\"errors\\": {
            let value = value##errors;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return(
                value
                |> Js.Array.map(value =>
                     {

                       \\"field\\": {
                         let value = value##field;
                         switch (value) {
                         | \`FIRST => \\"FIRST\\"
                         | \`SECOND => \\"SECOND\\"
                         | \`THIRD => \\"THIRD\\"
                         | \`FutureAddedValue(other) => other
                         };
                       },

                       \\"message\\": {
                         let value = value##message;

                         value;
                       },
                     }
                   ),
              )
            | None => Js.Nullable.null
            };
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Legacy mutationWithArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"optionalInputArgs\\": string};
  };
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t = {. \\"optionalInputArgs\\": string};
  type t_variables = {. \\"required\\": string};
  let parse: Raw.t => t =
    value => {

      \\"optionalInputArgs\\": {
        let value = value##optionalInputArgs;

        value;
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"optionalInputArgs\\": {
        let value = value##optionalInputArgs;

        value;
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|(\\"required\\", (a => Some(Js.Json.string(a)))(inp##required))|]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~required, ()) =>
    f(
      serializeVariables(
        {

          \\"required\\": required,
        }: t_variables,
      ),
    );
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Legacy nested.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type record = {
  f1: string,
  f2: string,
};

module MyQuery = {
  module Raw = {
    type t = {
      .
      \\"first\\": t_first,
      \\"second\\": t_second,
      \\"let_\\": t_let,
    }
    and t_let = {. \\"inner\\": Js.Nullable.t(t_let_inner)}
    and t_let_inner = {. \\"inner\\": Js.Nullable.t(t_let_inner_inner)}
    and t_let_inner_inner = {. \\"field\\": string}
    and t_second = {. \\"inner\\": Js.Nullable.t(t_second_inner)}
    and t_second_inner = {. \\"inner\\": Js.Nullable.t(t_second_inner_inner)}
    and t_second_inner_inner = {
      f1: string,
      f2: string,
    }
    and t_first = {. \\"inner\\": Js.Nullable.t(t_first_inner)}
    and t_first_inner = {. \\"inner\\": Js.Nullable.t(t_first_inner_inner)}
    and t_first_inner_inner = {. \\"field\\": string};
  };
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nsecond: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nf1: field  \\\\nf2: field  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nlet: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {
    .
    \\"first\\": t_first,
    \\"second\\": t_second,
    \\"let_\\": t_let,
  }
  and t_let = {. \\"inner\\": option(t_let_inner)}
  and t_let_inner = {. \\"inner\\": option(t_let_inner_inner)}
  and t_let_inner_inner = {. \\"field\\": string}
  and t_second = {. \\"inner\\": option(t_second_inner)}
  and t_second_inner = {. \\"inner\\": option(t_second_inner_inner)}
  and t_second_inner_inner = {
    f1: string,
    f2: string,
  }
  and t_first = {. \\"inner\\": option(t_first_inner)}
  and t_first_inner = {. \\"inner\\": option(t_first_inner_inner)}
  and t_first_inner_inner = {. \\"field\\": string};
  let parse: Raw.t => t =
    value => {

      \\"first\\": {
        let value = value##first;
        {

          \\"inner\\": {
            let value = value##inner;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some({

                \\"inner\\": {
                  let value = value##inner;

                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some({

                      \\"field\\": {
                        let value = value##field;

                        value;
                      },
                    })
                  | None => None
                  };
                },
              })
            | None => None
            };
          },
        };
      },

      \\"second\\": {
        let value = value##second;
        {

          \\"inner\\": {
            let value = value##inner;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some({

                \\"inner\\": {
                  let value = value##inner;

                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some({

                      \\"f1\\": {
                        let value = value##f1;

                        value;
                      },

                      \\"f2\\": {
                        let value = value##f2;

                        value;
                      },
                    })
                  | None => None
                  };
                },
              })
            | None => None
            };
          },
        };
      },

      \\"let_\\": {
        let value = value##let_;
        {

          \\"inner\\": {
            let value = value##inner;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some({

                \\"inner\\": {
                  let value = value##inner;

                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some({

                      \\"field\\": {
                        let value = value##field;

                        value;
                      },
                    })
                  | None => None
                  };
                },
              })
            | None => None
            };
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"first\\": {
        let value = value##first;
        {

          \\"inner\\": {
            let value = value##inner;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return({

                \\"inner\\": {
                  let value = value##inner;

                  switch (value) {
                  | Some(value) =>
                    Js.Nullable.return({

                      \\"field\\": {
                        let value = value##field;

                        value;
                      },
                    })
                  | None => Js.Nullable.null
                  };
                },
              })
            | None => Js.Nullable.null
            };
          },
        };
      },

      \\"second\\": {
        let value = value##second;
        {

          \\"inner\\": {
            let value = value##inner;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return({

                \\"inner\\": {
                  let value = value##inner;

                  switch (value) {
                  | Some(value) =>
                    Js.Nullable.return({

                      \\"f1\\": {
                        let value = value##f1;

                        value;
                      },

                      \\"f2\\": {
                        let value = value##f2;

                        value;
                      },
                    })
                  | None => Js.Nullable.null
                  };
                },
              })
            | None => Js.Nullable.null
            };
          },
        };
      },

      \\"let_\\": {
        let value = value##let_;
        {

          \\"inner\\": {
            let value = value##inner;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return({

                \\"inner\\": {
                  let value = value##inner;

                  switch (value) {
                  | Some(value) =>
                    Js.Nullable.return({

                      \\"field\\": {
                        let value = value##field;

                        value;
                      },
                    })
                  | None => Js.Nullable.null
                  };
                },
              })
            | None => Js.Nullable.null
            };
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Legacy nonrecursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"nonrecursiveInput\\": string};
  };
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"nonrecursiveInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    .
    \\"field\\": option(string),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  let parse: Raw.t => t =
    value => {

      \\"nonrecursiveInput\\": {
        let value = value##nonrecursiveInput;

        value;
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"nonrecursiveInput\\": {
        let value = value##nonrecursiveInput;

        value;
      },
    };
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (a => Some(serializeInputObjectNonrecursiveInput(a)))(inp##arg),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Js.Json.t =
    inp =>
      [|
        (
          \\"field\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##field,
          ),
        ),
        (
          \\"enum\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      switch (a) {
                      | \`FIRST => Js.Json.string(\\"FIRST\\")
                      | \`SECOND => Js.Json.string(\\"SECOND\\")
                      | \`THIRD => Js.Json.string(\\"THIRD\\")
                      },
                    )
                )(
                  b,
                )
              }
          )(
            inp##enum,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    )
  and makeInputObjectNonrecursiveInput =
      (~field=?, ~enum=?, ()): t_variables_NonrecursiveInput => {

    \\"field\\": field,

    \\"enum\\": enum,
  };
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Legacy pokedexApolloMode.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"pokemon\\": Js.Nullable.t(t_pokemon)}
    and t_pokemon = {
      .
      \\"id\\": string,
      \\"name\\": Js.Nullable.t(string),
    };
  };
  let query = \\"query   {\\\\npokemon(name: \\\\\\"Pikachu\\\\\\")  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"pokemon\\": option(t_pokemon)}
  and t_pokemon = {
    .
    \\"id\\": string,
    \\"name\\": option(string),
  };
  let parse: Raw.t => t =
    value => {

      \\"pokemon\\": {
        let value = value##pokemon;

        switch (Js.toOption(value)) {
        | Some(value) =>
          Some({

            \\"id\\": {
              let value = value##id;

              value;
            },

            \\"name\\": {
              let value = value##name;

              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
          })
        | None => None
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"pokemon\\": {
        let value = value##pokemon;

        switch (value) {
        | Some(value) =>
          Js.Nullable.return({

            \\"id\\": {
              let value = value##id;

              value;
            },

            \\"name\\": {
              let value = value##name;

              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            },
          })
        | None => Js.Nullable.null
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Legacy pokedexScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"pokemon\\": Js.Nullable.t(t_pokemon)}
    and t_pokemon = {
      .
      \\"id\\": string,
      \\"name\\": Js.Nullable.t(string),
    };
  };
  let query = \\"query pokemon($id: String, $name: String)  {\\\\npokemon(name: $name, id: $id)  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"pokemon\\": option(t_pokemon)}
  and t_pokemon = {
    .
    \\"id\\": string,
    \\"name\\": option(string),
  };
  type t_variables = {
    .
    \\"id\\": option(string),
    \\"name\\": option(string),
  };
  let parse: Raw.t => t =
    value => {

      \\"pokemon\\": {
        let value = value##pokemon;

        switch (Js.toOption(value)) {
        | Some(value) =>
          Some({

            \\"id\\": {
              let value = value##id;

              value;
            },

            \\"name\\": {
              let value = value##name;

              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
          })
        | None => None
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"pokemon\\": {
        let value = value##pokemon;

        switch (value) {
        | Some(value) =>
          Js.Nullable.return({

            \\"id\\": {
              let value = value##id;

              value;
            },

            \\"name\\": {
              let value = value##name;

              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            },
          })
        | None => Js.Nullable.null
        };
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"id\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##id,
          ),
        ),
        (
          \\"name\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##name,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~id=?, ~name=?, ()) =>
    f(
      serializeVariables(
        {

          \\"id\\": id,

          \\"name\\": name,
        }: t_variables,
      ),
    );
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Legacy record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type scalars = {
  string,
  int,
};

type dog = {
  name: string,
  barkVolume: float,
};

type oneFieldQuery = {nullableString: option(string)};

module MyQuery = {
  module Raw = {
    type t = {. \\"variousScalars\\": scalars};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"variousScalars\\": scalars};
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"int\\": {
            let value = value##int;

            value;
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"int\\": {
            let value = value##int;

            value;
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};

module OneFieldQuery = {
  module Raw = {
    type t = {. \\"variousScalars\\": t_variousScalars}
    and t_variousScalars = {nullableString: Js.Nullable.t(string)};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"variousScalars\\": t_variousScalars}
  and t_variousScalars = {nullableString: option(string)};
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};

module ExternalFragmentQuery = {
  module Fragment = {
    let query = \\"fragment Fragment on VariousScalars   {\\\\nstring  \\\\nint  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        string,
        int,
      };
      type t_VariousScalars = t;
    };
    type t = {
      string,
      int,
    };
    type t_VariousScalars = t;

    let parse = (value: Raw.t) => {

      \\"string\\": {
        let value = value##string;

        value;
      },

      \\"int\\": {
        let value = value##int;

        value;
      },
    };
    let serialize: t => Raw.t =
      value => {

        \\"string\\": {
          let value = value##string;

          value;
        },

        \\"int\\": {
          let value = value##int;

          value;
        },
      };
    let name = \\"Fragment\\";
  };
  module Untitled1 = {
    module Raw = {
      type t = {. \\"variousScalars\\": Fragment.Raw.t};
    };
    let query =
      (
        (\\"query   {\\\\nvariousScalars  {\\\\n...\\" ++ Fragment.name)
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ Fragment.query;
    type t = {. \\"variousScalars\\": Fragment.t};
    let parse: Raw.t => t =
      value => {

        \\"variousScalars\\": {
          let value = value##variousScalars;

          Fragment.parse(value);
        },
      };
    let serialize: t => Raw.t =
      value => {

        \\"variousScalars\\": {
          let value = value##variousScalars;
          Fragment.serialize(value);
        },
      };
    let makeVar = (~f, ()) => f(Js.Json.null);
    let make =
      makeVar(~f=variables =>
        {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
      );
    let makeWithVariables = variables => {
      \\"query\\": query,
      \\"variables\\": serializeVariables(variables),
      \\"parse\\": parse,
    };
    let definition = (parse, query, makeVar);
  };
};

module InlineFragmentQuery = {
  module Raw = {
    type t = {. \\"dogOrHuman\\": t_dogOrHuman}
    and t_dogOrHuman
    and t_dogOrHuman_Dog = {
      name: string,
      barkVolume: float,
    };
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"dogOrHuman\\": t_dogOrHuman}
  and t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ]
  and t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  let parse: Raw.t => t =
    value => {

      \\"dogOrHuman\\": {
        let value = value##dogOrHuman;
        [@metaloc loc]
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                {

                  \\"name\\": {
                    let value = value##name;

                    value;
                  },

                  \\"barkVolume\\": {
                    let value = value##barkVolume;

                    value;
                  },
                };
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"dogOrHuman\\": {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic({

              \\"name\\": {
                let value = value##name;

                value;
              },

              \\"barkVolume\\": {
                let value = value##barkVolume;

                value;
              },
            }): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};

module UnionExternalFragmentQuery = {
  module DogFragment = {
    let query = \\"fragment DogFragment on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        name: string,
        barkVolume: float,
      };
      type t_Dog = t;
    };
    type t = {
      name: string,
      barkVolume: float,
    };
    type t_Dog = t;

    let parse = (value: Raw.t) => {

      \\"name\\": {
        let value = value##name;

        value;
      },

      \\"barkVolume\\": {
        let value = value##barkVolume;

        value;
      },
    };
    let serialize: t => Raw.t =
      value => {

        \\"name\\": {
          let value = value##name;

          value;
        },

        \\"barkVolume\\": {
          let value = value##barkVolume;

          value;
        },
      };
    let name = \\"DogFragment\\";
  };
  module Untitled1 = {
    module Raw = {
      type t = {. \\"dogOrHuman\\": t_dogOrHuman}
      and t_dogOrHuman;
    };
    let query =
      (
        (
          \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n...\\"
          ++ DogFragment.name
        )
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ DogFragment.query;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman}
    and t_dogOrHuman = [
      | \`FutureAddedValue(Js.Json.t)
      | \`Dog(DogFragment.t)
    ];
    let parse: Raw.t => t =
      value => {

        \\"dogOrHuman\\": {
          let value = value##dogOrHuman;
          [@metaloc loc]
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);

                  DogFragment.parse(value);
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        },
      };
    let serialize: t => Raw.t =
      value => {

        \\"dogOrHuman\\": {
          let value = value##dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(DogFragment.serialize(value)): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        },
      };
    let makeVar = (~f, ()) => f(Js.Json.null);
    let make =
      makeVar(~f=variables =>
        {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
      );
    let makeWithVariables = variables => {
      \\"query\\": query,
      \\"variables\\": serializeVariables(variables),
      \\"parse\\": parse,
    };
    let definition = (parse, query, makeVar);
  };
};
"
`;

exports[`Legacy recursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"recursiveInput\\": string};
  };
  let query = \\"query ($arg: RecursiveInput!)  {\\\\nrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"recursiveInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_RecursiveInput}
  and t_variables_RecursiveInput = {
    .
    \\"otherField\\": option(string),
    \\"inner\\": option(t_variables_RecursiveInput),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  let parse: Raw.t => t =
    value => {

      \\"recursiveInput\\": {
        let value = value##recursiveInput;

        value;
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"recursiveInput\\": {
        let value = value##recursiveInput;

        value;
      },
    };
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (a => Some(serializeInputObjectRecursiveInput(a)))(inp##arg),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectRecursiveInput:
    t_variables_RecursiveInput => Js.Json.t =
    inp =>
      [|
        (
          \\"otherField\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##otherField,
          ),
        ),
        (
          \\"inner\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (a => Some(serializeInputObjectRecursiveInput(a)))(b)
              }
          )(
            inp##inner,
          ),
        ),
        (
          \\"enum\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      switch (a) {
                      | \`FIRST => Js.Json.string(\\"FIRST\\")
                      | \`SECOND => Js.Json.string(\\"SECOND\\")
                      | \`THIRD => Js.Json.string(\\"THIRD\\")
                      },
                    )
                )(
                  b,
                )
              }
          )(
            inp##enum,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    )
  and makeInputObjectRecursiveInput =
      (~otherField=?, ~inner=?, ~enum=?, ()): t_variables_RecursiveInput => {

    \\"otherField\\": otherField,

    \\"inner\\": inner,

    \\"enum\\": enum,
  };
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Legacy scalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"variousScalars\\": t_variousScalars}
    and t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"variousScalars\\": t_variousScalars}
  and t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Legacy scalarsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"scalarsInput\\": string};
  };
  let query = \\"query ($nullableString: String, $string: String!, $nullableInt: Int, $int: Int!, $nullableFloat: Float, $float: Float!, $nullableBoolean: Boolean, $boolean: Boolean!, $nullableID: ID, $id: ID!)  {\\\\nscalarsInput(arg: {nullableString: $nullableString, string: $string, nullableInt: $nullableInt, int: $int, nullableFloat: $nullableFloat, float: $float, nullableBoolean: $nullableBoolean, boolean: $boolean, nullableID: $nullableID, id: $id})  \\\\n}\\\\n\\";
  type t = {. \\"scalarsInput\\": string};
  type t_variables = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"scalarsInput\\": {
        let value = value##scalarsInput;

        value;
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"scalarsInput\\": {
        let value = value##scalarsInput;

        value;
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"nullableString\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##nullableString,
          ),
        ),
        (\\"string\\", (a => Some(Js.Json.string(a)))(inp##string)),
        (
          \\"nullableInt\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.number(float_of_int(a))))(b)
              }
          )(
            inp##nullableInt,
          ),
        ),
        (\\"int\\", (a => Some(Js.Json.number(float_of_int(a))))(inp##int)),
        (
          \\"nullableFloat\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.number(a)))(b)
              }
          )(
            inp##nullableFloat,
          ),
        ),
        (\\"float\\", (a => Some(Js.Json.number(a)))(inp##float)),
        (
          \\"nullableBoolean\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.boolean(a)))(b)
              }
          )(
            inp##nullableBoolean,
          ),
        ),
        (\\"boolean\\", (a => Some(Js.Json.boolean(a)))(inp##boolean)),
        (
          \\"nullableID\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##nullableID,
          ),
        ),
        (\\"id\\", (a => Some(Js.Json.string(a)))(inp##id)),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar =
      (
        ~f,
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      ) =>
    f(
      serializeVariables(
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,

          \\"nullableInt\\": nullableInt,

          \\"int\\": int,

          \\"nullableFloat\\": nullableFloat,

          \\"float\\": float,

          \\"nullableBoolean\\": nullableBoolean,

          \\"boolean\\": boolean,

          \\"nullableID\\": nullableID,

          \\"id\\": id,
        }: t_variables,
      ),
    );
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Legacy scalarsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"scalarsInput\\": string};
  };
  let query = \\"query ($arg: VariousScalarsInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"scalarsInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_VariousScalarsInput}
  and t_variables_VariousScalarsInput = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"scalarsInput\\": {
        let value = value##scalarsInput;

        value;
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"scalarsInput\\": {
        let value = value##scalarsInput;

        value;
      },
    };
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (a => Some(serializeInputObjectVariousScalarsInput(a)))(inp##arg),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectVariousScalarsInput:
    t_variables_VariousScalarsInput => Js.Json.t =
    inp =>
      [|
        (
          \\"nullableString\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##nullableString,
          ),
        ),
        (\\"string\\", (a => Some(Js.Json.string(a)))(inp##string)),
        (
          \\"nullableInt\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.number(float_of_int(a))))(b)
              }
          )(
            inp##nullableInt,
          ),
        ),
        (\\"int\\", (a => Some(Js.Json.number(float_of_int(a))))(inp##int)),
        (
          \\"nullableFloat\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.number(a)))(b)
              }
          )(
            inp##nullableFloat,
          ),
        ),
        (\\"float\\", (a => Some(Js.Json.number(a)))(inp##float)),
        (
          \\"nullableBoolean\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.boolean(a)))(b)
              }
          )(
            inp##nullableBoolean,
          ),
        ),
        (\\"boolean\\", (a => Some(Js.Json.boolean(a)))(inp##boolean)),
        (
          \\"nullableID\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##nullableID,
          ),
        ),
        (\\"id\\", (a => Some(Js.Json.string(a)))(inp##id)),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    )
  and makeInputObjectVariousScalarsInput =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      )
      : t_variables_VariousScalarsInput => {

    \\"nullableString\\": nullableString,

    \\"string\\": string,

    \\"nullableInt\\": nullableInt,

    \\"int\\": int,

    \\"nullableFloat\\": nullableFloat,

    \\"float\\": float,

    \\"nullableBoolean\\": nullableBoolean,

    \\"boolean\\": boolean,

    \\"nullableID\\": nullableID,

    \\"id\\": id,
  };
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Legacy skipDirectives.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {
      .
      \\"v1\\": t_v1,
      \\"v2\\": t_v2,
    }
    and t_v2 = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": Js.Nullable.t(string),
    }
    and t_v1 = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": Js.Nullable.t(string),
    };
  };
  let query = \\"query ($var: Boolean!)  {\\\\nv1: variousScalars  {\\\\nnullableString @skip(if: $var) \\\\nstring @skip(if: $var) \\\\n}\\\\n\\\\nv2: variousScalars  {\\\\nnullableString @include(if: $var) \\\\nstring @include(if: $var) \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {
    .
    \\"v1\\": t_v1,
    \\"v2\\": t_v2,
  }
  and t_v2 = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": option(string),
  }
  and t_v1 = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": option(string),
  };
  type t_variables = {. \\"var\\": bool};
  let parse: Raw.t => t =
    value => {

      \\"v1\\": {
        let value = value##v1;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"string\\": {
            let value = value##string;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },
        };
      },

      \\"v2\\": {
        let value = value##v2;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"string\\": {
            let value = value##string;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"v1\\": {
        let value = value##v1;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"string\\": {
            let value = value##string;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },
        };
      },

      \\"v2\\": {
        let value = value##v2;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"string\\": {
            let value = value##string;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },
        };
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|(\\"var\\", (a => Some(Js.Json.boolean(a)))(inp##var))|]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~var, ()) =>
    f(
      serializeVariables(
        {

          \\"var\\": var,
        }: t_variables,
      ),
    );
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Legacy subscription.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"simpleSubscription\\": t_simpleSubscription}
    and t_simpleSubscription
    and t_simpleSubscription_Human = {. \\"name\\": string}
    and t_simpleSubscription_Dog = {. \\"name\\": string};
  };
  let query = \\"subscription   {\\\\nsimpleSubscription  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"simpleSubscription\\": t_simpleSubscription}
  and t_simpleSubscription = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_simpleSubscription_Dog)
    | \`Human(t_simpleSubscription_Human)
  ]
  and t_simpleSubscription_Human = {. \\"name\\": string}
  and t_simpleSubscription_Dog = {. \\"name\\": string};
  let parse: Raw.t => t =
    value => {

      \\"simpleSubscription\\": {
        let value = value##simpleSubscription;
        [@metaloc loc]
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_simpleSubscription_Dog = Obj.magic(value);
                {

                  \\"name\\": {
                    let value = value##name;

                    value;
                  },
                };
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_simpleSubscription_Human = Obj.magic(value);
                {

                  \\"name\\": {
                    let value = value##name;

                    value;
                  },
                };
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_simpleSubscription
        );
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"simpleSubscription\\": {
        let value = value##simpleSubscription;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic({

              \\"name\\": {
                let value = value##name;

                value;
              },
            }): Raw.t_simpleSubscription
          )
        | \`Human(value) => (
            Obj.magic({

              \\"name\\": {
                let value = value##name;

                value;
              },
            }): Raw.t_simpleSubscription
          )
        | \`FutureAddedValue(value) => (
            Obj.magic(value): Raw.t_simpleSubscription
          )
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Legacy tagged_template.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"variousScalars\\": t_variousScalars}
    and t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"variousScalars\\": t_variousScalars}
  and t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};

module MyQuery2 = {
  module Raw = {
    type t = {. \\"variousScalars\\": t_variousScalars}
    and t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  %raw
  \\"let { graphql } = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t = {. \\"variousScalars\\": t_variousScalars}
  and t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};

module MyQuery3 = {
  module Raw = {
    type t = {. \\"variousScalars\\": t_variousScalars}
    and t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  %raw
  \\"let { graphql } = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t = {. \\"variousScalars\\": t_variousScalars}
  and t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};

module MyQuery4 = {
  module Raw = {
    type t = {. \\"variousScalars\\": t_variousScalars}
    and t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  %raw
  \\"let graphql = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t = {. \\"variousScalars\\": t_variousScalars}
  and t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Legacy typename.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"first\\": t_first}
    and t_first = {
      .
      \\"__typename\\": string,
      \\"inner\\": Js.Nullable.t(t_first_inner),
    }
    and t_first_inner = {
      .
      \\"__typename\\": string,
      \\"inner\\": Js.Nullable.t(t_first_inner_inner),
    }
    and t_first_inner_inner = {
      .
      \\"__typename\\": string,
      \\"field\\": string,
    };
  };
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"first\\": t_first}
  and t_first = {
    .
    \\"__typename\\": string,
    \\"inner\\": option(t_first_inner),
  }
  and t_first_inner = {
    .
    \\"__typename\\": string,
    \\"inner\\": option(t_first_inner_inner),
  }
  and t_first_inner_inner = {
    .
    \\"__typename\\": string,
    \\"field\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"first\\": {
        let value = value##first;
        {

          \\"__typename\\": {
            let value = value##__typename;

            value;
          },

          \\"inner\\": {
            let value = value##inner;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some({

                \\"__typename\\": {
                  let value = value##__typename;

                  value;
                },

                \\"inner\\": {
                  let value = value##inner;

                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some({

                      \\"__typename\\": {
                        let value = value##__typename;

                        value;
                      },

                      \\"field\\": {
                        let value = value##field;

                        value;
                      },
                    })
                  | None => None
                  };
                },
              })
            | None => None
            };
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"first\\": {
        let value = value##first;
        {

          \\"__typename\\": {
            let value = value##__typename;

            value;
          },

          \\"inner\\": {
            let value = value##inner;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return({

                \\"__typename\\": {
                  let value = value##__typename;

                  value;
                },

                \\"inner\\": {
                  let value = value##inner;

                  switch (value) {
                  | Some(value) =>
                    Js.Nullable.return({

                      \\"__typename\\": {
                        let value = value##__typename;

                        value;
                      },

                      \\"field\\": {
                        let value = value##field;

                        value;
                      },
                    })
                  | None => Js.Nullable.null
                  };
                },
              })
            | None => Js.Nullable.null
            };
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Legacy union.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"dogOrHuman\\": t_dogOrHuman}
    and t_dogOrHuman
    and t_dogOrHuman_Human = {. \\"name\\": string}
    and t_dogOrHuman_Dog = {
      .
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"dogOrHuman\\": t_dogOrHuman}
  and t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ]
  and t_dogOrHuman_Human = {. \\"name\\": string}
  and t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  let parse: Raw.t => t =
    value => {

      \\"dogOrHuman\\": {
        let value = value##dogOrHuman;
        [@metaloc loc]
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                {

                  \\"name\\": {
                    let value = value##name;

                    value;
                  },

                  \\"barkVolume\\": {
                    let value = value##barkVolume;

                    value;
                  },
                };
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                {

                  \\"name\\": {
                    let value = value##name;

                    value;
                  },
                };
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"dogOrHuman\\": {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic({

              \\"name\\": {
                let value = value##name;

                value;
              },

              \\"barkVolume\\": {
                let value = value##barkVolume;

                value;
              },
            }): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic({

              \\"name\\": {
                let value = value##name;

                value;
              },
            }): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Legacy unionPartial.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"dogOrHuman\\": t_dogOrHuman}
    and t_dogOrHuman
    and t_dogOrHuman_Dog = {
      .
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"dogOrHuman\\": t_dogOrHuman}
  and t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ]
  and t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  let parse: Raw.t => t =
    value => {

      \\"dogOrHuman\\": {
        let value = value##dogOrHuman;
        [@metaloc loc]
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                {

                  \\"name\\": {
                    let value = value##name;

                    value;
                  },

                  \\"barkVolume\\": {
                    let value = value##barkVolume;

                    value;
                  },
                };
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"dogOrHuman\\": {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic({

              \\"name\\": {
                let value = value##name;

                value;
              },

              \\"barkVolume\\": {
                let value = value##barkVolume;

                value;
              },
            }): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Objects argNamedQuery.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"argNamedQuery\\": int};
  };
  let query = \\"query ($query: String!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\";
  type t = {. \\"argNamedQuery\\": int};
  type t_variables = {. \\"query\\": string};
  let parse: Raw.t => t =
    value => {

      \\"argNamedQuery\\": {
        let value = value##argNamedQuery;

        value;
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"argNamedQuery\\": {
        let value = value##argNamedQuery;

        value;
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|(\\"query\\", (a => Some(Js.Json.string(a)))(inp##query))|]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~query, ()) =>
    f(
      serializeVariables(
        {

          \\"query\\": query,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Objects bug1.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module GraphQL_PPX = {
  let%private clone: Js.Dict.t('a) => Js.Dict.t('a) =
    a => Obj.magic(Js.Obj.assign(Obj.magic(Js.Obj.empty()), Obj.magic(a)));

  let rec deepMerge = (json1: Js.Json.t, json2: Js.Json.t) =>
    switch (
      (
        Obj.magic(json1) == Js.null,
        Js_array2.isArray(json1),
        Js.typeof(json1) == \\"object\\",
      ),
      (
        Obj.magic(json2) == Js.null,
        Js_array2.isArray(json2),
        Js.typeof(json2) == \\"object\\",
      ),
    ) {
    | ((_, true, _), (_, true, _)) => (
        Obj.magic(
          Js.Array.mapi(
            (el1, idx) => {
              let el2 = Js.Array.unsafe_get(Obj.magic(json2), idx);

              Js.typeof(el2) == \\"object\\" ? deepMerge(el1, el2) : el2;
            },
            Obj.magic(json1),
          ),
        ): Js.Json.t
      )

    | ((false, false, true), (false, false, true)) =>
      let obj1 = clone(Obj.magic(json1));
      let obj2 = Obj.magic(json2);
      Js.Dict.keys(obj2)
      |> Js.Array.forEach(key =>
           let existingVal: Js.Json.t = Js.Dict.unsafeGet(obj1, key);
           let newVal: Js.Json.t = Js.Dict.unsafeGet(obj1, key);
           Js.Dict.set(
             obj1,
             key,
             Js.typeof(existingVal) != \\"object\\"
               ? newVal : Obj.magic(deepMerge(existingVal, newVal)),
           );
         );
      Obj.magic(obj1);

    | ((_, _, _), (_, _, _)) => json2
    };
};

module LargeAvatars_User = {
  let query = \\"fragment LargeAvatars_User on User   {\\\\nid  \\\\nname  \\\\ngeneralStatistics  {\\\\nactivityCount  \\\\n}\\\\n\\\\n}\\\\n\\";
  module Raw = {
    type t = {
      id: string,
      name: string,
      generalStatistics: t_generalStatistics,
    }
    and t_generalStatistics = {activityCount: int};
    type t_User = t;
  };
  type t = {
    id: string,
    name: string,
    generalStatistics: t_generalStatistics,
  }
  and t_generalStatistics = {activityCount: int};
  type t_User = t;

  let parse = (value: Raw.t): t => {

    id: {
      let value = (value: Raw.t).id;

      value;
    },

    name: {
      let value = (value: Raw.t).name;

      value;
    },

    generalStatistics: {
      let value = (value: Raw.t).generalStatistics;
      (
        {

          activityCount: {
            let value = (value: Raw.t_generalStatistics).activityCount;

            value;
          },
        }: t_generalStatistics
      );
    },
  };
  let serialize: t => Raw.t =
    (value) => (
      {

        id: {
          let value = (value: t).id;

          value;
        },

        name: {
          let value = (value: t).name;

          value;
        },

        generalStatistics: {
          let value = (value: t).generalStatistics;
          (
            {

              activityCount: {
                let value = (value: t_generalStatistics).activityCount;

                value;
              },
            }: Raw.t_generalStatistics
          );
        },
      }: Raw.t
    );
  let name = \\"LargeAvatars_User\\";
};
module Small_Avatar_User = {
  let query = \\"fragment Small_Avatar_User on User   {\\\\nid  \\\\nname  \\\\nsmallAvatar: avatar(scaleFactor: $pixelRatio, width: 60, height: 60)  {\\\\nurl  \\\\ncolor  \\\\n}\\\\n\\\\n}\\\\n\\";
  module Raw = {
    type t = {
      .
      \\"id\\": string,
      \\"name\\": string,
      \\"smallAvatar\\": Js.Nullable.t(t_smallAvatar),
    }
    and t_smallAvatar = {
      .
      \\"url\\": string,
      \\"color\\": Js.Nullable.t(string),
    };
    type t_User = t;
  };
  type t = {
    .
    \\"id\\": string,
    \\"name\\": string,
    \\"smallAvatar\\": option(t_smallAvatar),
  }
  and t_smallAvatar = {
    .
    \\"url\\": string,
    \\"color\\": option(string),
  };
  type t_User = t;

  let parse = (~pixelRatio as _pixelRatio: [ | \`Float_NonNull], value: Raw.t) => {

    \\"id\\": {
      let value = value##id;

      value;
    },

    \\"name\\": {
      let value = value##name;

      value;
    },

    \\"smallAvatar\\": {
      let value = value##smallAvatar;

      switch (Js.toOption(value)) {
      | Some(value) =>
        Some({

          \\"url\\": {
            let value = value##url;

            value;
          },

          \\"color\\": {
            let value = value##color;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },
        })
      | None => None
      };
    },
  };
  let serialize: t => Raw.t =
    value => {

      \\"id\\": {
        let value = value##id;

        value;
      },

      \\"name\\": {
        let value = value##name;

        value;
      },

      \\"smallAvatar\\": {
        let value = value##smallAvatar;

        switch (value) {
        | Some(value) =>
          Js.Nullable.return({

            \\"url\\": {
              let value = value##url;

              value;
            },

            \\"color\\": {
              let value = value##color;

              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            },
          })
        | None => Js.Nullable.null
        };
      },
    };
  let name = \\"Small_Avatar_User\\";
};

module Query = {
  module Raw = {
    type t = {. \\"activityFeedItem\\": Js.Nullable.t(t_activityFeedItem)}
    and t_activityFeedItem = {
      .
      \\"id\\": string,
      \\"duration\\": Js.Nullable.t(int),
      \\"rating\\": Js.Nullable.t(int),
      \\"activity\\": t_activityFeedItem_activity,
      \\"participants\\": array(t_activityFeedItem_participants),
    }
    and t_activityFeedItem_participants
    and t_activityFeedItem_participants_generalStatistics = {
      .
      \\"activityCount\\": int,
    }
    and t_activityFeedItem_activity = {
      .
      \\"id\\": string,
      \\"title\\": Js.Nullable.t(string),
      \\"description\\": Js.Nullable.t(string),
      \\"duration\\": Js.Nullable.t(int),
      \\"cognitiveAspects\\": array(t_activityFeedItem_activity_cognitiveAspects),
    }
    and t_activityFeedItem_activity_cognitiveAspects = {
      .
      \\"id\\": string,
      \\"name\\": Js.Nullable.t(string),
    };
  };
  let query =
    (
      (
        (
          (
            (
              \\"query ActivityOverviewQuery($id: ID!, $pixelRatio: Float!)  {\\\\nactivityFeedItem(id: $id)  {\\\\nid  \\\\nduration  \\\\nrating  \\\\nactivity  {\\\\nid  \\\\ntitle  \\\\ndescription  \\\\nduration  \\\\ncognitiveAspects  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\nparticipants  {\\\\nid  \\\\nname  \\\\ngeneralStatistics  {\\\\nactivityCount  \\\\n}\\\\n\\\\n...\\"
              ++ LargeAvatars_User.name
            )
            ++ \\"   \\\\n...\\"
          )
          ++ Small_Avatar_User.name
        )
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ LargeAvatars_User.query
    )
    ++ Small_Avatar_User.query;
  type t = {. \\"activityFeedItem\\": option(t_activityFeedItem)}
  and t_activityFeedItem = {
    .
    \\"id\\": string,
    \\"duration\\": option(int),
    \\"rating\\": option(int),
    \\"activity\\": t_activityFeedItem_activity,
    \\"participants\\": array(t_activityFeedItem_participants),
  }
  and t_activityFeedItem_participants = {
    .
    \\"id\\": string,
    \\"name\\": string,
    \\"generalStatistics\\": t_activityFeedItem_participants_generalStatistics,
    \\"largeAvatars_User\\": LargeAvatars_User.t_User,
    \\"small_Avatar_User\\": Small_Avatar_User.t_User,
  }
  and t_activityFeedItem_participants_generalStatistics = {
    .
    \\"activityCount\\": int,
  }
  and t_activityFeedItem_activity = {
    .
    \\"id\\": string,
    \\"title\\": option(string),
    \\"description\\": option(string),
    \\"duration\\": option(int),
    \\"cognitiveAspects\\": array(t_activityFeedItem_activity_cognitiveAspects),
  }
  and t_activityFeedItem_activity_cognitiveAspects = {
    .
    \\"id\\": string,
    \\"name\\": option(string),
  };
  type t_variables = {
    .
    \\"id\\": string,
    \\"pixelRatio\\": float,
  };
  let parse: Raw.t => t =
    value => {

      \\"activityFeedItem\\": {
        let value = value##activityFeedItem;

        switch (Js.toOption(value)) {
        | Some(value) =>
          Some({

            \\"id\\": {
              let value = value##id;

              value;
            },

            \\"duration\\": {
              let value = value##duration;

              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },

            \\"rating\\": {
              let value = value##rating;

              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },

            \\"activity\\": {
              let value = value##activity;
              {

                \\"id\\": {
                  let value = value##id;

                  value;
                },

                \\"title\\": {
                  let value = value##title;

                  switch (Js.toOption(value)) {
                  | Some(value) => Some(value)
                  | None => None
                  };
                },

                \\"description\\": {
                  let value = value##description;

                  switch (Js.toOption(value)) {
                  | Some(value) => Some(value)
                  | None => None
                  };
                },

                \\"duration\\": {
                  let value = value##duration;

                  switch (Js.toOption(value)) {
                  | Some(value) => Some(value)
                  | None => None
                  };
                },

                \\"cognitiveAspects\\": {
                  let value = value##cognitiveAspects;

                  value
                  |> Js.Array.map(value =>
                       {

                         \\"id\\": {
                           let value = value##id;

                           value;
                         },

                         \\"name\\": {
                           let value = value##name;

                           switch (Js.toOption(value)) {
                           | Some(value) => Some(value)
                           | None => None
                           };
                         },
                       }
                     );
                },
              };
            },

            \\"participants\\": {
              let value = value##participants;

              value
              |> Js.Array.map(value =>
                   {

                     \\"id\\": {
                       let value =
                         Obj.magic(
                           Js.Dict.unsafeGet(Obj.magic(value), \\"id\\"),
                         );

                       value;
                     },

                     \\"name\\": {
                       let value =
                         Obj.magic(
                           Js.Dict.unsafeGet(Obj.magic(value), \\"name\\"),
                         );

                       value;
                     },

                     \\"generalStatistics\\": {
                       let value =
                         Obj.magic(
                           Js.Dict.unsafeGet(
                             Obj.magic(value),
                             \\"generalStatistics\\",
                           ),
                         );
                       {

                         \\"activityCount\\": {
                           let value = value##activityCount;

                           value;
                         },
                       };
                     },

                     \\"largeAvatars_User\\": {
                       let value: LargeAvatars_User.Raw.t = Obj.magic(value);

                       LargeAvatars_User.parse(value);
                     },

                     \\"small_Avatar_User\\": {
                       let value: Small_Avatar_User.Raw.t = Obj.magic(value);

                       Small_Avatar_User.parse(
                         ~pixelRatio=\`Float_NonNull,
                         value,
                       );
                     },
                   }
                 );
            },
          })
        | None => None
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"activityFeedItem\\": {
        let value = value##activityFeedItem;

        switch (value) {
        | Some(value) =>
          Js.Nullable.return({

            \\"id\\": {
              let value = value##id;

              value;
            },

            \\"duration\\": {
              let value = value##duration;

              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            },

            \\"rating\\": {
              let value = value##rating;

              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            },

            \\"activity\\": {
              let value = value##activity;
              {

                \\"id\\": {
                  let value = value##id;

                  value;
                },

                \\"title\\": {
                  let value = value##title;

                  switch (value) {
                  | Some(value) => Js.Nullable.return(value)
                  | None => Js.Nullable.null
                  };
                },

                \\"description\\": {
                  let value = value##description;

                  switch (value) {
                  | Some(value) => Js.Nullable.return(value)
                  | None => Js.Nullable.null
                  };
                },

                \\"duration\\": {
                  let value = value##duration;

                  switch (value) {
                  | Some(value) => Js.Nullable.return(value)
                  | None => Js.Nullable.null
                  };
                },

                \\"cognitiveAspects\\": {
                  let value = value##cognitiveAspects;

                  value
                  |> Js.Array.map(value =>
                       {

                         \\"id\\": {
                           let value = value##id;

                           value;
                         },

                         \\"name\\": {
                           let value = value##name;

                           switch (value) {
                           | Some(value) => Js.Nullable.return(value)
                           | None => Js.Nullable.null
                           };
                         },
                       }
                     );
                },
              };
            },

            \\"participants\\": {
              let value = value##participants;

              value
              |> Js.Array.map((value) =>
                   (
                     Obj.magic(
                       Js.Array.reduce(
                         GraphQL_PPX.deepMerge,
                         Obj.magic(Js.Dict.empty): Js.Json.t,
                         [|
                           (
                             Obj.magic(
                               LargeAvatars_User.serialize(
                                 value##largeAvatars_User,
                               ),
                             ): Js.Json.t
                           ),
                           (
                             Obj.magic(
                               Small_Avatar_User.serialize(
                                 value##small_Avatar_User,
                               ),
                             ): Js.Json.t
                           ),
                         |],
                       ),
                     ): Raw.t_activityFeedItem_participants
                   )
                 );
            },
          })
        | None => Js.Nullable.null
        };
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (\\"id\\", (a => Some(Js.Json.string(a)))(inp##id)),
        (\\"pixelRatio\\", (a => Some(Js.Json.number(a)))(inp##pixelRatio)),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~id, ~pixelRatio, ()) =>
    f(
      serializeVariables(
        {

          \\"id\\": id,

          \\"pixelRatio\\": pixelRatio,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Objects comment.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"nonrecursiveInput\\": string};
  };
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"nonrecursiveInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    .
    \\"field\\": option(string),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  let parse: Raw.t => t =
    value => {

      \\"nonrecursiveInput\\": {
        let value = value##nonrecursiveInput;

        value;
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"nonrecursiveInput\\": {
        let value = value##nonrecursiveInput;

        value;
      },
    };
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (a => Some(serializeInputObjectNonrecursiveInput(a)))(inp##arg),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Js.Json.t =
    inp =>
      [|
        (
          \\"field\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##field,
          ),
        ),
        (
          \\"enum\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      switch (a) {
                      | \`FIRST => Js.Json.string(\\"FIRST\\")
                      | \`SECOND => Js.Json.string(\\"SECOND\\")
                      | \`THIRD => Js.Json.string(\\"THIRD\\")
                      },
                    )
                )(
                  b,
                )
              }
          )(
            inp##enum,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    )
  and makeInputObjectNonrecursiveInput =
      (~field=?, ~enum=?, ()): t_variables_NonrecursiveInput => {

    \\"field\\": field,

    \\"enum\\": enum,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Objects customDecoder.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module StringOfInt = {
  let parse = string_of_int;
  type t = string;
};
module IntOfString = {
  let parse = int_of_string;
  type t = int;
};

module MyQuery = {
  module Raw = {
    type t = {. \\"variousScalars\\": t_variousScalars}
    and t_variousScalars = {
      .
      \\"string\\": string,
      \\"int\\": int,
    };
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"variousScalars\\": t_variousScalars}
  and t_variousScalars = {
    .
    \\"string\\": IntOfString.t,
    \\"int\\": StringOfInt.t,
  };
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"string\\": {
            let value = value##string;

            IntOfString.parse(value);
          },

          \\"int\\": {
            let value = value##int;

            StringOfInt.parse(value);
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"string\\": {
            let value = value##string;

            IntOfString.serialize(value);
          },

          \\"int\\": {
            let value = value##int;

            StringOfInt.serialize(value);
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Objects customScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"customScalarField\\": t_customScalarField}
    and t_customScalarField = {
      .
      \\"nullable\\": Js.Nullable.t(Js.Json.t),
      \\"nonNullable\\": Js.Json.t,
    };
  };
  let query = \\"query ($opt: CustomScalar, $req: CustomScalar!)  {\\\\ncustomScalarField(argOptional: $opt, argRequired: $req)  {\\\\nnullable  \\\\nnonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"customScalarField\\": t_customScalarField}
  and t_customScalarField = {
    .
    \\"nullable\\": option(Js.Json.t),
    \\"nonNullable\\": Js.Json.t,
  };
  type t_variables = {
    .
    \\"opt\\": option(Js.Json.t),
    \\"req\\": Js.Json.t,
  };
  let parse: Raw.t => t =
    value => {

      \\"customScalarField\\": {
        let value = value##customScalarField;
        {

          \\"nullable\\": {
            let value = value##nullable;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"nonNullable\\": {
            let value = value##nonNullable;

            value;
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"customScalarField\\": {
        let value = value##customScalarField;
        {

          \\"nullable\\": {
            let value = value##nullable;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"nonNullable\\": {
            let value = value##nonNullable;

            value;
          },
        };
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"opt\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(a))(b)
              }
          )(
            inp##opt,
          ),
        ),
        (\\"req\\", (a => Some(a))(inp##req)),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~opt=?, ~req, ()) =>
    f(
      serializeVariables(
        {

          \\"opt\\": opt,

          \\"req\\": req,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Objects enumInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"enumInput\\": string};
  };
  let query = \\"query ($arg: SampleField!)  {\\\\nenumInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"enumInput\\": string};
  type t_variables = {. \\"arg\\": [ | \`FIRST | \`SECOND | \`THIRD]};
  let parse: Raw.t => t =
    value => {

      \\"enumInput\\": {
        let value = value##enumInput;

        value;
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"enumInput\\": {
        let value = value##enumInput;

        value;
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (
            a =>
              Some(
                switch (a) {
                | \`FIRST => Js.Json.string(\\"FIRST\\")
                | \`SECOND => Js.Json.string(\\"SECOND\\")
                | \`THIRD => Js.Json.string(\\"THIRD\\")
                },
              )
          )(
            inp##arg,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Objects explicit_object_record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module RecordsQuery = {
  module Raw = {
    type t = {lists: t_lists}
    and t_lists = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {lists: t_lists}
  and t_lists = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  let parse: Raw.t => t =
    (value) => (
      {

        lists: {
          let value = (value: Raw.t).lists;
          (
            {

              nullableOfNullable: {
                let value = (value: Raw.t_lists).nullableOfNullable;

                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              },

              nullableOfNonNullable: {
                let value = (value: Raw.t_lists).nullableOfNonNullable;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value |> Js.Array.map(value => value))
                | None => None
                };
              },

              nonNullableOfNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNullable;

                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   );
              },

              nonNullableOfNonNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNonNullable;

                value |> Js.Array.map(value => value);
              },
            }: t_lists
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        lists: {
          let value = (value: t).lists;
          (
            {

              nullableOfNullable: {
                let value = (value: t_lists).nullableOfNullable;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map(value =>
                         switch (value) {
                         | Some(value) => Js.Nullable.return(value)
                         | None => Js.Nullable.null
                         }
                       ),
                  )
                | None => Js.Nullable.null
                };
              },

              nullableOfNonNullable: {
                let value = (value: t_lists).nullableOfNonNullable;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(value |> Js.Array.map(value => value))
                | None => Js.Nullable.null
                };
              },

              nonNullableOfNullable: {
                let value = (value: t_lists).nonNullableOfNullable;

                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   );
              },

              nonNullableOfNonNullable: {
                let value = (value: t_lists).nonNullableOfNonNullable;

                value |> Js.Array.map(value => value);
              },
            }: Raw.t_lists
          );
        },
      }: Raw.t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};

module ObjectsQuery = {
  module Raw = {
    type t = {. \\"lists\\": t_lists}
    and t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"lists\\": t_lists}
  and t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  let parse: Raw.t => t =
    value => {

      \\"lists\\": {
        let value = value##lists;
        {

          \\"nullableOfNullable\\": {
            let value = value##nullableOfNullable;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some(
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   ),
              )
            | None => None
            };
          },

          \\"nullableOfNonNullable\\": {
            let value = value##nullableOfNonNullable;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value |> Js.Array.map(value => value))
            | None => None
            };
          },

          \\"nonNullableOfNullable\\": {
            let value = value##nonNullableOfNullable;

            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               );
          },

          \\"nonNullableOfNonNullable\\": {
            let value = value##nonNullableOfNonNullable;

            value |> Js.Array.map(value => value);
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"lists\\": {
        let value = value##lists;
        {

          \\"nullableOfNullable\\": {
            let value = value##nullableOfNullable;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return(
                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   ),
              )
            | None => Js.Nullable.null
            };
          },

          \\"nullableOfNonNullable\\": {
            let value = value##nullableOfNonNullable;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return(value |> Js.Array.map(value => value))
            | None => Js.Nullable.null
            };
          },

          \\"nonNullableOfNullable\\": {
            let value = value##nonNullableOfNullable;

            value
            |> Js.Array.map(value =>
                 switch (value) {
                 | Some(value) => Js.Nullable.return(value)
                 | None => Js.Nullable.null
                 }
               );
          },

          \\"nonNullableOfNonNullable\\": {
            let value = value##nonNullableOfNonNullable;

            value |> Js.Array.map(value => value);
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Objects fragmentDefinition.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module GraphQL_PPX = {
  let%private clone: Js.Dict.t('a) => Js.Dict.t('a) =
    a => Obj.magic(Js.Obj.assign(Obj.magic(Js.Obj.empty()), Obj.magic(a)));

  let rec deepMerge = (json1: Js.Json.t, json2: Js.Json.t) =>
    switch (
      (
        Obj.magic(json1) == Js.null,
        Js_array2.isArray(json1),
        Js.typeof(json1) == \\"object\\",
      ),
      (
        Obj.magic(json2) == Js.null,
        Js_array2.isArray(json2),
        Js.typeof(json2) == \\"object\\",
      ),
    ) {
    | ((_, true, _), (_, true, _)) => (
        Obj.magic(
          Js.Array.mapi(
            (el1, idx) => {
              let el2 = Js.Array.unsafe_get(Obj.magic(json2), idx);

              Js.typeof(el2) == \\"object\\" ? deepMerge(el1, el2) : el2;
            },
            Obj.magic(json1),
          ),
        ): Js.Json.t
      )

    | ((false, false, true), (false, false, true)) =>
      let obj1 = clone(Obj.magic(json1));
      let obj2 = Obj.magic(json2);
      Js.Dict.keys(obj2)
      |> Js.Array.forEach(key =>
           let existingVal: Js.Json.t = Js.Dict.unsafeGet(obj1, key);
           let newVal: Js.Json.t = Js.Dict.unsafeGet(obj1, key);
           Js.Dict.set(
             obj1,
             key,
             Js.typeof(existingVal) != \\"object\\"
               ? newVal : Obj.magic(deepMerge(existingVal, newVal)),
           );
         );
      Obj.magic(obj1);

    | ((_, _, _), (_, _, _)) => json2
    };
};

module Fragments = {
  module ListFragment = {
    let query = \\"fragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        .
        \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
        \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      };
      type t_Lists = t;
    };
    type t = {
      .
      \\"nullableOfNullable\\": option(array(option(string))),
      \\"nullableOfNonNullable\\": option(array(string)),
    };
    type t_Lists = t;

    let parse = (value: Raw.t) => {

      \\"nullableOfNullable\\": {
        let value = value##nullableOfNullable;

        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      },

      \\"nullableOfNonNullable\\": {
        let value = value##nullableOfNonNullable;

        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      },
    };
    let serialize: t => Raw.t =
      value => {

        \\"nullableOfNullable\\": {
          let value = value##nullableOfNullable;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 ),
            )
          | None => Js.Nullable.null
          };
        },

        \\"nullableOfNonNullable\\": {
          let value = value##nullableOfNonNullable;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(value |> Js.Array.map(value => value))
          | None => Js.Nullable.null
          };
        },
      };
    let name = \\"ListFragment\\";
  };
  module Another = {
    let query = \\"fragment Another on Lists   {\\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
    module Raw = {
      type t = {. \\"nullableOfNonNullable\\": Js.Nullable.t(array(string))};
      type t_Lists = t;
    };
    type t = {. \\"nullableOfNonNullable\\": option(array(string))};
    type t_Lists = t;

    let parse = (value: Raw.t) => {

      \\"nullableOfNonNullable\\": {
        let value = value##nullableOfNonNullable;

        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      },
    };
    let serialize: t => Raw.t =
      value => {

        \\"nullableOfNonNullable\\": {
          let value = value##nullableOfNonNullable;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(value |> Js.Array.map(value => value))
          | None => Js.Nullable.null
          };
        },
      };
    let name = \\"Another\\";
  };
};

module MyQuery = {
  module Raw = {
    type t = {
      .
      \\"l1\\": Fragments.ListFragment.Raw.t,
      \\"l2\\": t_l2,
      \\"l3\\": t_l3,
      \\"l4\\": t_l4,
    }
    and t_l4
    and t_l3
    and t_l2;
  };
  let query =
    (
      (
        (
          (
            (
              (
                (
                  (
                    (
                      (
                        (
                          (
                            \\"query   {\\\\nl1: lists  {\\\\n...\\"
                            ++ Fragments.ListFragment.name
                          )
                          ++ \\"   \\\\n}\\\\n\\\\nl2: lists  {\\\\n...\\"
                        )
                        ++ Fragments.ListFragment.name
                      )
                      ++ \\"   \\\\n...\\"
                    )
                    ++ Fragments.ListFragment.name
                  )
                  ++ \\"   \\\\n}\\\\n\\\\nl3: lists  {\\\\nnullableOfNullable  \\\\n...\\"
                )
                ++ Fragments.ListFragment.name
              )
              ++ \\"   \\\\n...\\"
            )
            ++ Fragments.ListFragment.name
          )
          ++ \\"   \\\\n}\\\\n\\\\nl4: lists  {\\\\nnullableOfNullable  \\\\n...\\"
        )
        ++ Fragments.ListFragment.name
      )
      ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
    )
    ++ Fragments.ListFragment.query;
  type t = {
    .
    \\"l1\\": Fragments.ListFragment.t,
    \\"l2\\": t_l2,
    \\"l3\\": t_l3,
    \\"l4\\": t_l4,
  }
  and t_l4 = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"listFragment\\": Fragments.ListFragment.t_Lists,
  }
  and t_l3 = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"frag1\\": Fragments.ListFragment.t_Lists,
    \\"frag2\\": Fragments.ListFragment.t_Lists,
  }
  and t_l2 = {
    .
    \\"frag1\\": Fragments.ListFragment.t_Lists,
    \\"frag2\\": Fragments.ListFragment.t_Lists,
  };
  let parse: Raw.t => t =
    value => {

      \\"l1\\": {
        let value = value##l1;

        Fragments.ListFragment.parse(value);
      },

      \\"l2\\": {
        let value = value##l2;
        {

          \\"frag1\\": {
            let value: Fragments.ListFragment.Raw.t = Obj.magic(value);

            Fragments.ListFragment.parse(value);
          },

          \\"frag2\\": {
            let value: Fragments.ListFragment.Raw.t = Obj.magic(value);

            Fragments.ListFragment.parse(value);
          },
        };
      },

      \\"l3\\": {
        let value = value##l3;
        {

          \\"nullableOfNullable\\": {
            let value =
              Obj.magic(
                Js.Dict.unsafeGet(Obj.magic(value), \\"nullableOfNullable\\"),
              );

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some(
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   ),
              )
            | None => None
            };
          },

          \\"frag1\\": {
            let value: Fragments.ListFragment.Raw.t = Obj.magic(value);

            Fragments.ListFragment.parse(value);
          },

          \\"frag2\\": {
            let value: Fragments.ListFragment.Raw.t = Obj.magic(value);

            Fragments.ListFragment.parse(value);
          },
        };
      },

      \\"l4\\": {
        let value = value##l4;
        {

          \\"nullableOfNullable\\": {
            let value =
              Obj.magic(
                Js.Dict.unsafeGet(Obj.magic(value), \\"nullableOfNullable\\"),
              );

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some(
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   ),
              )
            | None => None
            };
          },

          \\"listFragment\\": {
            let value: Fragments.ListFragment.Raw.t = Obj.magic(value);

            Fragments.ListFragment.parse(value);
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"l1\\": {
        let value = value##l1;
        Fragments.ListFragment.serialize(value);
      },

      \\"l2\\": {
        let value = value##l2;
        (
          Obj.magic(
            Js.Array.reduce(
              GraphQL_PPX.deepMerge,
              Obj.magic(Js.Dict.empty): Js.Json.t,
              [|
                (
                  Obj.magic(Fragments.ListFragment.serialize(value##frag1)): Js.Json.t
                ),
                (
                  Obj.magic(Fragments.ListFragment.serialize(value##frag2)): Js.Json.t
                ),
              |],
            ),
          ): Raw.t_l2
        );
      },

      \\"l3\\": {
        let value = value##l3;
        (
          Obj.magic(
            Js.Array.reduce(
              GraphQL_PPX.deepMerge,
              Obj.magic(Js.Dict.empty): Js.Json.t,
              [|
                (
                  Obj.magic(Fragments.ListFragment.serialize(value##frag1)): Js.Json.t
                ),
                (
                  Obj.magic(Fragments.ListFragment.serialize(value##frag2)): Js.Json.t
                ),
              |],
            ),
          ): Raw.t_l3
        );
      },

      \\"l4\\": {
        let value = value##l4;
        (
          Obj.magic(
            Js.Array.reduce(
              GraphQL_PPX.deepMerge,
              Obj.magic(Js.Dict.empty): Js.Json.t,
              [|
                (
                  Obj.magic(
                    Fragments.ListFragment.serialize(value##listFragment),
                  ): Js.Json.t
                ),
              |],
            ),
          ): Raw.t_l4
        );
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Objects interface.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
"
`;

exports[`Objects lists.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"lists\\": t_lists}
    and t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"lists\\": t_lists}
  and t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  let parse: Raw.t => t =
    value => {

      \\"lists\\": {
        let value = value##lists;
        {

          \\"nullableOfNullable\\": {
            let value = value##nullableOfNullable;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some(
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   ),
              )
            | None => None
            };
          },

          \\"nullableOfNonNullable\\": {
            let value = value##nullableOfNonNullable;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value |> Js.Array.map(value => value))
            | None => None
            };
          },

          \\"nonNullableOfNullable\\": {
            let value = value##nonNullableOfNullable;

            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               );
          },

          \\"nonNullableOfNonNullable\\": {
            let value = value##nonNullableOfNonNullable;

            value |> Js.Array.map(value => value);
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"lists\\": {
        let value = value##lists;
        {

          \\"nullableOfNullable\\": {
            let value = value##nullableOfNullable;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return(
                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   ),
              )
            | None => Js.Nullable.null
            };
          },

          \\"nullableOfNonNullable\\": {
            let value = value##nullableOfNonNullable;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return(value |> Js.Array.map(value => value))
            | None => Js.Nullable.null
            };
          },

          \\"nonNullableOfNullable\\": {
            let value = value##nonNullableOfNullable;

            value
            |> Js.Array.map(value =>
                 switch (value) {
                 | Some(value) => Js.Nullable.return(value)
                 | None => Js.Nullable.null
                 }
               );
          },

          \\"nonNullableOfNonNullable\\": {
            let value = value##nonNullableOfNonNullable;

            value |> Js.Array.map(value => value);
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Objects listsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"listsInput\\": string};
  };
  let query = \\"query ($nullableOfNullable: [String], $nullableOfNonNullable: [String!], $nonNullableOfNullable: [String]!, $nonNullableOfNonNullable: [String!]!)  {\\\\nlistsInput(arg: {nullableOfNullable: $nullableOfNullable, nullableOfNonNullable: $nullableOfNonNullable, nonNullableOfNullable: $nonNullableOfNullable, nonNullableOfNonNullable: $nonNullableOfNonNullable})  \\\\n}\\\\n\\";
  type t = {. \\"listsInput\\": string};
  type t_variables = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  let parse: Raw.t => t =
    value => {

      \\"listsInput\\": {
        let value = value##listsInput;

        value;
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"listsInput\\": {
        let value = value##listsInput;

        value;
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"nullableOfNullable\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      a
                      |> Array.map(b =>
                           switch (
                             (
                               a =>
                                 switch (a) {
                                 | None => None
                                 | Some(b) =>
                                   (a => Some(Js.Json.string(a)))(b)
                                 }
                             )(
                               b,
                             )
                           ) {
                           | Some(c) => c
                           | None => Js.Json.null
                           }
                         )
                      |> Js.Json.array,
                    )
                )(
                  b,
                )
              }
          )(
            inp##nullableOfNullable,
          ),
        ),
        (
          \\"nullableOfNonNullable\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      a
                      |> Array.map(b =>
                           switch ((a => Some(Js.Json.string(a)))(b)) {
                           | Some(c) => c
                           | None => Js.Json.null
                           }
                         )
                      |> Js.Json.array,
                    )
                )(
                  b,
                )
              }
          )(
            inp##nullableOfNonNullable,
          ),
        ),
        (
          \\"nonNullableOfNullable\\",
          (
            a =>
              Some(
                a
                |> Array.map(b =>
                     switch (
                       (
                         a =>
                           switch (a) {
                           | None => None
                           | Some(b) => (a => Some(Js.Json.string(a)))(b)
                           }
                       )(
                         b,
                       )
                     ) {
                     | Some(c) => c
                     | None => Js.Json.null
                     }
                   )
                |> Js.Json.array,
              )
          )(
            inp##nonNullableOfNullable,
          ),
        ),
        (
          \\"nonNullableOfNonNullable\\",
          (
            a =>
              Some(
                a
                |> Array.map(b =>
                     switch ((a => Some(Js.Json.string(a)))(b)) {
                     | Some(c) => c
                     | None => Js.Json.null
                     }
                   )
                |> Js.Json.array,
              )
          )(
            inp##nonNullableOfNonNullable,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar =
      (
        ~f,
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      ) =>
    f(
      serializeVariables(
        {

          \\"nullableOfNullable\\": nullableOfNullable,

          \\"nullableOfNonNullable\\": nullableOfNonNullable,

          \\"nonNullableOfNullable\\": nonNullableOfNullable,

          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Objects listsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"listsInput\\": string};
  };
  let query = \\"query ($arg: ListsInput!)  {\\\\nlistsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"listsInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_ListsInput}
  and t_variables_ListsInput = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  let parse: Raw.t => t =
    value => {

      \\"listsInput\\": {
        let value = value##listsInput;

        value;
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"listsInput\\": {
        let value = value##listsInput;

        value;
      },
    };
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (\\"arg\\", (a => Some(serializeInputObjectListsInput(a)))(inp##arg)),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectListsInput: t_variables_ListsInput => Js.Json.t =
    inp =>
      [|
        (
          \\"nullableOfNullable\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      a
                      |> Array.map(b =>
                           switch (
                             (
                               a =>
                                 switch (a) {
                                 | None => None
                                 | Some(b) =>
                                   (a => Some(Js.Json.string(a)))(b)
                                 }
                             )(
                               b,
                             )
                           ) {
                           | Some(c) => c
                           | None => Js.Json.null
                           }
                         )
                      |> Js.Json.array,
                    )
                )(
                  b,
                )
              }
          )(
            inp##nullableOfNullable,
          ),
        ),
        (
          \\"nullableOfNonNullable\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      a
                      |> Array.map(b =>
                           switch ((a => Some(Js.Json.string(a)))(b)) {
                           | Some(c) => c
                           | None => Js.Json.null
                           }
                         )
                      |> Js.Json.array,
                    )
                )(
                  b,
                )
              }
          )(
            inp##nullableOfNonNullable,
          ),
        ),
        (
          \\"nonNullableOfNullable\\",
          (
            a =>
              Some(
                a
                |> Array.map(b =>
                     switch (
                       (
                         a =>
                           switch (a) {
                           | None => None
                           | Some(b) => (a => Some(Js.Json.string(a)))(b)
                           }
                       )(
                         b,
                       )
                     ) {
                     | Some(c) => c
                     | None => Js.Json.null
                     }
                   )
                |> Js.Json.array,
              )
          )(
            inp##nonNullableOfNullable,
          ),
        ),
        (
          \\"nonNullableOfNonNullable\\",
          (
            a =>
              Some(
                a
                |> Array.map(b =>
                     switch ((a => Some(Js.Json.string(a)))(b)) {
                     | Some(c) => c
                     | None => Js.Json.null
                     }
                   )
                |> Js.Json.array,
              )
          )(
            inp##nonNullableOfNonNullable,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    )
  and makeInputObjectListsInput =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      )
      : t_variables_ListsInput => {

    \\"nullableOfNullable\\": nullableOfNullable,

    \\"nullableOfNonNullable\\": nullableOfNonNullable,

    \\"nonNullableOfNullable\\": nonNullableOfNullable,

    \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Objects mutation.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"mutationWithError\\": t_mutationWithError}
    and t_mutationWithError = {
      .
      \\"value\\": Js.Nullable.t(t_mutationWithError_value),
      \\"errors\\": Js.Nullable.t(array(t_mutationWithError_errors)),
    }
    and t_mutationWithError_errors = {
      .
      \\"field\\": t_mutationWithError_errors_field,
      \\"message\\": string,
    }
    and t_mutationWithError_errors_field = string
    and t_mutationWithError_value = {. \\"stringField\\": string};
  };
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nvalue  {\\\\nstringField  \\\\n}\\\\n\\\\nerrors  {\\\\nfield  \\\\nmessage  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"mutationWithError\\": t_mutationWithError}
  and t_mutationWithError = {
    .
    \\"value\\": option(t_mutationWithError_value),
    \\"errors\\": option(array(t_mutationWithError_errors)),
  }
  and t_mutationWithError_errors = {
    .
    \\"field\\": t_mutationWithError_errors_field,
    \\"message\\": string,
  }
  and t_mutationWithError_errors_field = [
    | \`FutureAddedValue(string)
    | \`FIRST
    | \`SECOND
    | \`THIRD
  ]
  and t_mutationWithError_value = {. \\"stringField\\": string};
  let parse: Raw.t => t =
    value => {

      \\"mutationWithError\\": {
        let value = value##mutationWithError;
        {

          \\"value\\": {
            let value = value##value;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some({

                \\"stringField\\": {
                  let value = value##stringField;

                  value;
                },
              })
            | None => None
            };
          },

          \\"errors\\": {
            let value = value##errors;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some(
                value
                |> Js.Array.map(value =>
                     {

                       \\"field\\": {
                         let value = value##field;
                         switch (Obj.magic(value: string)) {
                         | \\"FIRST\\" => \`FIRST
                         | \\"SECOND\\" => \`SECOND
                         | \\"THIRD\\" => \`THIRD
                         | other => \`FutureAddedValue(other)
                         };
                       },

                       \\"message\\": {
                         let value = value##message;

                         value;
                       },
                     }
                   ),
              )
            | None => None
            };
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"mutationWithError\\": {
        let value = value##mutationWithError;
        {

          \\"value\\": {
            let value = value##value;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return({

                \\"stringField\\": {
                  let value = value##stringField;

                  value;
                },
              })
            | None => Js.Nullable.null
            };
          },

          \\"errors\\": {
            let value = value##errors;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return(
                value
                |> Js.Array.map(value =>
                     {

                       \\"field\\": {
                         let value = value##field;
                         switch (value) {
                         | \`FIRST => \\"FIRST\\"
                         | \`SECOND => \\"SECOND\\"
                         | \`THIRD => \\"THIRD\\"
                         | \`FutureAddedValue(other) => other
                         };
                       },

                       \\"message\\": {
                         let value = value##message;

                         value;
                       },
                     }
                   ),
              )
            | None => Js.Nullable.null
            };
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Objects mutationWithArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"optionalInputArgs\\": string};
  };
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t = {. \\"optionalInputArgs\\": string};
  type t_variables = {. \\"required\\": string};
  let parse: Raw.t => t =
    value => {

      \\"optionalInputArgs\\": {
        let value = value##optionalInputArgs;

        value;
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"optionalInputArgs\\": {
        let value = value##optionalInputArgs;

        value;
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|(\\"required\\", (a => Some(Js.Json.string(a)))(inp##required))|]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~required, ()) =>
    f(
      serializeVariables(
        {

          \\"required\\": required,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Objects nested.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type record = {
  f1: string,
  f2: string,
};

module MyQuery = {
  module Raw = {
    type t = {
      .
      \\"first\\": t_first,
      \\"second\\": t_second,
      \\"let_\\": t_let,
    }
    and t_let = {. \\"inner\\": Js.Nullable.t(t_let_inner)}
    and t_let_inner = {. \\"inner\\": Js.Nullable.t(t_let_inner_inner)}
    and t_let_inner_inner = {. \\"field\\": string}
    and t_second = {. \\"inner\\": Js.Nullable.t(t_second_inner)}
    and t_second_inner = {. \\"inner\\": Js.Nullable.t(t_second_inner_inner)}
    and t_second_inner_inner = {
      f1: string,
      f2: string,
    }
    and t_first = {. \\"inner\\": Js.Nullable.t(t_first_inner)}
    and t_first_inner = {. \\"inner\\": Js.Nullable.t(t_first_inner_inner)}
    and t_first_inner_inner = {. \\"field\\": string};
  };
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nsecond: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nf1: field  \\\\nf2: field  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nlet: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {
    .
    \\"first\\": t_first,
    \\"second\\": t_second,
    \\"let_\\": t_let,
  }
  and t_let = {. \\"inner\\": option(t_let_inner)}
  and t_let_inner = {. \\"inner\\": option(t_let_inner_inner)}
  and t_let_inner_inner = {. \\"field\\": string}
  and t_second = {. \\"inner\\": option(t_second_inner)}
  and t_second_inner = {. \\"inner\\": option(t_second_inner_inner)}
  and t_second_inner_inner = {
    f1: string,
    f2: string,
  }
  and t_first = {. \\"inner\\": option(t_first_inner)}
  and t_first_inner = {. \\"inner\\": option(t_first_inner_inner)}
  and t_first_inner_inner = {. \\"field\\": string};
  let parse: Raw.t => t =
    value => {

      \\"first\\": {
        let value = value##first;
        {

          \\"inner\\": {
            let value = value##inner;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some({

                \\"inner\\": {
                  let value = value##inner;

                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some({

                      \\"field\\": {
                        let value = value##field;

                        value;
                      },
                    })
                  | None => None
                  };
                },
              })
            | None => None
            };
          },
        };
      },

      \\"second\\": {
        let value = value##second;
        {

          \\"inner\\": {
            let value = value##inner;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some({

                \\"inner\\": {
                  let value = value##inner;

                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some({

                      \\"f1\\": {
                        let value = value##f1;

                        value;
                      },

                      \\"f2\\": {
                        let value = value##f2;

                        value;
                      },
                    })
                  | None => None
                  };
                },
              })
            | None => None
            };
          },
        };
      },

      \\"let_\\": {
        let value = value##let_;
        {

          \\"inner\\": {
            let value = value##inner;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some({

                \\"inner\\": {
                  let value = value##inner;

                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some({

                      \\"field\\": {
                        let value = value##field;

                        value;
                      },
                    })
                  | None => None
                  };
                },
              })
            | None => None
            };
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"first\\": {
        let value = value##first;
        {

          \\"inner\\": {
            let value = value##inner;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return({

                \\"inner\\": {
                  let value = value##inner;

                  switch (value) {
                  | Some(value) =>
                    Js.Nullable.return({

                      \\"field\\": {
                        let value = value##field;

                        value;
                      },
                    })
                  | None => Js.Nullable.null
                  };
                },
              })
            | None => Js.Nullable.null
            };
          },
        };
      },

      \\"second\\": {
        let value = value##second;
        {

          \\"inner\\": {
            let value = value##inner;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return({

                \\"inner\\": {
                  let value = value##inner;

                  switch (value) {
                  | Some(value) =>
                    Js.Nullable.return({

                      \\"f1\\": {
                        let value = value##f1;

                        value;
                      },

                      \\"f2\\": {
                        let value = value##f2;

                        value;
                      },
                    })
                  | None => Js.Nullable.null
                  };
                },
              })
            | None => Js.Nullable.null
            };
          },
        };
      },

      \\"let_\\": {
        let value = value##let_;
        {

          \\"inner\\": {
            let value = value##inner;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return({

                \\"inner\\": {
                  let value = value##inner;

                  switch (value) {
                  | Some(value) =>
                    Js.Nullable.return({

                      \\"field\\": {
                        let value = value##field;

                        value;
                      },
                    })
                  | None => Js.Nullable.null
                  };
                },
              })
            | None => Js.Nullable.null
            };
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Objects nonrecursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"nonrecursiveInput\\": string};
  };
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"nonrecursiveInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    .
    \\"field\\": option(string),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  let parse: Raw.t => t =
    value => {

      \\"nonrecursiveInput\\": {
        let value = value##nonrecursiveInput;

        value;
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"nonrecursiveInput\\": {
        let value = value##nonrecursiveInput;

        value;
      },
    };
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (a => Some(serializeInputObjectNonrecursiveInput(a)))(inp##arg),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Js.Json.t =
    inp =>
      [|
        (
          \\"field\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##field,
          ),
        ),
        (
          \\"enum\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      switch (a) {
                      | \`FIRST => Js.Json.string(\\"FIRST\\")
                      | \`SECOND => Js.Json.string(\\"SECOND\\")
                      | \`THIRD => Js.Json.string(\\"THIRD\\")
                      },
                    )
                )(
                  b,
                )
              }
          )(
            inp##enum,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    )
  and makeInputObjectNonrecursiveInput =
      (~field=?, ~enum=?, ()): t_variables_NonrecursiveInput => {

    \\"field\\": field,

    \\"enum\\": enum,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Objects pokedexApolloMode.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"pokemon\\": Js.Nullable.t(t_pokemon)}
    and t_pokemon = {
      .
      \\"id\\": string,
      \\"name\\": Js.Nullable.t(string),
    };
  };
  let query = \\"query   {\\\\npokemon(name: \\\\\\"Pikachu\\\\\\")  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"pokemon\\": option(t_pokemon)}
  and t_pokemon = {
    .
    \\"id\\": string,
    \\"name\\": option(string),
  };
  let parse: Raw.t => t =
    value => {

      \\"pokemon\\": {
        let value = value##pokemon;

        switch (Js.toOption(value)) {
        | Some(value) =>
          Some({

            \\"id\\": {
              let value = value##id;

              value;
            },

            \\"name\\": {
              let value = value##name;

              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
          })
        | None => None
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"pokemon\\": {
        let value = value##pokemon;

        switch (value) {
        | Some(value) =>
          Js.Nullable.return({

            \\"id\\": {
              let value = value##id;

              value;
            },

            \\"name\\": {
              let value = value##name;

              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            },
          })
        | None => Js.Nullable.null
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Objects pokedexScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"pokemon\\": Js.Nullable.t(t_pokemon)}
    and t_pokemon = {
      .
      \\"id\\": string,
      \\"name\\": Js.Nullable.t(string),
    };
  };
  let query = \\"query pokemon($id: String, $name: String)  {\\\\npokemon(name: $name, id: $id)  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"pokemon\\": option(t_pokemon)}
  and t_pokemon = {
    .
    \\"id\\": string,
    \\"name\\": option(string),
  };
  type t_variables = {
    .
    \\"id\\": option(string),
    \\"name\\": option(string),
  };
  let parse: Raw.t => t =
    value => {

      \\"pokemon\\": {
        let value = value##pokemon;

        switch (Js.toOption(value)) {
        | Some(value) =>
          Some({

            \\"id\\": {
              let value = value##id;

              value;
            },

            \\"name\\": {
              let value = value##name;

              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
          })
        | None => None
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"pokemon\\": {
        let value = value##pokemon;

        switch (value) {
        | Some(value) =>
          Js.Nullable.return({

            \\"id\\": {
              let value = value##id;

              value;
            },

            \\"name\\": {
              let value = value##name;

              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            },
          })
        | None => Js.Nullable.null
        };
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"id\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##id,
          ),
        ),
        (
          \\"name\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##name,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~id=?, ~name=?, ()) =>
    f(
      serializeVariables(
        {

          \\"id\\": id,

          \\"name\\": name,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Objects record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type scalars = {
  string,
  int,
};

type dog = {
  name: string,
  barkVolume: float,
};

type oneFieldQuery = {nullableString: option(string)};

module MyQuery = {
  module Raw = {
    type t = {. \\"variousScalars\\": scalars};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"variousScalars\\": scalars};
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"int\\": {
            let value = value##int;

            value;
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"int\\": {
            let value = value##int;

            value;
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};

module OneFieldQuery = {
  module Raw = {
    type t = {. \\"variousScalars\\": t_variousScalars}
    and t_variousScalars = {nullableString: Js.Nullable.t(string)};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"variousScalars\\": t_variousScalars}
  and t_variousScalars = {nullableString: option(string)};
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};

module ExternalFragmentQuery = {
  module Fragment = {
    let query = \\"fragment Fragment on VariousScalars   {\\\\nstring  \\\\nint  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        string,
        int,
      };
      type t_VariousScalars = t;
    };
    type t = {
      string,
      int,
    };
    type t_VariousScalars = t;

    let parse = (value: Raw.t) => {

      \\"string\\": {
        let value = value##string;

        value;
      },

      \\"int\\": {
        let value = value##int;

        value;
      },
    };
    let serialize: t => Raw.t =
      value => {

        \\"string\\": {
          let value = value##string;

          value;
        },

        \\"int\\": {
          let value = value##int;

          value;
        },
      };
    let name = \\"Fragment\\";
  };
  module Untitled1 = {
    module Raw = {
      type t = {. \\"variousScalars\\": Fragment.Raw.t};
    };
    let query =
      (
        (\\"query   {\\\\nvariousScalars  {\\\\n...\\" ++ Fragment.name)
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ Fragment.query;
    type t = {. \\"variousScalars\\": Fragment.t};
    let parse: Raw.t => t =
      value => {

        \\"variousScalars\\": {
          let value = value##variousScalars;

          Fragment.parse(value);
        },
      };
    let serialize: t => Raw.t =
      value => {

        \\"variousScalars\\": {
          let value = value##variousScalars;
          Fragment.serialize(value);
        },
      };
    let makeVar = (~f, ()) => f(Js.Json.null);
    let definition = (parse, query, makeVar);
  };
};

module InlineFragmentQuery = {
  module Raw = {
    type t = {. \\"dogOrHuman\\": t_dogOrHuman}
    and t_dogOrHuman
    and t_dogOrHuman_Dog = {
      name: string,
      barkVolume: float,
    };
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"dogOrHuman\\": t_dogOrHuman}
  and t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ]
  and t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  let parse: Raw.t => t =
    value => {

      \\"dogOrHuman\\": {
        let value = value##dogOrHuman;
        [@metaloc loc]
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                {

                  \\"name\\": {
                    let value = value##name;

                    value;
                  },

                  \\"barkVolume\\": {
                    let value = value##barkVolume;

                    value;
                  },
                };
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"dogOrHuman\\": {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic({

              \\"name\\": {
                let value = value##name;

                value;
              },

              \\"barkVolume\\": {
                let value = value##barkVolume;

                value;
              },
            }): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};

module UnionExternalFragmentQuery = {
  module DogFragment = {
    let query = \\"fragment DogFragment on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        name: string,
        barkVolume: float,
      };
      type t_Dog = t;
    };
    type t = {
      name: string,
      barkVolume: float,
    };
    type t_Dog = t;

    let parse = (value: Raw.t) => {

      \\"name\\": {
        let value = value##name;

        value;
      },

      \\"barkVolume\\": {
        let value = value##barkVolume;

        value;
      },
    };
    let serialize: t => Raw.t =
      value => {

        \\"name\\": {
          let value = value##name;

          value;
        },

        \\"barkVolume\\": {
          let value = value##barkVolume;

          value;
        },
      };
    let name = \\"DogFragment\\";
  };
  module Untitled1 = {
    module Raw = {
      type t = {. \\"dogOrHuman\\": t_dogOrHuman}
      and t_dogOrHuman;
    };
    let query =
      (
        (
          \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n...\\"
          ++ DogFragment.name
        )
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ DogFragment.query;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman}
    and t_dogOrHuman = [
      | \`FutureAddedValue(Js.Json.t)
      | \`Dog(DogFragment.t)
    ];
    let parse: Raw.t => t =
      value => {

        \\"dogOrHuman\\": {
          let value = value##dogOrHuman;
          [@metaloc loc]
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);

                  DogFragment.parse(value);
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        },
      };
    let serialize: t => Raw.t =
      value => {

        \\"dogOrHuman\\": {
          let value = value##dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(DogFragment.serialize(value)): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        },
      };
    let makeVar = (~f, ()) => f(Js.Json.null);
    let definition = (parse, query, makeVar);
  };
};
"
`;

exports[`Objects recursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"recursiveInput\\": string};
  };
  let query = \\"query ($arg: RecursiveInput!)  {\\\\nrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"recursiveInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_RecursiveInput}
  and t_variables_RecursiveInput = {
    .
    \\"otherField\\": option(string),
    \\"inner\\": option(t_variables_RecursiveInput),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  let parse: Raw.t => t =
    value => {

      \\"recursiveInput\\": {
        let value = value##recursiveInput;

        value;
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"recursiveInput\\": {
        let value = value##recursiveInput;

        value;
      },
    };
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (a => Some(serializeInputObjectRecursiveInput(a)))(inp##arg),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectRecursiveInput:
    t_variables_RecursiveInput => Js.Json.t =
    inp =>
      [|
        (
          \\"otherField\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##otherField,
          ),
        ),
        (
          \\"inner\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (a => Some(serializeInputObjectRecursiveInput(a)))(b)
              }
          )(
            inp##inner,
          ),
        ),
        (
          \\"enum\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      switch (a) {
                      | \`FIRST => Js.Json.string(\\"FIRST\\")
                      | \`SECOND => Js.Json.string(\\"SECOND\\")
                      | \`THIRD => Js.Json.string(\\"THIRD\\")
                      },
                    )
                )(
                  b,
                )
              }
          )(
            inp##enum,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    )
  and makeInputObjectRecursiveInput =
      (~otherField=?, ~inner=?, ~enum=?, ()): t_variables_RecursiveInput => {

    \\"otherField\\": otherField,

    \\"inner\\": inner,

    \\"enum\\": enum,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Objects scalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"variousScalars\\": t_variousScalars}
    and t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"variousScalars\\": t_variousScalars}
  and t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Objects scalarsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"scalarsInput\\": string};
  };
  let query = \\"query ($nullableString: String, $string: String!, $nullableInt: Int, $int: Int!, $nullableFloat: Float, $float: Float!, $nullableBoolean: Boolean, $boolean: Boolean!, $nullableID: ID, $id: ID!)  {\\\\nscalarsInput(arg: {nullableString: $nullableString, string: $string, nullableInt: $nullableInt, int: $int, nullableFloat: $nullableFloat, float: $float, nullableBoolean: $nullableBoolean, boolean: $boolean, nullableID: $nullableID, id: $id})  \\\\n}\\\\n\\";
  type t = {. \\"scalarsInput\\": string};
  type t_variables = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"scalarsInput\\": {
        let value = value##scalarsInput;

        value;
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"scalarsInput\\": {
        let value = value##scalarsInput;

        value;
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"nullableString\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##nullableString,
          ),
        ),
        (\\"string\\", (a => Some(Js.Json.string(a)))(inp##string)),
        (
          \\"nullableInt\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.number(float_of_int(a))))(b)
              }
          )(
            inp##nullableInt,
          ),
        ),
        (\\"int\\", (a => Some(Js.Json.number(float_of_int(a))))(inp##int)),
        (
          \\"nullableFloat\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.number(a)))(b)
              }
          )(
            inp##nullableFloat,
          ),
        ),
        (\\"float\\", (a => Some(Js.Json.number(a)))(inp##float)),
        (
          \\"nullableBoolean\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.boolean(a)))(b)
              }
          )(
            inp##nullableBoolean,
          ),
        ),
        (\\"boolean\\", (a => Some(Js.Json.boolean(a)))(inp##boolean)),
        (
          \\"nullableID\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##nullableID,
          ),
        ),
        (\\"id\\", (a => Some(Js.Json.string(a)))(inp##id)),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar =
      (
        ~f,
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      ) =>
    f(
      serializeVariables(
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,

          \\"nullableInt\\": nullableInt,

          \\"int\\": int,

          \\"nullableFloat\\": nullableFloat,

          \\"float\\": float,

          \\"nullableBoolean\\": nullableBoolean,

          \\"boolean\\": boolean,

          \\"nullableID\\": nullableID,

          \\"id\\": id,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Objects scalarsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"scalarsInput\\": string};
  };
  let query = \\"query ($arg: VariousScalarsInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"scalarsInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_VariousScalarsInput}
  and t_variables_VariousScalarsInput = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"scalarsInput\\": {
        let value = value##scalarsInput;

        value;
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"scalarsInput\\": {
        let value = value##scalarsInput;

        value;
      },
    };
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (a => Some(serializeInputObjectVariousScalarsInput(a)))(inp##arg),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectVariousScalarsInput:
    t_variables_VariousScalarsInput => Js.Json.t =
    inp =>
      [|
        (
          \\"nullableString\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##nullableString,
          ),
        ),
        (\\"string\\", (a => Some(Js.Json.string(a)))(inp##string)),
        (
          \\"nullableInt\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.number(float_of_int(a))))(b)
              }
          )(
            inp##nullableInt,
          ),
        ),
        (\\"int\\", (a => Some(Js.Json.number(float_of_int(a))))(inp##int)),
        (
          \\"nullableFloat\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.number(a)))(b)
              }
          )(
            inp##nullableFloat,
          ),
        ),
        (\\"float\\", (a => Some(Js.Json.number(a)))(inp##float)),
        (
          \\"nullableBoolean\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.boolean(a)))(b)
              }
          )(
            inp##nullableBoolean,
          ),
        ),
        (\\"boolean\\", (a => Some(Js.Json.boolean(a)))(inp##boolean)),
        (
          \\"nullableID\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##nullableID,
          ),
        ),
        (\\"id\\", (a => Some(Js.Json.string(a)))(inp##id)),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    )
  and makeInputObjectVariousScalarsInput =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      )
      : t_variables_VariousScalarsInput => {

    \\"nullableString\\": nullableString,

    \\"string\\": string,

    \\"nullableInt\\": nullableInt,

    \\"int\\": int,

    \\"nullableFloat\\": nullableFloat,

    \\"float\\": float,

    \\"nullableBoolean\\": nullableBoolean,

    \\"boolean\\": boolean,

    \\"nullableID\\": nullableID,

    \\"id\\": id,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Objects skipDirectives.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {
      .
      \\"v1\\": t_v1,
      \\"v2\\": t_v2,
    }
    and t_v2 = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": Js.Nullable.t(string),
    }
    and t_v1 = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": Js.Nullable.t(string),
    };
  };
  let query = \\"query ($var: Boolean!)  {\\\\nv1: variousScalars  {\\\\nnullableString @skip(if: $var) \\\\nstring @skip(if: $var) \\\\n}\\\\n\\\\nv2: variousScalars  {\\\\nnullableString @include(if: $var) \\\\nstring @include(if: $var) \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {
    .
    \\"v1\\": t_v1,
    \\"v2\\": t_v2,
  }
  and t_v2 = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": option(string),
  }
  and t_v1 = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": option(string),
  };
  type t_variables = {. \\"var\\": bool};
  let parse: Raw.t => t =
    value => {

      \\"v1\\": {
        let value = value##v1;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"string\\": {
            let value = value##string;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },
        };
      },

      \\"v2\\": {
        let value = value##v2;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"string\\": {
            let value = value##string;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"v1\\": {
        let value = value##v1;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"string\\": {
            let value = value##string;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },
        };
      },

      \\"v2\\": {
        let value = value##v2;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"string\\": {
            let value = value##string;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },
        };
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|(\\"var\\", (a => Some(Js.Json.boolean(a)))(inp##var))|]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~var, ()) =>
    f(
      serializeVariables(
        {

          \\"var\\": var,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Objects subscription.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"simpleSubscription\\": t_simpleSubscription}
    and t_simpleSubscription
    and t_simpleSubscription_Human = {. \\"name\\": string}
    and t_simpleSubscription_Dog = {. \\"name\\": string};
  };
  let query = \\"subscription   {\\\\nsimpleSubscription  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"simpleSubscription\\": t_simpleSubscription}
  and t_simpleSubscription = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_simpleSubscription_Dog)
    | \`Human(t_simpleSubscription_Human)
  ]
  and t_simpleSubscription_Human = {. \\"name\\": string}
  and t_simpleSubscription_Dog = {. \\"name\\": string};
  let parse: Raw.t => t =
    value => {

      \\"simpleSubscription\\": {
        let value = value##simpleSubscription;
        [@metaloc loc]
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_simpleSubscription_Dog = Obj.magic(value);
                {

                  \\"name\\": {
                    let value = value##name;

                    value;
                  },
                };
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_simpleSubscription_Human = Obj.magic(value);
                {

                  \\"name\\": {
                    let value = value##name;

                    value;
                  },
                };
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_simpleSubscription
        );
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"simpleSubscription\\": {
        let value = value##simpleSubscription;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic({

              \\"name\\": {
                let value = value##name;

                value;
              },
            }): Raw.t_simpleSubscription
          )
        | \`Human(value) => (
            Obj.magic({

              \\"name\\": {
                let value = value##name;

                value;
              },
            }): Raw.t_simpleSubscription
          )
        | \`FutureAddedValue(value) => (
            Obj.magic(value): Raw.t_simpleSubscription
          )
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Objects tagged_template.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"variousScalars\\": t_variousScalars}
    and t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"variousScalars\\": t_variousScalars}
  and t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};

module MyQuery2 = {
  module Raw = {
    type t = {. \\"variousScalars\\": t_variousScalars}
    and t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  %raw
  \\"let { graphql } = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t = {. \\"variousScalars\\": t_variousScalars}
  and t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};

module MyQuery3 = {
  module Raw = {
    type t = {. \\"variousScalars\\": t_variousScalars}
    and t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  %raw
  \\"let { graphql } = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t = {. \\"variousScalars\\": t_variousScalars}
  and t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};

module MyQuery4 = {
  module Raw = {
    type t = {. \\"variousScalars\\": t_variousScalars}
    and t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  %raw
  \\"let graphql = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t = {. \\"variousScalars\\": t_variousScalars}
  and t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (value) {
            | Some(value) => Js.Nullable.return(value)
            | None => Js.Nullable.null
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Objects typename.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"first\\": t_first}
    and t_first = {
      .
      \\"__typename\\": string,
      \\"inner\\": Js.Nullable.t(t_first_inner),
    }
    and t_first_inner = {
      .
      \\"__typename\\": string,
      \\"inner\\": Js.Nullable.t(t_first_inner_inner),
    }
    and t_first_inner_inner = {
      .
      \\"__typename\\": string,
      \\"field\\": string,
    };
  };
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"first\\": t_first}
  and t_first = {
    .
    \\"__typename\\": string,
    \\"inner\\": option(t_first_inner),
  }
  and t_first_inner = {
    .
    \\"__typename\\": string,
    \\"inner\\": option(t_first_inner_inner),
  }
  and t_first_inner_inner = {
    .
    \\"__typename\\": string,
    \\"field\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"first\\": {
        let value = value##first;
        {

          \\"__typename\\": {
            let value = value##__typename;

            value;
          },

          \\"inner\\": {
            let value = value##inner;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some({

                \\"__typename\\": {
                  let value = value##__typename;

                  value;
                },

                \\"inner\\": {
                  let value = value##inner;

                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some({

                      \\"__typename\\": {
                        let value = value##__typename;

                        value;
                      },

                      \\"field\\": {
                        let value = value##field;

                        value;
                      },
                    })
                  | None => None
                  };
                },
              })
            | None => None
            };
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"first\\": {
        let value = value##first;
        {

          \\"__typename\\": {
            let value = value##__typename;

            value;
          },

          \\"inner\\": {
            let value = value##inner;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return({

                \\"__typename\\": {
                  let value = value##__typename;

                  value;
                },

                \\"inner\\": {
                  let value = value##inner;

                  switch (value) {
                  | Some(value) =>
                    Js.Nullable.return({

                      \\"__typename\\": {
                        let value = value##__typename;

                        value;
                      },

                      \\"field\\": {
                        let value = value##field;

                        value;
                      },
                    })
                  | None => Js.Nullable.null
                  };
                },
              })
            | None => Js.Nullable.null
            };
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Objects union.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"dogOrHuman\\": t_dogOrHuman}
    and t_dogOrHuman
    and t_dogOrHuman_Human = {. \\"name\\": string}
    and t_dogOrHuman_Dog = {
      .
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"dogOrHuman\\": t_dogOrHuman}
  and t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ]
  and t_dogOrHuman_Human = {. \\"name\\": string}
  and t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  let parse: Raw.t => t =
    value => {

      \\"dogOrHuman\\": {
        let value = value##dogOrHuman;
        [@metaloc loc]
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                {

                  \\"name\\": {
                    let value = value##name;

                    value;
                  },

                  \\"barkVolume\\": {
                    let value = value##barkVolume;

                    value;
                  },
                };
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                {

                  \\"name\\": {
                    let value = value##name;

                    value;
                  },
                };
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"dogOrHuman\\": {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic({

              \\"name\\": {
                let value = value##name;

                value;
              },

              \\"barkVolume\\": {
                let value = value##barkVolume;

                value;
              },
            }): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic({

              \\"name\\": {
                let value = value##name;

                value;
              },
            }): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Objects unionPartial.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"dogOrHuman\\": t_dogOrHuman}
    and t_dogOrHuman
    and t_dogOrHuman_Dog = {
      .
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"dogOrHuman\\": t_dogOrHuman}
  and t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ]
  and t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  let parse: Raw.t => t =
    value => {

      \\"dogOrHuman\\": {
        let value = value##dogOrHuman;
        [@metaloc loc]
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                {

                  \\"name\\": {
                    let value = value##name;

                    value;
                  },

                  \\"barkVolume\\": {
                    let value = value##barkVolume;

                    value;
                  },
                };
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"dogOrHuman\\": {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic({

              \\"name\\": {
                let value = value##name;

                value;
              },

              \\"barkVolume\\": {
                let value = value##barkVolume;

                value;
              },
            }): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Records argNamedQuery.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {argNamedQuery: int};
  };
  let query = \\"query ($query: String!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\";
  type t = {argNamedQuery: int};
  type t_variables = {query: string};
  let parse: Raw.t => t =
    (value) => (
      {

        argNamedQuery: {
          let value = (value: Raw.t).argNamedQuery;

          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        argNamedQuery: {
          let value = (value: t).argNamedQuery;

          value;
        },
      }: Raw.t
    );
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|(\\"query\\", (a => Some(Js.Json.string(a)))(inp.query))|]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~query, ()) =>
    f(
      serializeVariables(
        {

          query: query,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Records bug1.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module GraphQL_PPX = {
  let%private clone: Js.Dict.t('a) => Js.Dict.t('a) =
    a => Obj.magic(Js.Obj.assign(Obj.magic(Js.Obj.empty()), Obj.magic(a)));

  let rec deepMerge = (json1: Js.Json.t, json2: Js.Json.t) =>
    switch (
      (
        Obj.magic(json1) == Js.null,
        Js_array2.isArray(json1),
        Js.typeof(json1) == \\"object\\",
      ),
      (
        Obj.magic(json2) == Js.null,
        Js_array2.isArray(json2),
        Js.typeof(json2) == \\"object\\",
      ),
    ) {
    | ((_, true, _), (_, true, _)) => (
        Obj.magic(
          Js.Array.mapi(
            (el1, idx) => {
              let el2 = Js.Array.unsafe_get(Obj.magic(json2), idx);

              Js.typeof(el2) == \\"object\\" ? deepMerge(el1, el2) : el2;
            },
            Obj.magic(json1),
          ),
        ): Js.Json.t
      )

    | ((false, false, true), (false, false, true)) =>
      let obj1 = clone(Obj.magic(json1));
      let obj2 = Obj.magic(json2);
      Js.Dict.keys(obj2)
      |> Js.Array.forEach(key =>
           let existingVal: Js.Json.t = Js.Dict.unsafeGet(obj1, key);
           let newVal: Js.Json.t = Js.Dict.unsafeGet(obj1, key);
           Js.Dict.set(
             obj1,
             key,
             Js.typeof(existingVal) != \\"object\\"
               ? newVal : Obj.magic(deepMerge(existingVal, newVal)),
           );
         );
      Obj.magic(obj1);

    | ((_, _, _), (_, _, _)) => json2
    };
};

module LargeAvatars_User = {
  let query = \\"fragment LargeAvatars_User on User   {\\\\nid  \\\\nname  \\\\ngeneralStatistics  {\\\\nactivityCount  \\\\n}\\\\n\\\\n}\\\\n\\";
  module Raw = {
    type t = {
      id: string,
      name: string,
      generalStatistics: t_generalStatistics,
    }
    and t_generalStatistics = {activityCount: int};
    type t_User = t;
  };
  type t = {
    id: string,
    name: string,
    generalStatistics: t_generalStatistics,
  }
  and t_generalStatistics = {activityCount: int};
  type t_User = t;

  let parse = (value: Raw.t): t => {

    id: {
      let value = (value: Raw.t).id;

      value;
    },

    name: {
      let value = (value: Raw.t).name;

      value;
    },

    generalStatistics: {
      let value = (value: Raw.t).generalStatistics;
      (
        {

          activityCount: {
            let value = (value: Raw.t_generalStatistics).activityCount;

            value;
          },
        }: t_generalStatistics
      );
    },
  };
  let serialize: t => Raw.t =
    (value) => (
      {

        id: {
          let value = (value: t).id;

          value;
        },

        name: {
          let value = (value: t).name;

          value;
        },

        generalStatistics: {
          let value = (value: t).generalStatistics;
          (
            {

              activityCount: {
                let value = (value: t_generalStatistics).activityCount;

                value;
              },
            }: Raw.t_generalStatistics
          );
        },
      }: Raw.t
    );
  let name = \\"LargeAvatars_User\\";
};
module Small_Avatar_User = {
  let query = \\"fragment Small_Avatar_User on User   {\\\\nid  \\\\nname  \\\\nsmallAvatar: avatar(scaleFactor: $pixelRatio, width: 60, height: 60)  {\\\\nurl  \\\\ncolor  \\\\n}\\\\n\\\\n}\\\\n\\";
  module Raw = {
    type t = {
      id: string,
      name: string,
      smallAvatar: Js.Nullable.t(t_smallAvatar),
    }
    and t_smallAvatar = {
      url: string,
      color: Js.Nullable.t(string),
    };
    type t_User = t;
  };
  type t = {
    id: string,
    name: string,
    smallAvatar: option(t_smallAvatar),
  }
  and t_smallAvatar = {
    url: string,
    color: option(string),
  };
  type t_User = t;

  let parse =
      (~pixelRatio as _pixelRatio: [ | \`Float_NonNull], value: Raw.t): t => {

    id: {
      let value = (value: Raw.t).id;

      value;
    },

    name: {
      let value = (value: Raw.t).name;

      value;
    },

    smallAvatar: {
      let value = (value: Raw.t).smallAvatar;

      switch (Js.toOption(value)) {
      | Some(value) =>
        Some(
          {

            url: {
              let value = (value: Raw.t_smallAvatar).url;

              value;
            },

            color: {
              let value = (value: Raw.t_smallAvatar).color;

              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
          }: t_smallAvatar,
        )
      | None => None
      };
    },
  };
  let serialize: t => Raw.t =
    (value) => (
      {

        id: {
          let value = (value: t).id;

          value;
        },

        name: {
          let value = (value: t).name;

          value;
        },

        smallAvatar: {
          let value = (value: t).smallAvatar;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {

                url: {
                  let value = (value: t_smallAvatar).url;

                  value;
                },

                color: {
                  let value = (value: t_smallAvatar).color;

                  switch (value) {
                  | Some(value) => Js.Nullable.return(value)
                  | None => Js.Nullable.null
                  };
                },
              }: Raw.t_smallAvatar,
            )
          | None => Js.Nullable.null
          };
        },
      }: Raw.t
    );
  let name = \\"Small_Avatar_User\\";
};

module Query = {
  module Raw = {
    type t = {activityFeedItem: Js.Nullable.t(t_activityFeedItem)}
    and t_activityFeedItem = {
      id: string,
      duration: Js.Nullable.t(int),
      rating: Js.Nullable.t(int),
      activity: t_activityFeedItem_activity,
      participants: array(t_activityFeedItem_participants),
    }
    and t_activityFeedItem_participants
    and t_activityFeedItem_participants_generalStatistics = {
      activityCount: int,
    }
    and t_activityFeedItem_activity = {
      id: string,
      title: Js.Nullable.t(string),
      description: Js.Nullable.t(string),
      duration: Js.Nullable.t(int),
      cognitiveAspects: array(t_activityFeedItem_activity_cognitiveAspects),
    }
    and t_activityFeedItem_activity_cognitiveAspects = {
      id: string,
      name: Js.Nullable.t(string),
    };
  };
  let query =
    (
      (
        (
          (
            (
              \\"query ActivityOverviewQuery($id: ID!, $pixelRatio: Float!)  {\\\\nactivityFeedItem(id: $id)  {\\\\nid  \\\\nduration  \\\\nrating  \\\\nactivity  {\\\\nid  \\\\ntitle  \\\\ndescription  \\\\nduration  \\\\ncognitiveAspects  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\nparticipants  {\\\\nid  \\\\nname  \\\\ngeneralStatistics  {\\\\nactivityCount  \\\\n}\\\\n\\\\n...\\"
              ++ LargeAvatars_User.name
            )
            ++ \\"   \\\\n...\\"
          )
          ++ Small_Avatar_User.name
        )
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ LargeAvatars_User.query
    )
    ++ Small_Avatar_User.query;
  type t = {activityFeedItem: option(t_activityFeedItem)}
  and t_activityFeedItem = {
    id: string,
    duration: option(int),
    rating: option(int),
    activity: t_activityFeedItem_activity,
    participants: array(t_activityFeedItem_participants),
  }
  and t_activityFeedItem_participants = {
    id: string,
    name: string,
    generalStatistics: t_activityFeedItem_participants_generalStatistics,
    largeAvatars_User: LargeAvatars_User.t_User,
    small_Avatar_User: Small_Avatar_User.t_User,
  }
  and t_activityFeedItem_participants_generalStatistics = {activityCount: int}
  and t_activityFeedItem_activity = {
    id: string,
    title: option(string),
    description: option(string),
    duration: option(int),
    cognitiveAspects: array(t_activityFeedItem_activity_cognitiveAspects),
  }
  and t_activityFeedItem_activity_cognitiveAspects = {
    id: string,
    name: option(string),
  };
  type t_variables = {
    id: string,
    pixelRatio: float,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        activityFeedItem: {
          let value = (value: Raw.t).activityFeedItem;

          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {

                id: {
                  let value = (value: Raw.t_activityFeedItem).id;

                  value;
                },

                duration: {
                  let value = (value: Raw.t_activityFeedItem).duration;

                  switch (Js.toOption(value)) {
                  | Some(value) => Some(value)
                  | None => None
                  };
                },

                rating: {
                  let value = (value: Raw.t_activityFeedItem).rating;

                  switch (Js.toOption(value)) {
                  | Some(value) => Some(value)
                  | None => None
                  };
                },

                activity: {
                  let value = (value: Raw.t_activityFeedItem).activity;
                  (
                    {

                      id: {
                        let value =
                          (value: Raw.t_activityFeedItem_activity).id;

                        value;
                      },

                      title: {
                        let value =
                          (value: Raw.t_activityFeedItem_activity).title;

                        switch (Js.toOption(value)) {
                        | Some(value) => Some(value)
                        | None => None
                        };
                      },

                      description: {
                        let value =
                          (value: Raw.t_activityFeedItem_activity).description;

                        switch (Js.toOption(value)) {
                        | Some(value) => Some(value)
                        | None => None
                        };
                      },

                      duration: {
                        let value =
                          (value: Raw.t_activityFeedItem_activity).duration;

                        switch (Js.toOption(value)) {
                        | Some(value) => Some(value)
                        | None => None
                        };
                      },

                      cognitiveAspects: {
                        let value =
                          (value: Raw.t_activityFeedItem_activity).
                            cognitiveAspects;

                        value
                        |> Js.Array.map((value) =>
                             (
                               {

                                 id: {
                                   let value =
                                     (
                                       value: Raw.t_activityFeedItem_activity_cognitiveAspects
                                     ).
                                       id;

                                   value;
                                 },

                                 name: {
                                   let value =
                                     (
                                       value: Raw.t_activityFeedItem_activity_cognitiveAspects
                                     ).
                                       name;

                                   switch (Js.toOption(value)) {
                                   | Some(value) => Some(value)
                                   | None => None
                                   };
                                 },
                               }: t_activityFeedItem_activity_cognitiveAspects
                             )
                           );
                      },
                    }: t_activityFeedItem_activity
                  );
                },

                participants: {
                  let value = (value: Raw.t_activityFeedItem).participants;

                  value
                  |> Js.Array.map((value) =>
                       (
                         {

                           id: {
                             let value =
                               Obj.magic(
                                 Js.Dict.unsafeGet(Obj.magic(value), \\"id\\"),
                               );

                             value;
                           },

                           name: {
                             let value =
                               Obj.magic(
                                 Js.Dict.unsafeGet(Obj.magic(value), \\"name\\"),
                               );

                             value;
                           },

                           generalStatistics: {
                             let value =
                               Obj.magic(
                                 Js.Dict.unsafeGet(
                                   Obj.magic(value),
                                   \\"generalStatistics\\",
                                 ),
                               );
                             (
                               {

                                 activityCount: {
                                   let value =
                                     (
                                       value: Raw.t_activityFeedItem_participants_generalStatistics
                                     ).
                                       activityCount;

                                   value;
                                 },
                               }: t_activityFeedItem_participants_generalStatistics
                             );
                           },

                           largeAvatars_User: {
                             let value: LargeAvatars_User.Raw.t =
                               Obj.magic(value);

                             LargeAvatars_User.parse(value);
                           },

                           small_Avatar_User: {
                             let value: Small_Avatar_User.Raw.t =
                               Obj.magic(value);

                             Small_Avatar_User.parse(
                               ~pixelRatio=\`Float_NonNull,
                               value,
                             );
                           },
                         }: t_activityFeedItem_participants
                       )
                     );
                },
              }: t_activityFeedItem,
            )
          | None => None
          };
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        activityFeedItem: {
          let value = (value: t).activityFeedItem;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {

                id: {
                  let value = (value: t_activityFeedItem).id;

                  value;
                },

                duration: {
                  let value = (value: t_activityFeedItem).duration;

                  switch (value) {
                  | Some(value) => Js.Nullable.return(value)
                  | None => Js.Nullable.null
                  };
                },

                rating: {
                  let value = (value: t_activityFeedItem).rating;

                  switch (value) {
                  | Some(value) => Js.Nullable.return(value)
                  | None => Js.Nullable.null
                  };
                },

                activity: {
                  let value = (value: t_activityFeedItem).activity;
                  (
                    {

                      id: {
                        let value = (value: t_activityFeedItem_activity).id;

                        value;
                      },

                      title: {
                        let value = (value: t_activityFeedItem_activity).title;

                        switch (value) {
                        | Some(value) => Js.Nullable.return(value)
                        | None => Js.Nullable.null
                        };
                      },

                      description: {
                        let value =
                          (value: t_activityFeedItem_activity).description;

                        switch (value) {
                        | Some(value) => Js.Nullable.return(value)
                        | None => Js.Nullable.null
                        };
                      },

                      duration: {
                        let value =
                          (value: t_activityFeedItem_activity).duration;

                        switch (value) {
                        | Some(value) => Js.Nullable.return(value)
                        | None => Js.Nullable.null
                        };
                      },

                      cognitiveAspects: {
                        let value =
                          (value: t_activityFeedItem_activity).
                            cognitiveAspects;

                        value
                        |> Js.Array.map((value) =>
                             (
                               {

                                 id: {
                                   let value =
                                     (
                                       value: t_activityFeedItem_activity_cognitiveAspects
                                     ).
                                       id;

                                   value;
                                 },

                                 name: {
                                   let value =
                                     (
                                       value: t_activityFeedItem_activity_cognitiveAspects
                                     ).
                                       name;

                                   switch (value) {
                                   | Some(value) => Js.Nullable.return(value)
                                   | None => Js.Nullable.null
                                   };
                                 },
                               }: Raw.t_activityFeedItem_activity_cognitiveAspects
                             )
                           );
                      },
                    }: Raw.t_activityFeedItem_activity
                  );
                },

                participants: {
                  let value = (value: t_activityFeedItem).participants;

                  value
                  |> Js.Array.map((value) =>
                       (
                         Obj.magic(
                           Js.Array.reduce(
                             GraphQL_PPX.deepMerge,
                             Obj.magic(Js.Dict.empty): Js.Json.t,
                             [|
                               (
                                 Obj.magic(
                                   LargeAvatars_User.serialize(
                                     (value: t_activityFeedItem_participants).
                                       largeAvatars_User,
                                   ),
                                 ): Js.Json.t
                               ),
                               (
                                 Obj.magic(
                                   Small_Avatar_User.serialize(
                                     (value: t_activityFeedItem_participants).
                                       small_Avatar_User,
                                   ),
                                 ): Js.Json.t
                               ),
                             |],
                           ),
                         ): Raw.t_activityFeedItem_participants
                       )
                     );
                },
              }: Raw.t_activityFeedItem,
            )
          | None => Js.Nullable.null
          };
        },
      }: Raw.t
    );
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (\\"id\\", (a => Some(Js.Json.string(a)))(inp.id)),
        (\\"pixelRatio\\", (a => Some(Js.Json.number(a)))(inp.pixelRatio)),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~id, ~pixelRatio, ()) =>
    f(
      serializeVariables(
        {

          id,

          pixelRatio,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Records comment.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {nonrecursiveInput: string};
  };
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {nonrecursiveInput: string};
  type t_variables = {arg: t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    field: option(string),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  let parse: Raw.t => t =
    (value) => (
      {

        nonrecursiveInput: {
          let value = (value: Raw.t).nonrecursiveInput;

          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        nonrecursiveInput: {
          let value = (value: t).nonrecursiveInput;

          value;
        },
      }: Raw.t
    );
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (a => Some(serializeInputObjectNonrecursiveInput(a)))(inp.arg),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Js.Json.t =
    inp =>
      [|
        (
          \\"field\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp.field,
          ),
        ),
        (
          \\"enum\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      switch (a) {
                      | \`FIRST => Js.Json.string(\\"FIRST\\")
                      | \`SECOND => Js.Json.string(\\"SECOND\\")
                      | \`THIRD => Js.Json.string(\\"THIRD\\")
                      },
                    )
                )(
                  b,
                )
              }
          )(
            inp.enum,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          arg: arg,
        }: t_variables,
      ),
    )
  and makeInputObjectNonrecursiveInput =
      (~field=?, ~enum=?, ()): t_variables_NonrecursiveInput => {

    field,

    enum,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Records customDecoder.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module StringOfInt = {
  let parse = string_of_int;
  type t = string;
};
module IntOfString = {
  let parse = int_of_string;
  type t = int;
};

module MyQuery = {
  module Raw = {
    type t = {variousScalars: t_variousScalars}
    and t_variousScalars = {
      string,
      int,
    };
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {variousScalars: t_variousScalars}
  and t_variousScalars = {
    string: IntOfString.t,
    int: StringOfInt.t,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {

              string: {
                let value = (value: Raw.t_variousScalars).string;

                IntOfString.parse(value);
              },

              int: {
                let value = (value: Raw.t_variousScalars).int;

                StringOfInt.parse(value);
              },
            }: t_variousScalars
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        variousScalars: {
          let value = (value: t).variousScalars;
          (
            {

              string: {
                let value = (value: t_variousScalars).string;

                IntOfString.serialize(value);
              },

              int: {
                let value = (value: t_variousScalars).int;

                StringOfInt.serialize(value);
              },
            }: Raw.t_variousScalars
          );
        },
      }: Raw.t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Records customScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {customScalarField: t_customScalarField}
    and t_customScalarField = {
      nullable: Js.Nullable.t(Js.Json.t),
      nonNullable: Js.Json.t,
    };
  };
  let query = \\"query ($opt: CustomScalar, $req: CustomScalar!)  {\\\\ncustomScalarField(argOptional: $opt, argRequired: $req)  {\\\\nnullable  \\\\nnonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {customScalarField: t_customScalarField}
  and t_customScalarField = {
    nullable: option(Js.Json.t),
    nonNullable: Js.Json.t,
  };
  type t_variables = {
    opt: option(Js.Json.t),
    req: Js.Json.t,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        customScalarField: {
          let value = (value: Raw.t).customScalarField;
          (
            {

              nullable: {
                let value = (value: Raw.t_customScalarField).nullable;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              nonNullable: {
                let value = (value: Raw.t_customScalarField).nonNullable;

                value;
              },
            }: t_customScalarField
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        customScalarField: {
          let value = (value: t).customScalarField;
          (
            {

              nullable: {
                let value = (value: t_customScalarField).nullable;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },

              nonNullable: {
                let value = (value: t_customScalarField).nonNullable;

                value;
              },
            }: Raw.t_customScalarField
          );
        },
      }: Raw.t
    );
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"opt\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(a))(b)
              }
          )(
            inp.opt,
          ),
        ),
        (\\"req\\", (a => Some(a))(inp.req)),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~opt=?, ~req, ()) =>
    f(
      serializeVariables(
        {

          opt,

          req,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Records enumInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {enumInput: string};
  };
  let query = \\"query ($arg: SampleField!)  {\\\\nenumInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {enumInput: string};
  type t_variables = {arg: [ | \`FIRST | \`SECOND | \`THIRD]};
  let parse: Raw.t => t =
    (value) => (
      {

        enumInput: {
          let value = (value: Raw.t).enumInput;

          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        enumInput: {
          let value = (value: t).enumInput;

          value;
        },
      }: Raw.t
    );
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (
            a =>
              Some(
                switch (a) {
                | \`FIRST => Js.Json.string(\\"FIRST\\")
                | \`SECOND => Js.Json.string(\\"SECOND\\")
                | \`THIRD => Js.Json.string(\\"THIRD\\")
                },
              )
          )(
            inp.arg,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          arg: arg,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Records explicit_object_record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module RecordsQuery = {
  module Raw = {
    type t = {lists: t_lists}
    and t_lists = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {lists: t_lists}
  and t_lists = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  let parse: Raw.t => t =
    (value) => (
      {

        lists: {
          let value = (value: Raw.t).lists;
          (
            {

              nullableOfNullable: {
                let value = (value: Raw.t_lists).nullableOfNullable;

                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              },

              nullableOfNonNullable: {
                let value = (value: Raw.t_lists).nullableOfNonNullable;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value |> Js.Array.map(value => value))
                | None => None
                };
              },

              nonNullableOfNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNullable;

                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   );
              },

              nonNullableOfNonNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNonNullable;

                value |> Js.Array.map(value => value);
              },
            }: t_lists
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        lists: {
          let value = (value: t).lists;
          (
            {

              nullableOfNullable: {
                let value = (value: t_lists).nullableOfNullable;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map(value =>
                         switch (value) {
                         | Some(value) => Js.Nullable.return(value)
                         | None => Js.Nullable.null
                         }
                       ),
                  )
                | None => Js.Nullable.null
                };
              },

              nullableOfNonNullable: {
                let value = (value: t_lists).nullableOfNonNullable;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(value |> Js.Array.map(value => value))
                | None => Js.Nullable.null
                };
              },

              nonNullableOfNullable: {
                let value = (value: t_lists).nonNullableOfNullable;

                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   );
              },

              nonNullableOfNonNullable: {
                let value = (value: t_lists).nonNullableOfNonNullable;

                value |> Js.Array.map(value => value);
              },
            }: Raw.t_lists
          );
        },
      }: Raw.t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};

module ObjectsQuery = {
  module Raw = {
    type t = {. \\"lists\\": t_lists}
    and t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"lists\\": t_lists}
  and t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  let parse: Raw.t => t =
    value => {

      \\"lists\\": {
        let value = value##lists;
        {

          \\"nullableOfNullable\\": {
            let value = value##nullableOfNullable;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some(
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   ),
              )
            | None => None
            };
          },

          \\"nullableOfNonNullable\\": {
            let value = value##nullableOfNonNullable;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value |> Js.Array.map(value => value))
            | None => None
            };
          },

          \\"nonNullableOfNullable\\": {
            let value = value##nonNullableOfNullable;

            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               );
          },

          \\"nonNullableOfNonNullable\\": {
            let value = value##nonNullableOfNonNullable;

            value |> Js.Array.map(value => value);
          },
        };
      },
    };
  let serialize: t => Raw.t =
    value => {

      \\"lists\\": {
        let value = value##lists;
        {

          \\"nullableOfNullable\\": {
            let value = value##nullableOfNullable;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return(
                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   ),
              )
            | None => Js.Nullable.null
            };
          },

          \\"nullableOfNonNullable\\": {
            let value = value##nullableOfNonNullable;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return(value |> Js.Array.map(value => value))
            | None => Js.Nullable.null
            };
          },

          \\"nonNullableOfNullable\\": {
            let value = value##nonNullableOfNullable;

            value
            |> Js.Array.map(value =>
                 switch (value) {
                 | Some(value) => Js.Nullable.return(value)
                 | None => Js.Nullable.null
                 }
               );
          },

          \\"nonNullableOfNonNullable\\": {
            let value = value##nonNullableOfNonNullable;

            value |> Js.Array.map(value => value);
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Records fragmentDefinition.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module GraphQL_PPX = {
  let%private clone: Js.Dict.t('a) => Js.Dict.t('a) =
    a => Obj.magic(Js.Obj.assign(Obj.magic(Js.Obj.empty()), Obj.magic(a)));

  let rec deepMerge = (json1: Js.Json.t, json2: Js.Json.t) =>
    switch (
      (
        Obj.magic(json1) == Js.null,
        Js_array2.isArray(json1),
        Js.typeof(json1) == \\"object\\",
      ),
      (
        Obj.magic(json2) == Js.null,
        Js_array2.isArray(json2),
        Js.typeof(json2) == \\"object\\",
      ),
    ) {
    | ((_, true, _), (_, true, _)) => (
        Obj.magic(
          Js.Array.mapi(
            (el1, idx) => {
              let el2 = Js.Array.unsafe_get(Obj.magic(json2), idx);

              Js.typeof(el2) == \\"object\\" ? deepMerge(el1, el2) : el2;
            },
            Obj.magic(json1),
          ),
        ): Js.Json.t
      )

    | ((false, false, true), (false, false, true)) =>
      let obj1 = clone(Obj.magic(json1));
      let obj2 = Obj.magic(json2);
      Js.Dict.keys(obj2)
      |> Js.Array.forEach(key =>
           let existingVal: Js.Json.t = Js.Dict.unsafeGet(obj1, key);
           let newVal: Js.Json.t = Js.Dict.unsafeGet(obj1, key);
           Js.Dict.set(
             obj1,
             key,
             Js.typeof(existingVal) != \\"object\\"
               ? newVal : Obj.magic(deepMerge(existingVal, newVal)),
           );
         );
      Obj.magic(obj1);

    | ((_, _, _), (_, _, _)) => json2
    };
};

module Fragments = {
  module ListFragment = {
    let query = \\"fragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
        nullableOfNonNullable: Js.Nullable.t(array(string)),
      };
      type t_Lists = t;
    };
    type t = {
      nullableOfNullable: option(array(option(string))),
      nullableOfNonNullable: option(array(string)),
    };
    type t_Lists = t;

    let parse = (value: Raw.t): t => {

      nullableOfNullable: {
        let value = (value: Raw.t).nullableOfNullable;

        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      },

      nullableOfNonNullable: {
        let value = (value: Raw.t).nullableOfNonNullable;

        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      },
    };
    let serialize: t => Raw.t =
      (value) => (
        {

          nullableOfNullable: {
            let value = (value: t).nullableOfNullable;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return(
                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   ),
              )
            | None => Js.Nullable.null
            };
          },

          nullableOfNonNullable: {
            let value = (value: t).nullableOfNonNullable;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return(value |> Js.Array.map(value => value))
            | None => Js.Nullable.null
            };
          },
        }: Raw.t
      );
    let name = \\"ListFragment\\";
  };
  module Another = {
    let query = \\"fragment Another on Lists   {\\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
    module Raw = {
      type t = {nullableOfNonNullable: Js.Nullable.t(array(string))};
      type t_Lists = t;
    };
    type t = {nullableOfNonNullable: option(array(string))};
    type t_Lists = t;

    let parse = (value: Raw.t): t => {

      nullableOfNonNullable: {
        let value = (value: Raw.t).nullableOfNonNullable;

        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      },
    };
    let serialize: t => Raw.t =
      (value) => (
        {

          nullableOfNonNullable: {
            let value = (value: t).nullableOfNonNullable;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return(value |> Js.Array.map(value => value))
            | None => Js.Nullable.null
            };
          },
        }: Raw.t
      );
    let name = \\"Another\\";
  };
};

module MyQuery = {
  module Raw = {
    type t = {
      l1: Fragments.ListFragment.Raw.t,
      l2: t_l2,
      l3: t_l3,
      l4: t_l4,
    }
    and t_l4
    and t_l3
    and t_l2;
  };
  let query =
    (
      (
        (
          (
            (
              (
                (
                  (
                    (
                      (
                        (
                          (
                            \\"query   {\\\\nl1: lists  {\\\\n...\\"
                            ++ Fragments.ListFragment.name
                          )
                          ++ \\"   \\\\n}\\\\n\\\\nl2: lists  {\\\\n...\\"
                        )
                        ++ Fragments.ListFragment.name
                      )
                      ++ \\"   \\\\n...\\"
                    )
                    ++ Fragments.ListFragment.name
                  )
                  ++ \\"   \\\\n}\\\\n\\\\nl3: lists  {\\\\nnullableOfNullable  \\\\n...\\"
                )
                ++ Fragments.ListFragment.name
              )
              ++ \\"   \\\\n...\\"
            )
            ++ Fragments.ListFragment.name
          )
          ++ \\"   \\\\n}\\\\n\\\\nl4: lists  {\\\\nnullableOfNullable  \\\\n...\\"
        )
        ++ Fragments.ListFragment.name
      )
      ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
    )
    ++ Fragments.ListFragment.query;
  type t = {
    l1: Fragments.ListFragment.t,
    l2: t_l2,
    l3: t_l3,
    l4: t_l4,
  }
  and t_l4 = {
    nullableOfNullable: option(array(option(string))),
    listFragment: Fragments.ListFragment.t_Lists,
  }
  and t_l3 = {
    nullableOfNullable: option(array(option(string))),
    frag1: Fragments.ListFragment.t_Lists,
    frag2: Fragments.ListFragment.t_Lists,
  }
  and t_l2 = {
    frag1: Fragments.ListFragment.t_Lists,
    frag2: Fragments.ListFragment.t_Lists,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        l1: {
          let value = (value: Raw.t).l1;

          Fragments.ListFragment.parse(value);
        },

        l2: {
          let value = (value: Raw.t).l2;
          (
            {

              frag1: {
                let value: Fragments.ListFragment.Raw.t = Obj.magic(value);

                Fragments.ListFragment.parse(value);
              },

              frag2: {
                let value: Fragments.ListFragment.Raw.t = Obj.magic(value);

                Fragments.ListFragment.parse(value);
              },
            }: t_l2
          );
        },

        l3: {
          let value = (value: Raw.t).l3;
          (
            {

              nullableOfNullable: {
                let value =
                  Obj.magic(
                    Js.Dict.unsafeGet(
                      Obj.magic(value),
                      \\"nullableOfNullable\\",
                    ),
                  );

                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              },

              frag1: {
                let value: Fragments.ListFragment.Raw.t = Obj.magic(value);

                Fragments.ListFragment.parse(value);
              },

              frag2: {
                let value: Fragments.ListFragment.Raw.t = Obj.magic(value);

                Fragments.ListFragment.parse(value);
              },
            }: t_l3
          );
        },

        l4: {
          let value = (value: Raw.t).l4;
          (
            {

              nullableOfNullable: {
                let value =
                  Obj.magic(
                    Js.Dict.unsafeGet(
                      Obj.magic(value),
                      \\"nullableOfNullable\\",
                    ),
                  );

                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              },

              listFragment: {
                let value: Fragments.ListFragment.Raw.t = Obj.magic(value);

                Fragments.ListFragment.parse(value);
              },
            }: t_l4
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        l1: {
          let value = (value: t).l1;
          Fragments.ListFragment.serialize(value);
        },

        l2: {
          let value = (value: t).l2;
          (
            Obj.magic(
              Js.Array.reduce(
                GraphQL_PPX.deepMerge,
                Obj.magic(Js.Dict.empty): Js.Json.t,
                [|
                  (
                    Obj.magic(
                      Fragments.ListFragment.serialize((value: t_l2).frag1),
                    ): Js.Json.t
                  ),
                  (
                    Obj.magic(
                      Fragments.ListFragment.serialize((value: t_l2).frag2),
                    ): Js.Json.t
                  ),
                |],
              ),
            ): Raw.t_l2
          );
        },

        l3: {
          let value = (value: t).l3;
          (
            Obj.magic(
              Js.Array.reduce(
                GraphQL_PPX.deepMerge,
                Obj.magic(Js.Dict.empty): Js.Json.t,
                [|
                  (
                    Obj.magic(
                      Fragments.ListFragment.serialize((value: t_l3).frag1),
                    ): Js.Json.t
                  ),
                  (
                    Obj.magic(
                      Fragments.ListFragment.serialize((value: t_l3).frag2),
                    ): Js.Json.t
                  ),
                |],
              ),
            ): Raw.t_l3
          );
        },

        l4: {
          let value = (value: t).l4;
          (
            Obj.magic(
              Js.Array.reduce(
                GraphQL_PPX.deepMerge,
                Obj.magic(Js.Dict.empty): Js.Json.t,
                [|
                  (
                    Obj.magic(
                      Fragments.ListFragment.serialize(
                        (value: t_l4).listFragment,
                      ),
                    ): Js.Json.t
                  ),
                |],
              ),
            ): Raw.t_l4
          );
        },
      }: Raw.t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Records interface.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
"
`;

exports[`Records lists.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {lists: t_lists}
    and t_lists = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {lists: t_lists}
  and t_lists = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  let parse: Raw.t => t =
    (value) => (
      {

        lists: {
          let value = (value: Raw.t).lists;
          (
            {

              nullableOfNullable: {
                let value = (value: Raw.t_lists).nullableOfNullable;

                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              },

              nullableOfNonNullable: {
                let value = (value: Raw.t_lists).nullableOfNonNullable;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value |> Js.Array.map(value => value))
                | None => None
                };
              },

              nonNullableOfNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNullable;

                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   );
              },

              nonNullableOfNonNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNonNullable;

                value |> Js.Array.map(value => value);
              },
            }: t_lists
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        lists: {
          let value = (value: t).lists;
          (
            {

              nullableOfNullable: {
                let value = (value: t_lists).nullableOfNullable;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map(value =>
                         switch (value) {
                         | Some(value) => Js.Nullable.return(value)
                         | None => Js.Nullable.null
                         }
                       ),
                  )
                | None => Js.Nullable.null
                };
              },

              nullableOfNonNullable: {
                let value = (value: t_lists).nullableOfNonNullable;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(value |> Js.Array.map(value => value))
                | None => Js.Nullable.null
                };
              },

              nonNullableOfNullable: {
                let value = (value: t_lists).nonNullableOfNullable;

                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   );
              },

              nonNullableOfNonNullable: {
                let value = (value: t_lists).nonNullableOfNonNullable;

                value |> Js.Array.map(value => value);
              },
            }: Raw.t_lists
          );
        },
      }: Raw.t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Records listsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {listsInput: string};
  };
  let query = \\"query ($nullableOfNullable: [String], $nullableOfNonNullable: [String!], $nonNullableOfNullable: [String]!, $nonNullableOfNonNullable: [String!]!)  {\\\\nlistsInput(arg: {nullableOfNullable: $nullableOfNullable, nullableOfNonNullable: $nullableOfNonNullable, nonNullableOfNullable: $nonNullableOfNullable, nonNullableOfNonNullable: $nonNullableOfNonNullable})  \\\\n}\\\\n\\";
  type t = {listsInput: string};
  type t_variables = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  let parse: Raw.t => t =
    (value) => (
      {

        listsInput: {
          let value = (value: Raw.t).listsInput;

          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        listsInput: {
          let value = (value: t).listsInput;

          value;
        },
      }: Raw.t
    );
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"nullableOfNullable\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      a
                      |> Array.map(b =>
                           switch (
                             (
                               a =>
                                 switch (a) {
                                 | None => None
                                 | Some(b) =>
                                   (a => Some(Js.Json.string(a)))(b)
                                 }
                             )(
                               b,
                             )
                           ) {
                           | Some(c) => c
                           | None => Js.Json.null
                           }
                         )
                      |> Js.Json.array,
                    )
                )(
                  b,
                )
              }
          )(
            inp.nullableOfNullable,
          ),
        ),
        (
          \\"nullableOfNonNullable\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      a
                      |> Array.map(b =>
                           switch ((a => Some(Js.Json.string(a)))(b)) {
                           | Some(c) => c
                           | None => Js.Json.null
                           }
                         )
                      |> Js.Json.array,
                    )
                )(
                  b,
                )
              }
          )(
            inp.nullableOfNonNullable,
          ),
        ),
        (
          \\"nonNullableOfNullable\\",
          (
            a =>
              Some(
                a
                |> Array.map(b =>
                     switch (
                       (
                         a =>
                           switch (a) {
                           | None => None
                           | Some(b) => (a => Some(Js.Json.string(a)))(b)
                           }
                       )(
                         b,
                       )
                     ) {
                     | Some(c) => c
                     | None => Js.Json.null
                     }
                   )
                |> Js.Json.array,
              )
          )(
            inp.nonNullableOfNullable,
          ),
        ),
        (
          \\"nonNullableOfNonNullable\\",
          (
            a =>
              Some(
                a
                |> Array.map(b =>
                     switch ((a => Some(Js.Json.string(a)))(b)) {
                     | Some(c) => c
                     | None => Js.Json.null
                     }
                   )
                |> Js.Json.array,
              )
          )(
            inp.nonNullableOfNonNullable,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar =
      (
        ~f,
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      ) =>
    f(
      serializeVariables(
        {

          nullableOfNullable,

          nullableOfNonNullable,

          nonNullableOfNullable,

          nonNullableOfNonNullable,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Records listsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {listsInput: string};
  };
  let query = \\"query ($arg: ListsInput!)  {\\\\nlistsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {listsInput: string};
  type t_variables = {arg: t_variables_ListsInput}
  and t_variables_ListsInput = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  let parse: Raw.t => t =
    (value) => (
      {

        listsInput: {
          let value = (value: Raw.t).listsInput;

          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        listsInput: {
          let value = (value: t).listsInput;

          value;
        },
      }: Raw.t
    );
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|(\\"arg\\", (a => Some(serializeInputObjectListsInput(a)))(inp.arg))|]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectListsInput: t_variables_ListsInput => Js.Json.t =
    inp =>
      [|
        (
          \\"nullableOfNullable\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      a
                      |> Array.map(b =>
                           switch (
                             (
                               a =>
                                 switch (a) {
                                 | None => None
                                 | Some(b) =>
                                   (a => Some(Js.Json.string(a)))(b)
                                 }
                             )(
                               b,
                             )
                           ) {
                           | Some(c) => c
                           | None => Js.Json.null
                           }
                         )
                      |> Js.Json.array,
                    )
                )(
                  b,
                )
              }
          )(
            inp.nullableOfNullable,
          ),
        ),
        (
          \\"nullableOfNonNullable\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      a
                      |> Array.map(b =>
                           switch ((a => Some(Js.Json.string(a)))(b)) {
                           | Some(c) => c
                           | None => Js.Json.null
                           }
                         )
                      |> Js.Json.array,
                    )
                )(
                  b,
                )
              }
          )(
            inp.nullableOfNonNullable,
          ),
        ),
        (
          \\"nonNullableOfNullable\\",
          (
            a =>
              Some(
                a
                |> Array.map(b =>
                     switch (
                       (
                         a =>
                           switch (a) {
                           | None => None
                           | Some(b) => (a => Some(Js.Json.string(a)))(b)
                           }
                       )(
                         b,
                       )
                     ) {
                     | Some(c) => c
                     | None => Js.Json.null
                     }
                   )
                |> Js.Json.array,
              )
          )(
            inp.nonNullableOfNullable,
          ),
        ),
        (
          \\"nonNullableOfNonNullable\\",
          (
            a =>
              Some(
                a
                |> Array.map(b =>
                     switch ((a => Some(Js.Json.string(a)))(b)) {
                     | Some(c) => c
                     | None => Js.Json.null
                     }
                   )
                |> Js.Json.array,
              )
          )(
            inp.nonNullableOfNonNullable,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          arg: arg,
        }: t_variables,
      ),
    )
  and makeInputObjectListsInput =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      )
      : t_variables_ListsInput => {

    nullableOfNullable,

    nullableOfNonNullable,

    nonNullableOfNullable,

    nonNullableOfNonNullable,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Records mutation.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {mutationWithError: t_mutationWithError}
    and t_mutationWithError = {
      value: Js.Nullable.t(t_mutationWithError_value),
      errors: Js.Nullable.t(array(t_mutationWithError_errors)),
    }
    and t_mutationWithError_errors = {
      field: t_mutationWithError_errors_field,
      message: string,
    }
    and t_mutationWithError_errors_field = string
    and t_mutationWithError_value = {stringField: string};
  };
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nvalue  {\\\\nstringField  \\\\n}\\\\n\\\\nerrors  {\\\\nfield  \\\\nmessage  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {mutationWithError: t_mutationWithError}
  and t_mutationWithError = {
    value: option(t_mutationWithError_value),
    errors: option(array(t_mutationWithError_errors)),
  }
  and t_mutationWithError_errors = {
    field: t_mutationWithError_errors_field,
    message: string,
  }
  and t_mutationWithError_errors_field = [
    | \`FutureAddedValue(string)
    | \`FIRST
    | \`SECOND
    | \`THIRD
  ]
  and t_mutationWithError_value = {stringField: string};
  let parse: Raw.t => t =
    (value) => (
      {

        mutationWithError: {
          let value = (value: Raw.t).mutationWithError;
          (
            {

              value: {
                let value = (value: Raw.t_mutationWithError).value;

                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {

                      stringField: {
                        let value =
                          (value: Raw.t_mutationWithError_value).stringField;

                        value;
                      },
                    }: t_mutationWithError_value,
                  )
                | None => None
                };
              },

              errors: {
                let value = (value: Raw.t_mutationWithError).errors;

                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map((value) =>
                         (
                           {

                             field: {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).field;
                               switch (Obj.magic(value: string)) {
                               | \\"FIRST\\" => \`FIRST
                               | \\"SECOND\\" => \`SECOND
                               | \\"THIRD\\" => \`THIRD
                               | other => \`FutureAddedValue(other)
                               };
                             },

                             message: {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).
                                   message;

                               value;
                             },
                           }: t_mutationWithError_errors
                         )
                       ),
                  )
                | None => None
                };
              },
            }: t_mutationWithError
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        mutationWithError: {
          let value = (value: t).mutationWithError;
          (
            {

              value: {
                let value = (value: t_mutationWithError).value;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {

                      stringField: {
                        let value =
                          (value: t_mutationWithError_value).stringField;

                        value;
                      },
                    }: Raw.t_mutationWithError_value,
                  )
                | None => Js.Nullable.null
                };
              },

              errors: {
                let value = (value: t_mutationWithError).errors;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map((value) =>
                         (
                           {

                             field: {
                               let value =
                                 (value: t_mutationWithError_errors).field;
                               switch (value) {
                               | \`FIRST => \\"FIRST\\"
                               | \`SECOND => \\"SECOND\\"
                               | \`THIRD => \\"THIRD\\"
                               | \`FutureAddedValue(other) => other
                               };
                             },

                             message: {
                               let value =
                                 (value: t_mutationWithError_errors).message;

                               value;
                             },
                           }: Raw.t_mutationWithError_errors
                         )
                       ),
                  )
                | None => Js.Nullable.null
                };
              },
            }: Raw.t_mutationWithError
          );
        },
      }: Raw.t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Records mutationWithArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {optionalInputArgs: string};
  };
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t = {optionalInputArgs: string};
  type t_variables = {required: string};
  let parse: Raw.t => t =
    (value) => (
      {

        optionalInputArgs: {
          let value = (value: Raw.t).optionalInputArgs;

          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        optionalInputArgs: {
          let value = (value: t).optionalInputArgs;

          value;
        },
      }: Raw.t
    );
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|(\\"required\\", (a => Some(Js.Json.string(a)))(inp.required))|]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~required, ()) =>
    f(
      serializeVariables(
        {

          required: required,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Records nested.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type record = {
  f1: string,
  f2: string,
};

module MyQuery = {
  module Raw = {
    type t = {
      first: t_first,
      second: t_second,
      let_: t_let,
    }
    and t_let = {inner: Js.Nullable.t(t_let_inner)}
    and t_let_inner = {inner: Js.Nullable.t(t_let_inner_inner)}
    and t_let_inner_inner = {field: string}
    and t_second = {inner: Js.Nullable.t(t_second_inner)}
    and t_second_inner = {inner: Js.Nullable.t(t_second_inner_inner)}
    and t_second_inner_inner = {
      f1: string,
      f2: string,
    }
    and t_first = {inner: Js.Nullable.t(t_first_inner)}
    and t_first_inner = {inner: Js.Nullable.t(t_first_inner_inner)}
    and t_first_inner_inner = {field: string};
  };
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nsecond: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nf1: field  \\\\nf2: field  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nlet: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {
    first: t_first,
    second: t_second,
    let_: t_let,
  }
  and t_let = {inner: option(t_let_inner)}
  and t_let_inner = {inner: option(t_let_inner_inner)}
  and t_let_inner_inner = {field: string}
  and t_second = {inner: option(t_second_inner)}
  and t_second_inner = {inner: option(t_second_inner_inner)}
  and t_second_inner_inner = {
    f1: string,
    f2: string,
  }
  and t_first = {inner: option(t_first_inner)}
  and t_first_inner = {inner: option(t_first_inner_inner)}
  and t_first_inner_inner = {field: string};
  let parse: Raw.t => t =
    (value) => (
      {

        first: {
          let value = (value: Raw.t).first;
          (
            {

              inner: {
                let value = (value: Raw.t_first).inner;

                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {

                      inner: {
                        let value = (value: Raw.t_first_inner).inner;

                        switch (Js.toOption(value)) {
                        | Some(value) =>
                          Some(
                            {

                              field: {
                                let value =
                                  (value: Raw.t_first_inner_inner).field;

                                value;
                              },
                            }: t_first_inner_inner,
                          )
                        | None => None
                        };
                      },
                    }: t_first_inner,
                  )
                | None => None
                };
              },
            }: t_first
          );
        },

        second: {
          let value = (value: Raw.t).second;
          (
            {

              inner: {
                let value = (value: Raw.t_second).inner;

                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {

                      inner: {
                        let value = (value: Raw.t_second_inner).inner;

                        switch (Js.toOption(value)) {
                        | Some(value) =>
                          Some(
                            {

                              f1: {
                                let value =
                                  (value: Raw.t_second_inner_inner).f1;

                                value;
                              },

                              f2: {
                                let value =
                                  (value: Raw.t_second_inner_inner).f2;

                                value;
                              },
                            }: t_second_inner_inner,
                          )
                        | None => None
                        };
                      },
                    }: t_second_inner,
                  )
                | None => None
                };
              },
            }: t_second
          );
        },

        let_: {
          let value = (value: Raw.t).let_;
          (
            {

              inner: {
                let value = (value: Raw.t_let).inner;

                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {

                      inner: {
                        let value = (value: Raw.t_let_inner).inner;

                        switch (Js.toOption(value)) {
                        | Some(value) =>
                          Some(
                            {

                              field: {
                                let value =
                                  (value: Raw.t_let_inner_inner).field;

                                value;
                              },
                            }: t_let_inner_inner,
                          )
                        | None => None
                        };
                      },
                    }: t_let_inner,
                  )
                | None => None
                };
              },
            }: t_let
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        first: {
          let value = (value: t).first;
          (
            {

              inner: {
                let value = (value: t_first).inner;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {

                      inner: {
                        let value = (value: t_first_inner).inner;

                        switch (value) {
                        | Some(value) =>
                          Js.Nullable.return(
                            {

                              field: {
                                let value = (value: t_first_inner_inner).field;

                                value;
                              },
                            }: Raw.t_first_inner_inner,
                          )
                        | None => Js.Nullable.null
                        };
                      },
                    }: Raw.t_first_inner,
                  )
                | None => Js.Nullable.null
                };
              },
            }: Raw.t_first
          );
        },

        second: {
          let value = (value: t).second;
          (
            {

              inner: {
                let value = (value: t_second).inner;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {

                      inner: {
                        let value = (value: t_second_inner).inner;

                        switch (value) {
                        | Some(value) =>
                          Js.Nullable.return(
                            {

                              f1: {
                                let value = (value: t_second_inner_inner).f1;

                                value;
                              },

                              f2: {
                                let value = (value: t_second_inner_inner).f2;

                                value;
                              },
                            }: Raw.t_second_inner_inner,
                          )
                        | None => Js.Nullable.null
                        };
                      },
                    }: Raw.t_second_inner,
                  )
                | None => Js.Nullable.null
                };
              },
            }: Raw.t_second
          );
        },

        let_: {
          let value = (value: t).let_;
          (
            {

              inner: {
                let value = (value: t_let).inner;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {

                      inner: {
                        let value = (value: t_let_inner).inner;

                        switch (value) {
                        | Some(value) =>
                          Js.Nullable.return(
                            {

                              field: {
                                let value = (value: t_let_inner_inner).field;

                                value;
                              },
                            }: Raw.t_let_inner_inner,
                          )
                        | None => Js.Nullable.null
                        };
                      },
                    }: Raw.t_let_inner,
                  )
                | None => Js.Nullable.null
                };
              },
            }: Raw.t_let
          );
        },
      }: Raw.t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Records nonrecursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {nonrecursiveInput: string};
  };
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {nonrecursiveInput: string};
  type t_variables = {arg: t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    field: option(string),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  let parse: Raw.t => t =
    (value) => (
      {

        nonrecursiveInput: {
          let value = (value: Raw.t).nonrecursiveInput;

          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        nonrecursiveInput: {
          let value = (value: t).nonrecursiveInput;

          value;
        },
      }: Raw.t
    );
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (a => Some(serializeInputObjectNonrecursiveInput(a)))(inp.arg),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Js.Json.t =
    inp =>
      [|
        (
          \\"field\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp.field,
          ),
        ),
        (
          \\"enum\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      switch (a) {
                      | \`FIRST => Js.Json.string(\\"FIRST\\")
                      | \`SECOND => Js.Json.string(\\"SECOND\\")
                      | \`THIRD => Js.Json.string(\\"THIRD\\")
                      },
                    )
                )(
                  b,
                )
              }
          )(
            inp.enum,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          arg: arg,
        }: t_variables,
      ),
    )
  and makeInputObjectNonrecursiveInput =
      (~field=?, ~enum=?, ()): t_variables_NonrecursiveInput => {

    field,

    enum,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Records pokedexApolloMode.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {pokemon: Js.Nullable.t(t_pokemon)}
    and t_pokemon = {
      id: string,
      name: Js.Nullable.t(string),
    };
  };
  let query = \\"query   {\\\\npokemon(name: \\\\\\"Pikachu\\\\\\")  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {pokemon: option(t_pokemon)}
  and t_pokemon = {
    id: string,
    name: option(string),
  };
  let parse: Raw.t => t =
    (value) => (
      {

        pokemon: {
          let value = (value: Raw.t).pokemon;

          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {

                id: {
                  let value = (value: Raw.t_pokemon).id;

                  value;
                },

                name: {
                  let value = (value: Raw.t_pokemon).name;

                  switch (Js.toOption(value)) {
                  | Some(value) => Some(value)
                  | None => None
                  };
                },
              }: t_pokemon,
            )
          | None => None
          };
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        pokemon: {
          let value = (value: t).pokemon;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {

                id: {
                  let value = (value: t_pokemon).id;

                  value;
                },

                name: {
                  let value = (value: t_pokemon).name;

                  switch (value) {
                  | Some(value) => Js.Nullable.return(value)
                  | None => Js.Nullable.null
                  };
                },
              }: Raw.t_pokemon,
            )
          | None => Js.Nullable.null
          };
        },
      }: Raw.t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Records pokedexScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {pokemon: Js.Nullable.t(t_pokemon)}
    and t_pokemon = {
      id: string,
      name: Js.Nullable.t(string),
    };
  };
  let query = \\"query pokemon($id: String, $name: String)  {\\\\npokemon(name: $name, id: $id)  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {pokemon: option(t_pokemon)}
  and t_pokemon = {
    id: string,
    name: option(string),
  };
  type t_variables = {
    id: option(string),
    name: option(string),
  };
  let parse: Raw.t => t =
    (value) => (
      {

        pokemon: {
          let value = (value: Raw.t).pokemon;

          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {

                id: {
                  let value = (value: Raw.t_pokemon).id;

                  value;
                },

                name: {
                  let value = (value: Raw.t_pokemon).name;

                  switch (Js.toOption(value)) {
                  | Some(value) => Some(value)
                  | None => None
                  };
                },
              }: t_pokemon,
            )
          | None => None
          };
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        pokemon: {
          let value = (value: t).pokemon;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {

                id: {
                  let value = (value: t_pokemon).id;

                  value;
                },

                name: {
                  let value = (value: t_pokemon).name;

                  switch (value) {
                  | Some(value) => Js.Nullable.return(value)
                  | None => Js.Nullable.null
                  };
                },
              }: Raw.t_pokemon,
            )
          | None => Js.Nullable.null
          };
        },
      }: Raw.t
    );
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"id\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp.id,
          ),
        ),
        (
          \\"name\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp.name,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~id=?, ~name=?, ()) =>
    f(
      serializeVariables(
        {

          id,

          name,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Records record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type scalars = {
  string,
  int,
};

type dog = {
  name: string,
  barkVolume: float,
};

type oneFieldQuery = {nullableString: option(string)};

module MyQuery = {
  module Raw = {
    type t = {variousScalars: scalars};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {variousScalars: scalars};
  let parse: Raw.t => t =
    (value) => (
      {

        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {

              string: {
                let value = (value: Raw.t_variousScalars).string;

                value;
              },

              int: {
                let value = (value: Raw.t_variousScalars).int;

                value;
              },
            }: scalars
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        variousScalars: {
          let value = (value: t).variousScalars;
          (
            {

              string: {
                let value = (value: scalars).string;

                value;
              },

              int: {
                let value = (value: scalars).int;

                value;
              },
            }: Raw.t_variousScalars
          );
        },
      }: Raw.t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};

module OneFieldQuery = {
  module Raw = {
    type t = {variousScalars: t_variousScalars}
    and t_variousScalars = {nullableString: Js.Nullable.t(string)};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {variousScalars: t_variousScalars}
  and t_variousScalars = {nullableString: option(string)};
  let parse: Raw.t => t =
    (value) => (
      {

        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {

              nullableString: {
                let value = (value: Raw.t_variousScalars).nullableString;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
            }: t_variousScalars
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        variousScalars: {
          let value = (value: t).variousScalars;
          (
            {

              nullableString: {
                let value = (value: t_variousScalars).nullableString;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },
            }: Raw.t_variousScalars
          );
        },
      }: Raw.t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};

module ExternalFragmentQuery = {
  module Fragment = {
    let query = \\"fragment Fragment on VariousScalars   {\\\\nstring  \\\\nint  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        string,
        int,
      };
      type t_VariousScalars = t;
    };
    type t = {
      string,
      int,
    };
    type t_VariousScalars = t;

    let parse = (value: Raw.t): t => {

      string: {
        let value = (value: Raw.t).string;

        value;
      },

      int: {
        let value = (value: Raw.t).int;

        value;
      },
    };
    let serialize: t => Raw.t =
      (value) => (
        {

          string: {
            let value = (value: t).string;

            value;
          },

          int: {
            let value = (value: t).int;

            value;
          },
        }: Raw.t
      );
    let name = \\"Fragment\\";
  };
  module Untitled1 = {
    module Raw = {
      type t = {variousScalars: Fragment.Raw.t};
    };
    let query =
      (
        (\\"query   {\\\\nvariousScalars  {\\\\n...\\" ++ Fragment.name)
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ Fragment.query;
    type t = {variousScalars: Fragment.t};
    let parse: Raw.t => t =
      (value) => (
        {

          variousScalars: {
            let value = (value: Raw.t).variousScalars;

            Fragment.parse(value);
          },
        }: t
      );
    let serialize: t => Raw.t =
      (value) => (
        {

          variousScalars: {
            let value = (value: t).variousScalars;
            Fragment.serialize(value);
          },
        }: Raw.t
      );
    let makeVar = (~f, ()) => f(Js.Json.null);
    let definition = (parse, query, makeVar);
  };
};

module InlineFragmentQuery = {
  module Raw = {
    type t = {dogOrHuman: t_dogOrHuman}
    and t_dogOrHuman
    and t_dogOrHuman_Dog = {
      name: string,
      barkVolume: float,
    };
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {dogOrHuman: t_dogOrHuman}
  and t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ]
  and t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        dogOrHuman: {
          let value = (value: Raw.t).dogOrHuman;
          [@metaloc loc]
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                  (
                    {

                      name: {
                        let value = (value: Raw.t_dogOrHuman_Dog).name;

                        value;
                      },

                      barkVolume: {
                        let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;

                        value;
                      },
                    }: t_dogOrHuman_Dog
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        dogOrHuman: {
          let value = (value: t).dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {

                  name: {
                    let value = (value: t_dogOrHuman_Dog).name;

                    value;
                  },

                  barkVolume: {
                    let value = (value: t_dogOrHuman_Dog).barkVolume;

                    value;
                  },
                }: Raw.t_dogOrHuman_Dog,
              ): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        },
      }: Raw.t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};

module UnionExternalFragmentQuery = {
  module DogFragment = {
    let query = \\"fragment DogFragment on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        name: string,
        barkVolume: float,
      };
      type t_Dog = t;
    };
    type t = {
      name: string,
      barkVolume: float,
    };
    type t_Dog = t;

    let parse = (value: Raw.t): t => {

      name: {
        let value = (value: Raw.t).name;

        value;
      },

      barkVolume: {
        let value = (value: Raw.t).barkVolume;

        value;
      },
    };
    let serialize: t => Raw.t =
      (value) => (
        {

          name: {
            let value = (value: t).name;

            value;
          },

          barkVolume: {
            let value = (value: t).barkVolume;

            value;
          },
        }: Raw.t
      );
    let name = \\"DogFragment\\";
  };
  module Untitled1 = {
    module Raw = {
      type t = {dogOrHuman: t_dogOrHuman}
      and t_dogOrHuman;
    };
    let query =
      (
        (
          \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n...\\"
          ++ DogFragment.name
        )
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ DogFragment.query;
    type t = {dogOrHuman: t_dogOrHuman}
    and t_dogOrHuman = [
      | \`FutureAddedValue(Js.Json.t)
      | \`Dog(DogFragment.t)
    ];
    let parse: Raw.t => t =
      (value) => (
        {

          dogOrHuman: {
            let value = (value: Raw.t).dogOrHuman;
            [@metaloc loc]
            let typename: string =
              Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
            (
              switch (typename) {
              | \\"Dog\\" =>
                \`Dog(
                  {
                    let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);

                    DogFragment.parse(value);
                  },
                )
              | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
              }: t_dogOrHuman
            );
          },
        }: t
      );
    let serialize: t => Raw.t =
      (value) => (
        {

          dogOrHuman: {
            let value = (value: t).dogOrHuman;
            switch (value) {
            | \`Dog(value) => (
                Obj.magic(DogFragment.serialize(value)): Raw.t_dogOrHuman
              )
            | \`FutureAddedValue(value) => (
                Obj.magic(value): Raw.t_dogOrHuman
              )
            };
          },
        }: Raw.t
      );
    let makeVar = (~f, ()) => f(Js.Json.null);
    let definition = (parse, query, makeVar);
  };
};
"
`;

exports[`Records recursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {recursiveInput: string};
  };
  let query = \\"query ($arg: RecursiveInput!)  {\\\\nrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {recursiveInput: string};
  type t_variables = {arg: t_variables_RecursiveInput}
  and t_variables_RecursiveInput = {
    otherField: option(string),
    inner: option(t_variables_RecursiveInput),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  let parse: Raw.t => t =
    (value) => (
      {

        recursiveInput: {
          let value = (value: Raw.t).recursiveInput;

          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        recursiveInput: {
          let value = (value: t).recursiveInput;

          value;
        },
      }: Raw.t
    );
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (a => Some(serializeInputObjectRecursiveInput(a)))(inp.arg),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectRecursiveInput:
    t_variables_RecursiveInput => Js.Json.t =
    inp =>
      [|
        (
          \\"otherField\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp.otherField,
          ),
        ),
        (
          \\"inner\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (a => Some(serializeInputObjectRecursiveInput(a)))(b)
              }
          )(
            inp.inner,
          ),
        ),
        (
          \\"enum\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      switch (a) {
                      | \`FIRST => Js.Json.string(\\"FIRST\\")
                      | \`SECOND => Js.Json.string(\\"SECOND\\")
                      | \`THIRD => Js.Json.string(\\"THIRD\\")
                      },
                    )
                )(
                  b,
                )
              }
          )(
            inp.enum,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          arg: arg,
        }: t_variables,
      ),
    )
  and makeInputObjectRecursiveInput =
      (~otherField=?, ~inner=?, ~enum=?, ()): t_variables_RecursiveInput => {

    otherField,

    inner,

    enum,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Records scalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {variousScalars: t_variousScalars}
    and t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {variousScalars: t_variousScalars}
  and t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {

              nullableString: {
                let value = (value: Raw.t_variousScalars).nullableString;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              string: {
                let value = (value: Raw.t_variousScalars).string;

                value;
              },

              nullableInt: {
                let value = (value: Raw.t_variousScalars).nullableInt;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              int: {
                let value = (value: Raw.t_variousScalars).int;

                value;
              },

              nullableFloat: {
                let value = (value: Raw.t_variousScalars).nullableFloat;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              float: {
                let value = (value: Raw.t_variousScalars).float;

                value;
              },

              nullableBoolean: {
                let value = (value: Raw.t_variousScalars).nullableBoolean;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              boolean: {
                let value = (value: Raw.t_variousScalars).boolean;

                value;
              },

              nullableID: {
                let value = (value: Raw.t_variousScalars).nullableID;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              id: {
                let value = (value: Raw.t_variousScalars).id;

                value;
              },
            }: t_variousScalars
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        variousScalars: {
          let value = (value: t).variousScalars;
          (
            {

              nullableString: {
                let value = (value: t_variousScalars).nullableString;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },

              string: {
                let value = (value: t_variousScalars).string;

                value;
              },

              nullableInt: {
                let value = (value: t_variousScalars).nullableInt;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },

              int: {
                let value = (value: t_variousScalars).int;

                value;
              },

              nullableFloat: {
                let value = (value: t_variousScalars).nullableFloat;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },

              float: {
                let value = (value: t_variousScalars).float;

                value;
              },

              nullableBoolean: {
                let value = (value: t_variousScalars).nullableBoolean;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },

              boolean: {
                let value = (value: t_variousScalars).boolean;

                value;
              },

              nullableID: {
                let value = (value: t_variousScalars).nullableID;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },

              id: {
                let value = (value: t_variousScalars).id;

                value;
              },
            }: Raw.t_variousScalars
          );
        },
      }: Raw.t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Records scalarsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {scalarsInput: string};
  };
  let query = \\"query ($nullableString: String, $string: String!, $nullableInt: Int, $int: Int!, $nullableFloat: Float, $float: Float!, $nullableBoolean: Boolean, $boolean: Boolean!, $nullableID: ID, $id: ID!)  {\\\\nscalarsInput(arg: {nullableString: $nullableString, string: $string, nullableInt: $nullableInt, int: $int, nullableFloat: $nullableFloat, float: $float, nullableBoolean: $nullableBoolean, boolean: $boolean, nullableID: $nullableID, id: $id})  \\\\n}\\\\n\\";
  type t = {scalarsInput: string};
  type t_variables = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        scalarsInput: {
          let value = (value: Raw.t).scalarsInput;

          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        scalarsInput: {
          let value = (value: t).scalarsInput;

          value;
        },
      }: Raw.t
    );
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"nullableString\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp.nullableString,
          ),
        ),
        (\\"string\\", (a => Some(Js.Json.string(a)))(inp.string)),
        (
          \\"nullableInt\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.number(float_of_int(a))))(b)
              }
          )(
            inp.nullableInt,
          ),
        ),
        (\\"int\\", (a => Some(Js.Json.number(float_of_int(a))))(inp.int)),
        (
          \\"nullableFloat\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.number(a)))(b)
              }
          )(
            inp.nullableFloat,
          ),
        ),
        (\\"float\\", (a => Some(Js.Json.number(a)))(inp.float)),
        (
          \\"nullableBoolean\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.boolean(a)))(b)
              }
          )(
            inp.nullableBoolean,
          ),
        ),
        (\\"boolean\\", (a => Some(Js.Json.boolean(a)))(inp.boolean)),
        (
          \\"nullableID\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp.nullableID,
          ),
        ),
        (\\"id\\", (a => Some(Js.Json.string(a)))(inp.id)),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar =
      (
        ~f,
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      ) =>
    f(
      serializeVariables(
        {

          nullableString,

          string,

          nullableInt,

          int,

          nullableFloat,

          float,

          nullableBoolean,

          boolean,

          nullableID,

          id,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Records scalarsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {scalarsInput: string};
  };
  let query = \\"query ($arg: VariousScalarsInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {scalarsInput: string};
  type t_variables = {arg: t_variables_VariousScalarsInput}
  and t_variables_VariousScalarsInput = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        scalarsInput: {
          let value = (value: Raw.t).scalarsInput;

          value;
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        scalarsInput: {
          let value = (value: t).scalarsInput;

          value;
        },
      }: Raw.t
    );
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (a => Some(serializeInputObjectVariousScalarsInput(a)))(inp.arg),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectVariousScalarsInput:
    t_variables_VariousScalarsInput => Js.Json.t =
    inp =>
      [|
        (
          \\"nullableString\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp.nullableString,
          ),
        ),
        (\\"string\\", (a => Some(Js.Json.string(a)))(inp.string)),
        (
          \\"nullableInt\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.number(float_of_int(a))))(b)
              }
          )(
            inp.nullableInt,
          ),
        ),
        (\\"int\\", (a => Some(Js.Json.number(float_of_int(a))))(inp.int)),
        (
          \\"nullableFloat\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.number(a)))(b)
              }
          )(
            inp.nullableFloat,
          ),
        ),
        (\\"float\\", (a => Some(Js.Json.number(a)))(inp.float)),
        (
          \\"nullableBoolean\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.boolean(a)))(b)
              }
          )(
            inp.nullableBoolean,
          ),
        ),
        (\\"boolean\\", (a => Some(Js.Json.boolean(a)))(inp.boolean)),
        (
          \\"nullableID\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp.nullableID,
          ),
        ),
        (\\"id\\", (a => Some(Js.Json.string(a)))(inp.id)),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          arg: arg,
        }: t_variables,
      ),
    )
  and makeInputObjectVariousScalarsInput =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      )
      : t_variables_VariousScalarsInput => {

    nullableString,

    string,

    nullableInt,

    int,

    nullableFloat,

    float,

    nullableBoolean,

    boolean,

    nullableID,

    id,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Records skipDirectives.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {
      v1: t_v1,
      v2: t_v2,
    }
    and t_v2 = {
      nullableString: Js.Nullable.t(string),
      string: Js.Nullable.t(string),
    }
    and t_v1 = {
      nullableString: Js.Nullable.t(string),
      string: Js.Nullable.t(string),
    };
  };
  let query = \\"query ($var: Boolean!)  {\\\\nv1: variousScalars  {\\\\nnullableString @skip(if: $var) \\\\nstring @skip(if: $var) \\\\n}\\\\n\\\\nv2: variousScalars  {\\\\nnullableString @include(if: $var) \\\\nstring @include(if: $var) \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {
    v1: t_v1,
    v2: t_v2,
  }
  and t_v2 = {
    nullableString: option(string),
    string: option(string),
  }
  and t_v1 = {
    nullableString: option(string),
    string: option(string),
  };
  type t_variables = {var: bool};
  let parse: Raw.t => t =
    (value) => (
      {

        v1: {
          let value = (value: Raw.t).v1;
          (
            {

              nullableString: {
                let value = (value: Raw.t_v1).nullableString;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              string: {
                let value = (value: Raw.t_v1).string;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
            }: t_v1
          );
        },

        v2: {
          let value = (value: Raw.t).v2;
          (
            {

              nullableString: {
                let value = (value: Raw.t_v2).nullableString;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              string: {
                let value = (value: Raw.t_v2).string;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
            }: t_v2
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        v1: {
          let value = (value: t).v1;
          (
            {

              nullableString: {
                let value = (value: t_v1).nullableString;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },

              string: {
                let value = (value: t_v1).string;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },
            }: Raw.t_v1
          );
        },

        v2: {
          let value = (value: t).v2;
          (
            {

              nullableString: {
                let value = (value: t_v2).nullableString;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },

              string: {
                let value = (value: t_v2).string;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },
            }: Raw.t_v2
          );
        },
      }: Raw.t
    );
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|(\\"var\\", (a => Some(Js.Json.boolean(a)))(inp.var))|]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~var, ()) =>
    f(
      serializeVariables(
        {

          var: var,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Records subscription.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {simpleSubscription: t_simpleSubscription}
    and t_simpleSubscription
    and t_simpleSubscription_Human = {name: string}
    and t_simpleSubscription_Dog = {name: string};
  };
  let query = \\"subscription   {\\\\nsimpleSubscription  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {simpleSubscription: t_simpleSubscription}
  and t_simpleSubscription = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_simpleSubscription_Dog)
    | \`Human(t_simpleSubscription_Human)
  ]
  and t_simpleSubscription_Human = {name: string}
  and t_simpleSubscription_Dog = {name: string};
  let parse: Raw.t => t =
    (value) => (
      {

        simpleSubscription: {
          let value = (value: Raw.t).simpleSubscription;
          [@metaloc loc]
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_simpleSubscription_Dog = Obj.magic(value);
                  (
                    {

                      name: {
                        let value = (value: Raw.t_simpleSubscription_Dog).name;

                        value;
                      },
                    }: t_simpleSubscription_Dog
                  );
                },
              )
            | \\"Human\\" =>
              \`Human(
                {
                  let value: Raw.t_simpleSubscription_Human = Obj.magic(value);
                  (
                    {

                      name: {
                        let value =
                          (value: Raw.t_simpleSubscription_Human).name;

                        value;
                      },
                    }: t_simpleSubscription_Human
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_simpleSubscription
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        simpleSubscription: {
          let value = (value: t).simpleSubscription;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {

                  name: {
                    let value = (value: t_simpleSubscription_Dog).name;

                    value;
                  },
                }: Raw.t_simpleSubscription_Dog,
              ): Raw.t_simpleSubscription
            )
          | \`Human(value) => (
              Obj.magic(
                {

                  name: {
                    let value = (value: t_simpleSubscription_Human).name;

                    value;
                  },
                }: Raw.t_simpleSubscription_Human,
              ): Raw.t_simpleSubscription
            )
          | \`FutureAddedValue(value) => (
              Obj.magic(value): Raw.t_simpleSubscription
            )
          };
        },
      }: Raw.t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Records tagged_template.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {variousScalars: t_variousScalars}
    and t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {variousScalars: t_variousScalars}
  and t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {

              nullableString: {
                let value = (value: Raw.t_variousScalars).nullableString;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              string: {
                let value = (value: Raw.t_variousScalars).string;

                value;
              },

              nullableInt: {
                let value = (value: Raw.t_variousScalars).nullableInt;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              int: {
                let value = (value: Raw.t_variousScalars).int;

                value;
              },

              nullableFloat: {
                let value = (value: Raw.t_variousScalars).nullableFloat;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              float: {
                let value = (value: Raw.t_variousScalars).float;

                value;
              },

              nullableBoolean: {
                let value = (value: Raw.t_variousScalars).nullableBoolean;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              boolean: {
                let value = (value: Raw.t_variousScalars).boolean;

                value;
              },

              nullableID: {
                let value = (value: Raw.t_variousScalars).nullableID;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              id: {
                let value = (value: Raw.t_variousScalars).id;

                value;
              },
            }: t_variousScalars
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        variousScalars: {
          let value = (value: t).variousScalars;
          (
            {

              nullableString: {
                let value = (value: t_variousScalars).nullableString;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },

              string: {
                let value = (value: t_variousScalars).string;

                value;
              },

              nullableInt: {
                let value = (value: t_variousScalars).nullableInt;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },

              int: {
                let value = (value: t_variousScalars).int;

                value;
              },

              nullableFloat: {
                let value = (value: t_variousScalars).nullableFloat;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },

              float: {
                let value = (value: t_variousScalars).float;

                value;
              },

              nullableBoolean: {
                let value = (value: t_variousScalars).nullableBoolean;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },

              boolean: {
                let value = (value: t_variousScalars).boolean;

                value;
              },

              nullableID: {
                let value = (value: t_variousScalars).nullableID;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },

              id: {
                let value = (value: t_variousScalars).id;

                value;
              },
            }: Raw.t_variousScalars
          );
        },
      }: Raw.t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};

module MyQuery2 = {
  module Raw = {
    type t = {variousScalars: t_variousScalars}
    and t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
  };
  %raw
  \\"let { graphql } = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t = {variousScalars: t_variousScalars}
  and t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {

              nullableString: {
                let value = (value: Raw.t_variousScalars).nullableString;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              string: {
                let value = (value: Raw.t_variousScalars).string;

                value;
              },

              nullableInt: {
                let value = (value: Raw.t_variousScalars).nullableInt;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              int: {
                let value = (value: Raw.t_variousScalars).int;

                value;
              },

              nullableFloat: {
                let value = (value: Raw.t_variousScalars).nullableFloat;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              float: {
                let value = (value: Raw.t_variousScalars).float;

                value;
              },

              nullableBoolean: {
                let value = (value: Raw.t_variousScalars).nullableBoolean;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              boolean: {
                let value = (value: Raw.t_variousScalars).boolean;

                value;
              },

              nullableID: {
                let value = (value: Raw.t_variousScalars).nullableID;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              id: {
                let value = (value: Raw.t_variousScalars).id;

                value;
              },
            }: t_variousScalars
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        variousScalars: {
          let value = (value: t).variousScalars;
          (
            {

              nullableString: {
                let value = (value: t_variousScalars).nullableString;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },

              string: {
                let value = (value: t_variousScalars).string;

                value;
              },

              nullableInt: {
                let value = (value: t_variousScalars).nullableInt;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },

              int: {
                let value = (value: t_variousScalars).int;

                value;
              },

              nullableFloat: {
                let value = (value: t_variousScalars).nullableFloat;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },

              float: {
                let value = (value: t_variousScalars).float;

                value;
              },

              nullableBoolean: {
                let value = (value: t_variousScalars).nullableBoolean;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },

              boolean: {
                let value = (value: t_variousScalars).boolean;

                value;
              },

              nullableID: {
                let value = (value: t_variousScalars).nullableID;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },

              id: {
                let value = (value: t_variousScalars).id;

                value;
              },
            }: Raw.t_variousScalars
          );
        },
      }: Raw.t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};

module MyQuery3 = {
  module Raw = {
    type t = {variousScalars: t_variousScalars}
    and t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
  };
  %raw
  \\"let { graphql } = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t = {variousScalars: t_variousScalars}
  and t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {

              nullableString: {
                let value = (value: Raw.t_variousScalars).nullableString;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              string: {
                let value = (value: Raw.t_variousScalars).string;

                value;
              },

              nullableInt: {
                let value = (value: Raw.t_variousScalars).nullableInt;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              int: {
                let value = (value: Raw.t_variousScalars).int;

                value;
              },

              nullableFloat: {
                let value = (value: Raw.t_variousScalars).nullableFloat;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              float: {
                let value = (value: Raw.t_variousScalars).float;

                value;
              },

              nullableBoolean: {
                let value = (value: Raw.t_variousScalars).nullableBoolean;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              boolean: {
                let value = (value: Raw.t_variousScalars).boolean;

                value;
              },

              nullableID: {
                let value = (value: Raw.t_variousScalars).nullableID;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              id: {
                let value = (value: Raw.t_variousScalars).id;

                value;
              },
            }: t_variousScalars
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        variousScalars: {
          let value = (value: t).variousScalars;
          (
            {

              nullableString: {
                let value = (value: t_variousScalars).nullableString;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },

              string: {
                let value = (value: t_variousScalars).string;

                value;
              },

              nullableInt: {
                let value = (value: t_variousScalars).nullableInt;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },

              int: {
                let value = (value: t_variousScalars).int;

                value;
              },

              nullableFloat: {
                let value = (value: t_variousScalars).nullableFloat;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },

              float: {
                let value = (value: t_variousScalars).float;

                value;
              },

              nullableBoolean: {
                let value = (value: t_variousScalars).nullableBoolean;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },

              boolean: {
                let value = (value: t_variousScalars).boolean;

                value;
              },

              nullableID: {
                let value = (value: t_variousScalars).nullableID;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },

              id: {
                let value = (value: t_variousScalars).id;

                value;
              },
            }: Raw.t_variousScalars
          );
        },
      }: Raw.t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};

module MyQuery4 = {
  module Raw = {
    type t = {variousScalars: t_variousScalars}
    and t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
  };
  %raw
  \\"let graphql = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t = {variousScalars: t_variousScalars}
  and t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {

              nullableString: {
                let value = (value: Raw.t_variousScalars).nullableString;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              string: {
                let value = (value: Raw.t_variousScalars).string;

                value;
              },

              nullableInt: {
                let value = (value: Raw.t_variousScalars).nullableInt;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              int: {
                let value = (value: Raw.t_variousScalars).int;

                value;
              },

              nullableFloat: {
                let value = (value: Raw.t_variousScalars).nullableFloat;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              float: {
                let value = (value: Raw.t_variousScalars).float;

                value;
              },

              nullableBoolean: {
                let value = (value: Raw.t_variousScalars).nullableBoolean;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              boolean: {
                let value = (value: Raw.t_variousScalars).boolean;

                value;
              },

              nullableID: {
                let value = (value: Raw.t_variousScalars).nullableID;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              id: {
                let value = (value: Raw.t_variousScalars).id;

                value;
              },
            }: t_variousScalars
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        variousScalars: {
          let value = (value: t).variousScalars;
          (
            {

              nullableString: {
                let value = (value: t_variousScalars).nullableString;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },

              string: {
                let value = (value: t_variousScalars).string;

                value;
              },

              nullableInt: {
                let value = (value: t_variousScalars).nullableInt;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },

              int: {
                let value = (value: t_variousScalars).int;

                value;
              },

              nullableFloat: {
                let value = (value: t_variousScalars).nullableFloat;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },

              float: {
                let value = (value: t_variousScalars).float;

                value;
              },

              nullableBoolean: {
                let value = (value: t_variousScalars).nullableBoolean;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },

              boolean: {
                let value = (value: t_variousScalars).boolean;

                value;
              },

              nullableID: {
                let value = (value: t_variousScalars).nullableID;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              },

              id: {
                let value = (value: t_variousScalars).id;

                value;
              },
            }: Raw.t_variousScalars
          );
        },
      }: Raw.t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Records typename.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {first: t_first}
    and t_first = {
      __typename: string,
      inner: Js.Nullable.t(t_first_inner),
    }
    and t_first_inner = {
      __typename: string,
      inner: Js.Nullable.t(t_first_inner_inner),
    }
    and t_first_inner_inner = {
      __typename: string,
      field: string,
    };
  };
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {first: t_first}
  and t_first = {
    __typename: string,
    inner: option(t_first_inner),
  }
  and t_first_inner = {
    __typename: string,
    inner: option(t_first_inner_inner),
  }
  and t_first_inner_inner = {
    __typename: string,
    field: string,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        first: {
          let value = (value: Raw.t).first;
          (
            {

              __typename: {
                let value = (value: Raw.t_first).__typename;

                value;
              },

              inner: {
                let value = (value: Raw.t_first).inner;

                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {

                      __typename: {
                        let value = (value: Raw.t_first_inner).__typename;

                        value;
                      },

                      inner: {
                        let value = (value: Raw.t_first_inner).inner;

                        switch (Js.toOption(value)) {
                        | Some(value) =>
                          Some(
                            {

                              __typename: {
                                let value =
                                  (value: Raw.t_first_inner_inner).__typename;

                                value;
                              },

                              field: {
                                let value =
                                  (value: Raw.t_first_inner_inner).field;

                                value;
                              },
                            }: t_first_inner_inner,
                          )
                        | None => None
                        };
                      },
                    }: t_first_inner,
                  )
                | None => None
                };
              },
            }: t_first
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        first: {
          let value = (value: t).first;
          (
            {

              __typename: {
                let value = (value: t_first).__typename;

                value;
              },

              inner: {
                let value = (value: t_first).inner;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {

                      __typename: {
                        let value = (value: t_first_inner).__typename;

                        value;
                      },

                      inner: {
                        let value = (value: t_first_inner).inner;

                        switch (value) {
                        | Some(value) =>
                          Js.Nullable.return(
                            {

                              __typename: {
                                let value =
                                  (value: t_first_inner_inner).__typename;

                                value;
                              },

                              field: {
                                let value = (value: t_first_inner_inner).field;

                                value;
                              },
                            }: Raw.t_first_inner_inner,
                          )
                        | None => Js.Nullable.null
                        };
                      },
                    }: Raw.t_first_inner,
                  )
                | None => Js.Nullable.null
                };
              },
            }: Raw.t_first
          );
        },
      }: Raw.t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Records union.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {dogOrHuman: t_dogOrHuman}
    and t_dogOrHuman
    and t_dogOrHuman_Human = {name: string}
    and t_dogOrHuman_Dog = {
      name: string,
      barkVolume: float,
    };
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {dogOrHuman: t_dogOrHuman}
  and t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ]
  and t_dogOrHuman_Human = {name: string}
  and t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        dogOrHuman: {
          let value = (value: Raw.t).dogOrHuman;
          [@metaloc loc]
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                  (
                    {

                      name: {
                        let value = (value: Raw.t_dogOrHuman_Dog).name;

                        value;
                      },

                      barkVolume: {
                        let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;

                        value;
                      },
                    }: t_dogOrHuman_Dog
                  );
                },
              )
            | \\"Human\\" =>
              \`Human(
                {
                  let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                  (
                    {

                      name: {
                        let value = (value: Raw.t_dogOrHuman_Human).name;

                        value;
                      },
                    }: t_dogOrHuman_Human
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        dogOrHuman: {
          let value = (value: t).dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {

                  name: {
                    let value = (value: t_dogOrHuman_Dog).name;

                    value;
                  },

                  barkVolume: {
                    let value = (value: t_dogOrHuman_Dog).barkVolume;

                    value;
                  },
                }: Raw.t_dogOrHuman_Dog,
              ): Raw.t_dogOrHuman
            )
          | \`Human(value) => (
              Obj.magic(
                {

                  name: {
                    let value = (value: t_dogOrHuman_Human).name;

                    value;
                  },
                }: Raw.t_dogOrHuman_Human,
              ): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        },
      }: Raw.t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Records unionPartial.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {dogOrHuman: t_dogOrHuman}
    and t_dogOrHuman
    and t_dogOrHuman_Dog = {
      name: string,
      barkVolume: float,
    };
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {dogOrHuman: t_dogOrHuman}
  and t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ]
  and t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        dogOrHuman: {
          let value = (value: Raw.t).dogOrHuman;
          [@metaloc loc]
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                  (
                    {

                      name: {
                        let value = (value: Raw.t_dogOrHuman_Dog).name;

                        value;
                      },

                      barkVolume: {
                        let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;

                        value;
                      },
                    }: t_dogOrHuman_Dog
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        },
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {

        dogOrHuman: {
          let value = (value: t).dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {

                  name: {
                    let value = (value: t_dogOrHuman_Dog).name;

                    value;
                  },

                  barkVolume: {
                    let value = (value: t_dogOrHuman_Dog).barkVolume;

                    value;
                  },
                }: Raw.t_dogOrHuman_Dog,
              ): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        },
      }: Raw.t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;
