// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Legacy argNamedQuery.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"argNamedQuery\\": int};
  };
  let query = \\"query ($query: String!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\";
  type t = {. \\"argNamedQuery\\": int};
  type t_variables = {. \\"query\\": string};
  let parse: Raw.t => t =
    value => {

      \\"argNamedQuery\\": {
        let value = value##argNamedQuery;

        value;
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|(\\"query\\", (a => Some(Js.Json.string(a)))(inp##query))|]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~query, ()) =>
    f(
      serializeVariables(
        {

          \\"query\\": query,
        }: t_variables,
      ),
    );
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Legacy comment.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"nonrecursiveInput\\": string};
  };
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"nonrecursiveInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    .
    \\"field\\": option(string),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  let parse: Raw.t => t =
    value => {

      \\"nonrecursiveInput\\": {
        let value = value##nonrecursiveInput;

        value;
      },
    };
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (a => Some(serializeInputObjectNonrecursiveInput(a)))(inp##arg),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Js.Json.t =
    inp =>
      [|
        (
          \\"field\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##field,
          ),
        ),
        (
          \\"enum\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      switch (a) {
                      | \`FIRST => Js.Json.string(\\"FIRST\\")
                      | \`SECOND => Js.Json.string(\\"SECOND\\")
                      | \`THIRD => Js.Json.string(\\"THIRD\\")
                      },
                    )
                )(
                  b,
                )
              }
          )(
            inp##enum,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    )
  and makeInputObjectNonrecursiveInput =
      (~field=?, ~enum=?, ()): t_variables_NonrecursiveInput => {

    \\"field\\": field,

    \\"enum\\": enum,
  };
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Legacy customDecoder.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module StringOfInt = {
  let parse = string_of_int;
  type t = string;
};
module IntOfString = {
  let parse = int_of_string;
  type t = int;
};

module MyQuery = {
  module Raw = {
    type t = {. \\"variousScalars\\": t_variousScalars}
    and t_variousScalars = {
      .
      \\"string\\": string,
      \\"int\\": int,
    };
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"variousScalars\\": t_variousScalars}
  and t_variousScalars = {
    .
    \\"string\\": IntOfString.t,
    \\"int\\": StringOfInt.t,
  };
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"string\\": {
            let value = value##string;

            IntOfString.parse(value);
          },

          \\"int\\": {
            let value = value##int;

            StringOfInt.parse(value);
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Legacy customScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"customScalarField\\": t_customScalarField}
    and t_customScalarField = {
      .
      \\"nullable\\": Js.Nullable.t(Js.Json.t),
      \\"nonNullable\\": Js.Json.t,
    };
  };
  let query = \\"query ($opt: CustomScalar, $req: CustomScalar!)  {\\\\ncustomScalarField(argOptional: $opt, argRequired: $req)  {\\\\nnullable  \\\\nnonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"customScalarField\\": t_customScalarField}
  and t_customScalarField = {
    .
    \\"nullable\\": option(Js.Json.t),
    \\"nonNullable\\": Js.Json.t,
  };
  type t_variables = {
    .
    \\"opt\\": option(Js.Json.t),
    \\"req\\": Js.Json.t,
  };
  let parse: Raw.t => t =
    value => {

      \\"customScalarField\\": {
        let value = value##customScalarField;
        {

          \\"nullable\\": {
            let value = value##nullable;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"nonNullable\\": {
            let value = value##nonNullable;

            value;
          },
        };
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"opt\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(a))(b)
              }
          )(
            inp##opt,
          ),
        ),
        (\\"req\\", (a => Some(a))(inp##req)),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~opt=?, ~req, ()) =>
    f(
      serializeVariables(
        {

          \\"opt\\": opt,

          \\"req\\": req,
        }: t_variables,
      ),
    );
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Legacy enumInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"enumInput\\": string};
  };
  let query = \\"query ($arg: SampleField!)  {\\\\nenumInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"enumInput\\": string};
  type t_variables = {. \\"arg\\": [ | \`FIRST | \`SECOND | \`THIRD]};
  let parse: Raw.t => t =
    value => {

      \\"enumInput\\": {
        let value = value##enumInput;

        value;
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (
            a =>
              Some(
                switch (a) {
                | \`FIRST => Js.Json.string(\\"FIRST\\")
                | \`SECOND => Js.Json.string(\\"SECOND\\")
                | \`THIRD => Js.Json.string(\\"THIRD\\")
                },
              )
          )(
            inp##arg,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    );
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Legacy explicit_object_record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module RecordsQuery = {
  module Raw = {
    type t = {lists: t_lists}
    and t_lists = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {lists: t_lists}
  and t_lists = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  let parse: Raw.t => t =
    (value) => (
      {

        lists: {
          let value = (value: Raw.t).lists;
          (
            {

              nullableOfNullable: {
                let value = (value: Raw.t_lists).nullableOfNullable;

                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              },

              nullableOfNonNullable: {
                let value = (value: Raw.t_lists).nullableOfNonNullable;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value |> Js.Array.map(value => value))
                | None => None
                };
              },

              nonNullableOfNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNullable;

                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   );
              },

              nonNullableOfNonNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNonNullable;

                value |> Js.Array.map(value => value);
              },
            }: t_lists
          );
        },
      }: t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};

module ObjectsQuery = {
  module Raw = {
    type t = {. \\"lists\\": t_lists}
    and t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"lists\\": t_lists}
  and t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  let parse: Raw.t => t =
    value => {

      \\"lists\\": {
        let value = value##lists;
        {

          \\"nullableOfNullable\\": {
            let value = value##nullableOfNullable;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some(
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   ),
              )
            | None => None
            };
          },

          \\"nullableOfNonNullable\\": {
            let value = value##nullableOfNonNullable;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value |> Js.Array.map(value => value))
            | None => None
            };
          },

          \\"nonNullableOfNullable\\": {
            let value = value##nonNullableOfNullable;

            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               );
          },

          \\"nonNullableOfNonNullable\\": {
            let value = value##nonNullableOfNonNullable;

            value |> Js.Array.map(value => value);
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Legacy fragmentDefinition.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];

module Fragments = {
  module ListFragment = {
    let query = \\"fragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        .
        \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
        \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      };
      type t_Lists = t;
    };
    type t = {
      .
      \\"nullableOfNullable\\": option(array(option(string))),
      \\"nullableOfNonNullable\\": option(array(string)),
    };
    type t_Lists = t;

    let parse = (value: Raw.t) => {

      \\"nullableOfNullable\\": {
        let value = value##nullableOfNullable;

        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      },

      \\"nullableOfNonNullable\\": {
        let value = value##nullableOfNonNullable;

        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      },
    };
    let name = \\"ListFragment\\";
  };
  module Another = {
    let query = \\"fragment Another on Lists   {\\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
    module Raw = {
      type t = {. \\"nullableOfNonNullable\\": Js.Nullable.t(array(string))};
      type t_Lists = t;
    };
    type t = {. \\"nullableOfNonNullable\\": option(array(string))};
    type t_Lists = t;

    let parse = (value: Raw.t) => {

      \\"nullableOfNonNullable\\": {
        let value = value##nullableOfNonNullable;

        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      },
    };
    let name = \\"Another\\";
  };
};

module MyQuery = {
  module Raw = {
    type t = {
      .
      \\"l1\\": Fragments.ListFragment.Raw.t,
      \\"l2\\": t_l2,
    }
    and t_l2 = Js.t({.});
  };
  let query =
    (
      (
        (
          (
            (
              (\\"query   {\\\\nl1: lists  {\\\\n...\\" ++ Fragments.ListFragment.name)
              ++ \\"   \\\\n}\\\\n\\\\nl2: lists  {\\\\n...\\"
            )
            ++ Fragments.ListFragment.name
          )
          ++ \\"   \\\\n...\\"
        )
        ++ Fragments.ListFragment.name
      )
      ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
    )
    ++ Fragments.ListFragment.query;
  type t = {
    .
    \\"l1\\": Fragments.ListFragment.t,
    \\"l2\\": t_l2,
  }
  and t_l2 = {
    .
    \\"frag1\\": Fragments.ListFragment.t_Lists,
    \\"frag2\\": Fragments.ListFragment.t_Lists,
  };
  let parse: Raw.t => t =
    value => {

      \\"l1\\": {
        let value = value##l1;

        Fragments.ListFragment.parse(value);
      },

      \\"l2\\": {
        let value = value##l2;
        {

          \\"frag1\\": {
            let value: Fragments.ListFragment.Raw.t = Obj.magic(value);

            Fragments.ListFragment.parse(value);
          },

          \\"frag2\\": {
            let value: Fragments.ListFragment.Raw.t = Obj.magic(value);

            Fragments.ListFragment.parse(value);
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Legacy interface.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
"
`;

exports[`Legacy lists.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"lists\\": t_lists}
    and t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"lists\\": t_lists}
  and t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  let parse: Raw.t => t =
    value => {

      \\"lists\\": {
        let value = value##lists;
        {

          \\"nullableOfNullable\\": {
            let value = value##nullableOfNullable;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some(
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   ),
              )
            | None => None
            };
          },

          \\"nullableOfNonNullable\\": {
            let value = value##nullableOfNonNullable;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value |> Js.Array.map(value => value))
            | None => None
            };
          },

          \\"nonNullableOfNullable\\": {
            let value = value##nonNullableOfNullable;

            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               );
          },

          \\"nonNullableOfNonNullable\\": {
            let value = value##nonNullableOfNonNullable;

            value |> Js.Array.map(value => value);
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Legacy listsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"listsInput\\": string};
  };
  let query = \\"query ($nullableOfNullable: [String], $nullableOfNonNullable: [String!], $nonNullableOfNullable: [String]!, $nonNullableOfNonNullable: [String!]!)  {\\\\nlistsInput(arg: {nullableOfNullable: $nullableOfNullable, nullableOfNonNullable: $nullableOfNonNullable, nonNullableOfNullable: $nonNullableOfNullable, nonNullableOfNonNullable: $nonNullableOfNonNullable})  \\\\n}\\\\n\\";
  type t = {. \\"listsInput\\": string};
  type t_variables = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  let parse: Raw.t => t =
    value => {

      \\"listsInput\\": {
        let value = value##listsInput;

        value;
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"nullableOfNullable\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      a
                      |> Array.map(b =>
                           switch (
                             (
                               a =>
                                 switch (a) {
                                 | None => None
                                 | Some(b) =>
                                   (a => Some(Js.Json.string(a)))(b)
                                 }
                             )(
                               b,
                             )
                           ) {
                           | Some(c) => c
                           | None => Js.Json.null
                           }
                         )
                      |> Js.Json.array,
                    )
                )(
                  b,
                )
              }
          )(
            inp##nullableOfNullable,
          ),
        ),
        (
          \\"nullableOfNonNullable\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      a
                      |> Array.map(b =>
                           switch ((a => Some(Js.Json.string(a)))(b)) {
                           | Some(c) => c
                           | None => Js.Json.null
                           }
                         )
                      |> Js.Json.array,
                    )
                )(
                  b,
                )
              }
          )(
            inp##nullableOfNonNullable,
          ),
        ),
        (
          \\"nonNullableOfNullable\\",
          (
            a =>
              Some(
                a
                |> Array.map(b =>
                     switch (
                       (
                         a =>
                           switch (a) {
                           | None => None
                           | Some(b) => (a => Some(Js.Json.string(a)))(b)
                           }
                       )(
                         b,
                       )
                     ) {
                     | Some(c) => c
                     | None => Js.Json.null
                     }
                   )
                |> Js.Json.array,
              )
          )(
            inp##nonNullableOfNullable,
          ),
        ),
        (
          \\"nonNullableOfNonNullable\\",
          (
            a =>
              Some(
                a
                |> Array.map(b =>
                     switch ((a => Some(Js.Json.string(a)))(b)) {
                     | Some(c) => c
                     | None => Js.Json.null
                     }
                   )
                |> Js.Json.array,
              )
          )(
            inp##nonNullableOfNonNullable,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar =
      (
        ~f,
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      ) =>
    f(
      serializeVariables(
        {

          \\"nullableOfNullable\\": nullableOfNullable,

          \\"nullableOfNonNullable\\": nullableOfNonNullable,

          \\"nonNullableOfNullable\\": nonNullableOfNullable,

          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        }: t_variables,
      ),
    );
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Legacy listsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"listsInput\\": string};
  };
  let query = \\"query ($arg: ListsInput!)  {\\\\nlistsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"listsInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_ListsInput}
  and t_variables_ListsInput = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  let parse: Raw.t => t =
    value => {

      \\"listsInput\\": {
        let value = value##listsInput;

        value;
      },
    };
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (\\"arg\\", (a => Some(serializeInputObjectListsInput(a)))(inp##arg)),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectListsInput: t_variables_ListsInput => Js.Json.t =
    inp =>
      [|
        (
          \\"nullableOfNullable\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      a
                      |> Array.map(b =>
                           switch (
                             (
                               a =>
                                 switch (a) {
                                 | None => None
                                 | Some(b) =>
                                   (a => Some(Js.Json.string(a)))(b)
                                 }
                             )(
                               b,
                             )
                           ) {
                           | Some(c) => c
                           | None => Js.Json.null
                           }
                         )
                      |> Js.Json.array,
                    )
                )(
                  b,
                )
              }
          )(
            inp##nullableOfNullable,
          ),
        ),
        (
          \\"nullableOfNonNullable\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      a
                      |> Array.map(b =>
                           switch ((a => Some(Js.Json.string(a)))(b)) {
                           | Some(c) => c
                           | None => Js.Json.null
                           }
                         )
                      |> Js.Json.array,
                    )
                )(
                  b,
                )
              }
          )(
            inp##nullableOfNonNullable,
          ),
        ),
        (
          \\"nonNullableOfNullable\\",
          (
            a =>
              Some(
                a
                |> Array.map(b =>
                     switch (
                       (
                         a =>
                           switch (a) {
                           | None => None
                           | Some(b) => (a => Some(Js.Json.string(a)))(b)
                           }
                       )(
                         b,
                       )
                     ) {
                     | Some(c) => c
                     | None => Js.Json.null
                     }
                   )
                |> Js.Json.array,
              )
          )(
            inp##nonNullableOfNullable,
          ),
        ),
        (
          \\"nonNullableOfNonNullable\\",
          (
            a =>
              Some(
                a
                |> Array.map(b =>
                     switch ((a => Some(Js.Json.string(a)))(b)) {
                     | Some(c) => c
                     | None => Js.Json.null
                     }
                   )
                |> Js.Json.array,
              )
          )(
            inp##nonNullableOfNonNullable,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    )
  and makeInputObjectListsInput =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      )
      : t_variables_ListsInput => {

    \\"nullableOfNullable\\": nullableOfNullable,

    \\"nullableOfNonNullable\\": nullableOfNonNullable,

    \\"nonNullableOfNullable\\": nonNullableOfNullable,

    \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
  };
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Legacy mutation.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"mutationWithError\\": t_mutationWithError}
    and t_mutationWithError = {
      .
      \\"value\\": Js.Nullable.t(t_mutationWithError_value),
      \\"errors\\": Js.Nullable.t(array(t_mutationWithError_errors)),
    }
    and t_mutationWithError_errors = {
      .
      \\"field\\": t_mutationWithError_errors_field,
      \\"message\\": string,
    }
    and t_mutationWithError_errors_field = string
    and t_mutationWithError_value = {. \\"stringField\\": string};
  };
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nvalue  {\\\\nstringField  \\\\n}\\\\n\\\\nerrors  {\\\\nfield  \\\\nmessage  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"mutationWithError\\": t_mutationWithError}
  and t_mutationWithError = {
    .
    \\"value\\": option(t_mutationWithError_value),
    \\"errors\\": option(array(t_mutationWithError_errors)),
  }
  and t_mutationWithError_errors = {
    .
    \\"field\\": t_mutationWithError_errors_field,
    \\"message\\": string,
  }
  and t_mutationWithError_errors_field = [
    | \`FutureAddedValue(string)
    | \`FIRST
    | \`SECOND
    | \`THIRD
  ]
  and t_mutationWithError_value = {. \\"stringField\\": string};
  let parse: Raw.t => t =
    value => {

      \\"mutationWithError\\": {
        let value = value##mutationWithError;
        {

          \\"value\\": {
            let value = value##value;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some({

                \\"stringField\\": {
                  let value = value##stringField;

                  value;
                },
              })
            | None => None
            };
          },

          \\"errors\\": {
            let value = value##errors;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some(
                value
                |> Js.Array.map(value =>
                     {

                       \\"field\\": {
                         let value = value##field;
                         switch (Obj.magic(value: string)) {
                         | \\"FIRST\\" => \`FIRST
                         | \\"SECOND\\" => \`SECOND
                         | \\"THIRD\\" => \`THIRD
                         | other => \`FutureAddedValue(other)
                         };
                       },

                       \\"message\\": {
                         let value = value##message;

                         value;
                       },
                     }
                   ),
              )
            | None => None
            };
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Legacy mutationWithArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"optionalInputArgs\\": string};
  };
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t = {. \\"optionalInputArgs\\": string};
  type t_variables = {. \\"required\\": string};
  let parse: Raw.t => t =
    value => {

      \\"optionalInputArgs\\": {
        let value = value##optionalInputArgs;

        value;
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|(\\"required\\", (a => Some(Js.Json.string(a)))(inp##required))|]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~required, ()) =>
    f(
      serializeVariables(
        {

          \\"required\\": required,
        }: t_variables,
      ),
    );
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Legacy nested.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type record = {
  f1: string,
  f2: string,
};

module MyQuery = {
  module Raw = {
    type t = {
      .
      \\"first\\": t_first,
      \\"second\\": t_second,
      \\"let_\\": t_let,
    }
    and t_let = {. \\"inner\\": Js.Nullable.t(t_let_inner)}
    and t_let_inner = {. \\"inner\\": Js.Nullable.t(t_let_inner_inner)}
    and t_let_inner_inner = {. \\"field\\": string}
    and t_second = {. \\"inner\\": Js.Nullable.t(t_second_inner)}
    and t_second_inner = {. \\"inner\\": Js.Nullable.t(t_second_inner_inner)}
    and t_second_inner_inner = {
      f1: string,
      f2: string,
    }
    and t_first = {. \\"inner\\": Js.Nullable.t(t_first_inner)}
    and t_first_inner = {. \\"inner\\": Js.Nullable.t(t_first_inner_inner)}
    and t_first_inner_inner = {. \\"field\\": string};
  };
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nsecond: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nf1: field  \\\\nf2: field  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nlet: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {
    .
    \\"first\\": t_first,
    \\"second\\": t_second,
    \\"let_\\": t_let,
  }
  and t_let = {. \\"inner\\": option(t_let_inner)}
  and t_let_inner = {. \\"inner\\": option(t_let_inner_inner)}
  and t_let_inner_inner = {. \\"field\\": string}
  and t_second = {. \\"inner\\": option(t_second_inner)}
  and t_second_inner = {. \\"inner\\": option(t_second_inner_inner)}
  and t_second_inner_inner = {
    f1: string,
    f2: string,
  }
  and t_first = {. \\"inner\\": option(t_first_inner)}
  and t_first_inner = {. \\"inner\\": option(t_first_inner_inner)}
  and t_first_inner_inner = {. \\"field\\": string};
  let parse: Raw.t => t =
    value => {

      \\"first\\": {
        let value = value##first;
        {

          \\"inner\\": {
            let value = value##inner;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some({

                \\"inner\\": {
                  let value = value##inner;

                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some({

                      \\"field\\": {
                        let value = value##field;

                        value;
                      },
                    })
                  | None => None
                  };
                },
              })
            | None => None
            };
          },
        };
      },

      \\"second\\": {
        let value = value##second;
        {

          \\"inner\\": {
            let value = value##inner;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some({

                \\"inner\\": {
                  let value = value##inner;

                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some({

                      \\"f1\\": {
                        let value = value##f1;

                        value;
                      },

                      \\"f2\\": {
                        let value = value##f2;

                        value;
                      },
                    })
                  | None => None
                  };
                },
              })
            | None => None
            };
          },
        };
      },

      \\"let_\\": {
        let value = value##let_;
        {

          \\"inner\\": {
            let value = value##inner;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some({

                \\"inner\\": {
                  let value = value##inner;

                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some({

                      \\"field\\": {
                        let value = value##field;

                        value;
                      },
                    })
                  | None => None
                  };
                },
              })
            | None => None
            };
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Legacy nonrecursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"nonrecursiveInput\\": string};
  };
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"nonrecursiveInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    .
    \\"field\\": option(string),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  let parse: Raw.t => t =
    value => {

      \\"nonrecursiveInput\\": {
        let value = value##nonrecursiveInput;

        value;
      },
    };
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (a => Some(serializeInputObjectNonrecursiveInput(a)))(inp##arg),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Js.Json.t =
    inp =>
      [|
        (
          \\"field\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##field,
          ),
        ),
        (
          \\"enum\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      switch (a) {
                      | \`FIRST => Js.Json.string(\\"FIRST\\")
                      | \`SECOND => Js.Json.string(\\"SECOND\\")
                      | \`THIRD => Js.Json.string(\\"THIRD\\")
                      },
                    )
                )(
                  b,
                )
              }
          )(
            inp##enum,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    )
  and makeInputObjectNonrecursiveInput =
      (~field=?, ~enum=?, ()): t_variables_NonrecursiveInput => {

    \\"field\\": field,

    \\"enum\\": enum,
  };
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Legacy pokedexApolloMode.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"pokemon\\": Js.Nullable.t(t_pokemon)}
    and t_pokemon = {
      .
      \\"id\\": string,
      \\"name\\": Js.Nullable.t(string),
    };
  };
  let query = \\"query   {\\\\npokemon(name: \\\\\\"Pikachu\\\\\\")  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"pokemon\\": option(t_pokemon)}
  and t_pokemon = {
    .
    \\"id\\": string,
    \\"name\\": option(string),
  };
  let parse: Raw.t => t =
    value => {

      \\"pokemon\\": {
        let value = value##pokemon;

        switch (Js.toOption(value)) {
        | Some(value) =>
          Some({

            \\"id\\": {
              let value = value##id;

              value;
            },

            \\"name\\": {
              let value = value##name;

              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
          })
        | None => None
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Legacy pokedexScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"pokemon\\": Js.Nullable.t(t_pokemon)}
    and t_pokemon = {
      .
      \\"id\\": string,
      \\"name\\": Js.Nullable.t(string),
    };
  };
  let query = \\"query pokemon($id: String, $name: String)  {\\\\npokemon(name: $name, id: $id)  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"pokemon\\": option(t_pokemon)}
  and t_pokemon = {
    .
    \\"id\\": string,
    \\"name\\": option(string),
  };
  type t_variables = {
    .
    \\"id\\": option(string),
    \\"name\\": option(string),
  };
  let parse: Raw.t => t =
    value => {

      \\"pokemon\\": {
        let value = value##pokemon;

        switch (Js.toOption(value)) {
        | Some(value) =>
          Some({

            \\"id\\": {
              let value = value##id;

              value;
            },

            \\"name\\": {
              let value = value##name;

              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
          })
        | None => None
        };
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"id\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##id,
          ),
        ),
        (
          \\"name\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##name,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~id=?, ~name=?, ()) =>
    f(
      serializeVariables(
        {

          \\"id\\": id,

          \\"name\\": name,
        }: t_variables,
      ),
    );
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Legacy record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type scalars = {
  string,
  int,
};

type dog = {
  name: string,
  barkVolume: float,
};

type oneFieldQuery = {nullableString: option(string)};

module MyQuery = {
  module Raw = {
    type t = {. \\"variousScalars\\": scalars};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"variousScalars\\": scalars};
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"int\\": {
            let value = value##int;

            value;
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};

module OneFieldQuery = {
  module Raw = {
    type t = {. \\"variousScalars\\": t_variousScalars}
    and t_variousScalars = {nullableString: Js.Nullable.t(string)};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"variousScalars\\": t_variousScalars}
  and t_variousScalars = {nullableString: option(string)};
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};

module ExternalFragmentQuery = {
  module Fragment = {
    let query = \\"fragment Fragment on VariousScalars   {\\\\nstring  \\\\nint  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        string,
        int,
      };
      type t_VariousScalars = t;
    };
    type t = {
      string,
      int,
    };
    type t_VariousScalars = t;

    let parse = (value: Raw.t) => {

      \\"string\\": {
        let value = value##string;

        value;
      },

      \\"int\\": {
        let value = value##int;

        value;
      },
    };
    let name = \\"Fragment\\";
  };
  module Untitled1 = {
    module Raw = {
      type t = {. \\"variousScalars\\": Fragment.Raw.t};
    };
    let query =
      (
        (\\"query   {\\\\nvariousScalars  {\\\\n...\\" ++ Fragment.name)
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ Fragment.query;
    type t = {. \\"variousScalars\\": Fragment.t};
    let parse: Raw.t => t =
      value => {

        \\"variousScalars\\": {
          let value = value##variousScalars;

          Fragment.parse(value);
        },
      };
    let makeVar = (~f, ()) => f(Js.Json.null);
    let make =
      makeVar(~f=variables =>
        {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
      );
    let makeWithVariables = variables => {
      \\"query\\": query,
      \\"variables\\": serializeVariables(variables),
      \\"parse\\": parse,
    };
    let definition = (parse, query, makeVar);
  };
};

module InlineFragmentQuery = {
  module Raw = {
    type t = {. \\"dogOrHuman\\": t_dogOrHuman}
    and t_dogOrHuman
    and t_dogOrHuman_Dog = {
      name: string,
      barkVolume: float,
    };
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"dogOrHuman\\": t_dogOrHuman}
  and t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ]
  and t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  let parse: Raw.t => t =
    value => {

      \\"dogOrHuman\\": {
        let value = value##dogOrHuman;

        switch (Js.Json.decodeObject(Obj.magic(value): Js.Json.t)) {

        | None =>
          Js.Exn.raiseError(
            \\"graphql_ppx: \\"
            ++ \\"Expected union \\"
            ++ \\"DogOrHuman\\"
            ++ \\" to be an object, got \\"
            ++ Js.Json.stringify(Obj.magic(value): Js.Json.t),
          )

        | Some(typename_obj) =>
          switch (Js.Dict.get(typename_obj, \\"__typename\\")) {

          | None =>
            Js.Exn.raiseError(
              \\"graphql_ppx: \\"
              ++ \\"Union \\"
              ++ \\"DogOrHuman\\"
              ++ \\" is missing the __typename field\\",
            )

          | Some(typename) =>
            switch (Js.Json.decodeString(typename)) {

            | None =>
              Js.Exn.raiseError(
                \\"graphql_ppx: \\"
                ++ \\"Union \\"
                ++ \\"DogOrHuman\\"
                ++ \\" has a __typename field that is not a string\\",
              )

            | Some(typename) =>
              switch (typename) {
              | \\"Dog\\" =>
                \`Dog(
                  {
                    let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                    {

                      \\"name\\": {
                        let value = value##name;

                        value;
                      },

                      \\"barkVolume\\": {
                        let value = value##barkVolume;

                        value;
                      },
                    };
                  },
                )
              | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
              }
            }
          }
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};

module UnionExternalFragmentQuery = {
  module DogFragment = {
    let query = \\"fragment DogFragment on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        name: string,
        barkVolume: float,
      };
      type t_Dog = t;
    };
    type t = {
      name: string,
      barkVolume: float,
    };
    type t_Dog = t;

    let parse = (value: Raw.t) => {

      \\"name\\": {
        let value = value##name;

        value;
      },

      \\"barkVolume\\": {
        let value = value##barkVolume;

        value;
      },
    };
    let name = \\"DogFragment\\";
  };
  module Untitled1 = {
    module Raw = {
      type t = {. \\"dogOrHuman\\": t_dogOrHuman}
      and t_dogOrHuman;
    };
    let query =
      (
        (
          \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n...\\"
          ++ DogFragment.name
        )
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ DogFragment.query;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman}
    and t_dogOrHuman = [
      | \`FutureAddedValue(Js.Json.t)
      | \`Dog(DogFragment.t)
    ];
    let parse: Raw.t => t =
      value => {

        \\"dogOrHuman\\": {
          let value = value##dogOrHuman;

          switch (Js.Json.decodeObject(Obj.magic(value): Js.Json.t)) {

          | None =>
            Js.Exn.raiseError(
              \\"graphql_ppx: \\"
              ++ \\"Expected union \\"
              ++ \\"DogOrHuman\\"
              ++ \\" to be an object, got \\"
              ++ Js.Json.stringify(Obj.magic(value): Js.Json.t),
            )

          | Some(typename_obj) =>
            switch (Js.Dict.get(typename_obj, \\"__typename\\")) {

            | None =>
              Js.Exn.raiseError(
                \\"graphql_ppx: \\"
                ++ \\"Union \\"
                ++ \\"DogOrHuman\\"
                ++ \\" is missing the __typename field\\",
              )

            | Some(typename) =>
              switch (Js.Json.decodeString(typename)) {

              | None =>
                Js.Exn.raiseError(
                  \\"graphql_ppx: \\"
                  ++ \\"Union \\"
                  ++ \\"DogOrHuman\\"
                  ++ \\" has a __typename field that is not a string\\",
                )

              | Some(typename) =>
                switch (typename) {
                | \\"Dog\\" =>
                  \`Dog(
                    {
                      let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);

                      DogFragment.parse(value);
                    },
                  )
                | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
                }
              }
            }
          };
        },
      };
    let makeVar = (~f, ()) => f(Js.Json.null);
    let make =
      makeVar(~f=variables =>
        {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
      );
    let makeWithVariables = variables => {
      \\"query\\": query,
      \\"variables\\": serializeVariables(variables),
      \\"parse\\": parse,
    };
    let definition = (parse, query, makeVar);
  };
};
"
`;

exports[`Legacy recursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"recursiveInput\\": string};
  };
  let query = \\"query ($arg: RecursiveInput!)  {\\\\nrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"recursiveInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_RecursiveInput}
  and t_variables_RecursiveInput = {
    .
    \\"otherField\\": option(string),
    \\"inner\\": option(t_variables_RecursiveInput),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  let parse: Raw.t => t =
    value => {

      \\"recursiveInput\\": {
        let value = value##recursiveInput;

        value;
      },
    };
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (a => Some(serializeInputObjectRecursiveInput(a)))(inp##arg),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectRecursiveInput:
    t_variables_RecursiveInput => Js.Json.t =
    inp =>
      [|
        (
          \\"otherField\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##otherField,
          ),
        ),
        (
          \\"inner\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (a => Some(serializeInputObjectRecursiveInput(a)))(b)
              }
          )(
            inp##inner,
          ),
        ),
        (
          \\"enum\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      switch (a) {
                      | \`FIRST => Js.Json.string(\\"FIRST\\")
                      | \`SECOND => Js.Json.string(\\"SECOND\\")
                      | \`THIRD => Js.Json.string(\\"THIRD\\")
                      },
                    )
                )(
                  b,
                )
              }
          )(
            inp##enum,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    )
  and makeInputObjectRecursiveInput =
      (~otherField=?, ~inner=?, ~enum=?, ()): t_variables_RecursiveInput => {

    \\"otherField\\": otherField,

    \\"inner\\": inner,

    \\"enum\\": enum,
  };
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Legacy scalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"variousScalars\\": t_variousScalars}
    and t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"variousScalars\\": t_variousScalars}
  and t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Legacy scalarsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"scalarsInput\\": string};
  };
  let query = \\"query ($nullableString: String, $string: String!, $nullableInt: Int, $int: Int!, $nullableFloat: Float, $float: Float!, $nullableBoolean: Boolean, $boolean: Boolean!, $nullableID: ID, $id: ID!)  {\\\\nscalarsInput(arg: {nullableString: $nullableString, string: $string, nullableInt: $nullableInt, int: $int, nullableFloat: $nullableFloat, float: $float, nullableBoolean: $nullableBoolean, boolean: $boolean, nullableID: $nullableID, id: $id})  \\\\n}\\\\n\\";
  type t = {. \\"scalarsInput\\": string};
  type t_variables = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"scalarsInput\\": {
        let value = value##scalarsInput;

        value;
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"nullableString\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##nullableString,
          ),
        ),
        (\\"string\\", (a => Some(Js.Json.string(a)))(inp##string)),
        (
          \\"nullableInt\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.number(float_of_int(a))))(b)
              }
          )(
            inp##nullableInt,
          ),
        ),
        (\\"int\\", (a => Some(Js.Json.number(float_of_int(a))))(inp##int)),
        (
          \\"nullableFloat\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.number(a)))(b)
              }
          )(
            inp##nullableFloat,
          ),
        ),
        (\\"float\\", (a => Some(Js.Json.number(a)))(inp##float)),
        (
          \\"nullableBoolean\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.boolean(a)))(b)
              }
          )(
            inp##nullableBoolean,
          ),
        ),
        (\\"boolean\\", (a => Some(Js.Json.boolean(a)))(inp##boolean)),
        (
          \\"nullableID\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##nullableID,
          ),
        ),
        (\\"id\\", (a => Some(Js.Json.string(a)))(inp##id)),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar =
      (
        ~f,
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      ) =>
    f(
      serializeVariables(
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,

          \\"nullableInt\\": nullableInt,

          \\"int\\": int,

          \\"nullableFloat\\": nullableFloat,

          \\"float\\": float,

          \\"nullableBoolean\\": nullableBoolean,

          \\"boolean\\": boolean,

          \\"nullableID\\": nullableID,

          \\"id\\": id,
        }: t_variables,
      ),
    );
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Legacy scalarsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"scalarsInput\\": string};
  };
  let query = \\"query ($arg: VariousScalarsInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"scalarsInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_VariousScalarsInput}
  and t_variables_VariousScalarsInput = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"scalarsInput\\": {
        let value = value##scalarsInput;

        value;
      },
    };
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (a => Some(serializeInputObjectVariousScalarsInput(a)))(inp##arg),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectVariousScalarsInput:
    t_variables_VariousScalarsInput => Js.Json.t =
    inp =>
      [|
        (
          \\"nullableString\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##nullableString,
          ),
        ),
        (\\"string\\", (a => Some(Js.Json.string(a)))(inp##string)),
        (
          \\"nullableInt\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.number(float_of_int(a))))(b)
              }
          )(
            inp##nullableInt,
          ),
        ),
        (\\"int\\", (a => Some(Js.Json.number(float_of_int(a))))(inp##int)),
        (
          \\"nullableFloat\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.number(a)))(b)
              }
          )(
            inp##nullableFloat,
          ),
        ),
        (\\"float\\", (a => Some(Js.Json.number(a)))(inp##float)),
        (
          \\"nullableBoolean\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.boolean(a)))(b)
              }
          )(
            inp##nullableBoolean,
          ),
        ),
        (\\"boolean\\", (a => Some(Js.Json.boolean(a)))(inp##boolean)),
        (
          \\"nullableID\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##nullableID,
          ),
        ),
        (\\"id\\", (a => Some(Js.Json.string(a)))(inp##id)),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    )
  and makeInputObjectVariousScalarsInput =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      )
      : t_variables_VariousScalarsInput => {

    \\"nullableString\\": nullableString,

    \\"string\\": string,

    \\"nullableInt\\": nullableInt,

    \\"int\\": int,

    \\"nullableFloat\\": nullableFloat,

    \\"float\\": float,

    \\"nullableBoolean\\": nullableBoolean,

    \\"boolean\\": boolean,

    \\"nullableID\\": nullableID,

    \\"id\\": id,
  };
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Legacy skipDirectives.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {
      .
      \\"v1\\": t_v1,
      \\"v2\\": t_v2,
    }
    and t_v2 = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": Js.Nullable.t(string),
    }
    and t_v1 = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": Js.Nullable.t(string),
    };
  };
  let query = \\"query ($var: Boolean!)  {\\\\nv1: variousScalars  {\\\\nnullableString @skip(if: $var) \\\\nstring @skip(if: $var) \\\\n}\\\\n\\\\nv2: variousScalars  {\\\\nnullableString @include(if: $var) \\\\nstring @include(if: $var) \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {
    .
    \\"v1\\": t_v1,
    \\"v2\\": t_v2,
  }
  and t_v2 = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": option(string),
  }
  and t_v1 = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": option(string),
  };
  type t_variables = {. \\"var\\": bool};
  let parse: Raw.t => t =
    value => {

      \\"v1\\": {
        let value = value##v1;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"string\\": {
            let value = value##string;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },
        };
      },

      \\"v2\\": {
        let value = value##v2;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"string\\": {
            let value = value##string;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },
        };
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|(\\"var\\", (a => Some(Js.Json.boolean(a)))(inp##var))|]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~var, ()) =>
    f(
      serializeVariables(
        {

          \\"var\\": var,
        }: t_variables,
      ),
    );
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Legacy subscription.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"simpleSubscription\\": t_simpleSubscription}
    and t_simpleSubscription
    and t_simpleSubscription_Human = {. \\"name\\": string}
    and t_simpleSubscription_Dog = {. \\"name\\": string};
  };
  let query = \\"subscription   {\\\\nsimpleSubscription  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"simpleSubscription\\": t_simpleSubscription}
  and t_simpleSubscription = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_simpleSubscription_Dog)
    | \`Human(t_simpleSubscription_Human)
  ]
  and t_simpleSubscription_Human = {. \\"name\\": string}
  and t_simpleSubscription_Dog = {. \\"name\\": string};
  let parse: Raw.t => t =
    value => {

      \\"simpleSubscription\\": {
        let value = value##simpleSubscription;

        switch (Js.Json.decodeObject(Obj.magic(value): Js.Json.t)) {

        | None =>
          Js.Exn.raiseError(
            \\"graphql_ppx: \\"
            ++ \\"Expected union \\"
            ++ \\"DogOrHuman\\"
            ++ \\" to be an object, got \\"
            ++ Js.Json.stringify(Obj.magic(value): Js.Json.t),
          )

        | Some(typename_obj) =>
          switch (Js.Dict.get(typename_obj, \\"__typename\\")) {

          | None =>
            Js.Exn.raiseError(
              \\"graphql_ppx: \\"
              ++ \\"Union \\"
              ++ \\"DogOrHuman\\"
              ++ \\" is missing the __typename field\\",
            )

          | Some(typename) =>
            switch (Js.Json.decodeString(typename)) {

            | None =>
              Js.Exn.raiseError(
                \\"graphql_ppx: \\"
                ++ \\"Union \\"
                ++ \\"DogOrHuman\\"
                ++ \\" has a __typename field that is not a string\\",
              )

            | Some(typename) =>
              switch (typename) {
              | \\"Dog\\" =>
                \`Dog(
                  {
                    let value: Raw.t_simpleSubscription_Dog = Obj.magic(value);
                    {

                      \\"name\\": {
                        let value = value##name;

                        value;
                      },
                    };
                  },
                )
              | \\"Human\\" =>
                \`Human(
                  {
                    let value: Raw.t_simpleSubscription_Human =
                      Obj.magic(value);
                    {

                      \\"name\\": {
                        let value = value##name;

                        value;
                      },
                    };
                  },
                )
              | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
              }
            }
          }
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Legacy tagged_template.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"variousScalars\\": t_variousScalars}
    and t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"variousScalars\\": t_variousScalars}
  and t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};

module MyQuery2 = {
  module Raw = {
    type t = {. \\"variousScalars\\": t_variousScalars}
    and t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  %raw
  \\"let { graphql } = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t = {. \\"variousScalars\\": t_variousScalars}
  and t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};

module MyQuery3 = {
  module Raw = {
    type t = {. \\"variousScalars\\": t_variousScalars}
    and t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  %raw
  \\"let { graphql } = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t = {. \\"variousScalars\\": t_variousScalars}
  and t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};

module MyQuery4 = {
  module Raw = {
    type t = {. \\"variousScalars\\": t_variousScalars}
    and t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  %raw
  \\"let graphql = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t = {. \\"variousScalars\\": t_variousScalars}
  and t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Legacy typename.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"first\\": t_first}
    and t_first = {
      .
      \\"__typename\\": string,
      \\"inner\\": Js.Nullable.t(t_first_inner),
    }
    and t_first_inner = {
      .
      \\"__typename\\": string,
      \\"inner\\": Js.Nullable.t(t_first_inner_inner),
    }
    and t_first_inner_inner = {
      .
      \\"__typename\\": string,
      \\"field\\": string,
    };
  };
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"first\\": t_first}
  and t_first = {
    .
    \\"__typename\\": string,
    \\"inner\\": option(t_first_inner),
  }
  and t_first_inner = {
    .
    \\"__typename\\": string,
    \\"inner\\": option(t_first_inner_inner),
  }
  and t_first_inner_inner = {
    .
    \\"__typename\\": string,
    \\"field\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"first\\": {
        let value = value##first;
        {

          \\"__typename\\": {
            let value = value##__typename;

            value;
          },

          \\"inner\\": {
            let value = value##inner;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some({

                \\"__typename\\": {
                  let value = value##__typename;

                  value;
                },

                \\"inner\\": {
                  let value = value##inner;

                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some({

                      \\"__typename\\": {
                        let value = value##__typename;

                        value;
                      },

                      \\"field\\": {
                        let value = value##field;

                        value;
                      },
                    })
                  | None => None
                  };
                },
              })
            | None => None
            };
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Legacy union.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"dogOrHuman\\": t_dogOrHuman}
    and t_dogOrHuman
    and t_dogOrHuman_Human = {. \\"name\\": string}
    and t_dogOrHuman_Dog = {
      .
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"dogOrHuman\\": t_dogOrHuman}
  and t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ]
  and t_dogOrHuman_Human = {. \\"name\\": string}
  and t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  let parse: Raw.t => t =
    value => {

      \\"dogOrHuman\\": {
        let value = value##dogOrHuman;

        switch (Js.Json.decodeObject(Obj.magic(value): Js.Json.t)) {

        | None =>
          Js.Exn.raiseError(
            \\"graphql_ppx: \\"
            ++ \\"Expected union \\"
            ++ \\"DogOrHuman\\"
            ++ \\" to be an object, got \\"
            ++ Js.Json.stringify(Obj.magic(value): Js.Json.t),
          )

        | Some(typename_obj) =>
          switch (Js.Dict.get(typename_obj, \\"__typename\\")) {

          | None =>
            Js.Exn.raiseError(
              \\"graphql_ppx: \\"
              ++ \\"Union \\"
              ++ \\"DogOrHuman\\"
              ++ \\" is missing the __typename field\\",
            )

          | Some(typename) =>
            switch (Js.Json.decodeString(typename)) {

            | None =>
              Js.Exn.raiseError(
                \\"graphql_ppx: \\"
                ++ \\"Union \\"
                ++ \\"DogOrHuman\\"
                ++ \\" has a __typename field that is not a string\\",
              )

            | Some(typename) =>
              switch (typename) {
              | \\"Dog\\" =>
                \`Dog(
                  {
                    let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                    {

                      \\"name\\": {
                        let value = value##name;

                        value;
                      },

                      \\"barkVolume\\": {
                        let value = value##barkVolume;

                        value;
                      },
                    };
                  },
                )
              | \\"Human\\" =>
                \`Human(
                  {
                    let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                    {

                      \\"name\\": {
                        let value = value##name;

                        value;
                      },
                    };
                  },
                )
              | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
              }
            }
          }
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Legacy unionPartial.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"dogOrHuman\\": t_dogOrHuman}
    and t_dogOrHuman
    and t_dogOrHuman_Dog = {
      .
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"dogOrHuman\\": t_dogOrHuman}
  and t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ]
  and t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  let parse: Raw.t => t =
    value => {

      \\"dogOrHuman\\": {
        let value = value##dogOrHuman;

        switch (Js.Json.decodeObject(Obj.magic(value): Js.Json.t)) {

        | None =>
          Js.Exn.raiseError(
            \\"graphql_ppx: \\"
            ++ \\"Expected union \\"
            ++ \\"DogOrHuman\\"
            ++ \\" to be an object, got \\"
            ++ Js.Json.stringify(Obj.magic(value): Js.Json.t),
          )

        | Some(typename_obj) =>
          switch (Js.Dict.get(typename_obj, \\"__typename\\")) {

          | None =>
            Js.Exn.raiseError(
              \\"graphql_ppx: \\"
              ++ \\"Union \\"
              ++ \\"DogOrHuman\\"
              ++ \\" is missing the __typename field\\",
            )

          | Some(typename) =>
            switch (Js.Json.decodeString(typename)) {

            | None =>
              Js.Exn.raiseError(
                \\"graphql_ppx: \\"
                ++ \\"Union \\"
                ++ \\"DogOrHuman\\"
                ++ \\" has a __typename field that is not a string\\",
              )

            | Some(typename) =>
              switch (typename) {
              | \\"Dog\\" =>
                \`Dog(
                  {
                    let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                    {

                      \\"name\\": {
                        let value = value##name;

                        value;
                      },

                      \\"barkVolume\\": {
                        let value = value##barkVolume;

                        value;
                      },
                    };
                  },
                )
              | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
              }
            }
          }
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let make =
    makeVar(~f=variables =>
      {\\"query\\": query, \\"variables\\": variables, \\"parse\\": parse}
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Objects argNamedQuery.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"argNamedQuery\\": int};
  };
  let query = \\"query ($query: String!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\";
  type t = {. \\"argNamedQuery\\": int};
  type t_variables = {. \\"query\\": string};
  let parse: Raw.t => t =
    value => {

      \\"argNamedQuery\\": {
        let value = value##argNamedQuery;

        value;
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|(\\"query\\", (a => Some(Js.Json.string(a)))(inp##query))|]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~query, ()) =>
    f(
      serializeVariables(
        {

          \\"query\\": query,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Objects comment.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"nonrecursiveInput\\": string};
  };
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"nonrecursiveInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    .
    \\"field\\": option(string),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  let parse: Raw.t => t =
    value => {

      \\"nonrecursiveInput\\": {
        let value = value##nonrecursiveInput;

        value;
      },
    };
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (a => Some(serializeInputObjectNonrecursiveInput(a)))(inp##arg),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Js.Json.t =
    inp =>
      [|
        (
          \\"field\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##field,
          ),
        ),
        (
          \\"enum\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      switch (a) {
                      | \`FIRST => Js.Json.string(\\"FIRST\\")
                      | \`SECOND => Js.Json.string(\\"SECOND\\")
                      | \`THIRD => Js.Json.string(\\"THIRD\\")
                      },
                    )
                )(
                  b,
                )
              }
          )(
            inp##enum,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    )
  and makeInputObjectNonrecursiveInput =
      (~field=?, ~enum=?, ()): t_variables_NonrecursiveInput => {

    \\"field\\": field,

    \\"enum\\": enum,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Objects customDecoder.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module StringOfInt = {
  let parse = string_of_int;
  type t = string;
};
module IntOfString = {
  let parse = int_of_string;
  type t = int;
};

module MyQuery = {
  module Raw = {
    type t = {. \\"variousScalars\\": t_variousScalars}
    and t_variousScalars = {
      .
      \\"string\\": string,
      \\"int\\": int,
    };
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"variousScalars\\": t_variousScalars}
  and t_variousScalars = {
    .
    \\"string\\": IntOfString.t,
    \\"int\\": StringOfInt.t,
  };
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"string\\": {
            let value = value##string;

            IntOfString.parse(value);
          },

          \\"int\\": {
            let value = value##int;

            StringOfInt.parse(value);
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Objects customScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"customScalarField\\": t_customScalarField}
    and t_customScalarField = {
      .
      \\"nullable\\": Js.Nullable.t(Js.Json.t),
      \\"nonNullable\\": Js.Json.t,
    };
  };
  let query = \\"query ($opt: CustomScalar, $req: CustomScalar!)  {\\\\ncustomScalarField(argOptional: $opt, argRequired: $req)  {\\\\nnullable  \\\\nnonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"customScalarField\\": t_customScalarField}
  and t_customScalarField = {
    .
    \\"nullable\\": option(Js.Json.t),
    \\"nonNullable\\": Js.Json.t,
  };
  type t_variables = {
    .
    \\"opt\\": option(Js.Json.t),
    \\"req\\": Js.Json.t,
  };
  let parse: Raw.t => t =
    value => {

      \\"customScalarField\\": {
        let value = value##customScalarField;
        {

          \\"nullable\\": {
            let value = value##nullable;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"nonNullable\\": {
            let value = value##nonNullable;

            value;
          },
        };
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"opt\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(a))(b)
              }
          )(
            inp##opt,
          ),
        ),
        (\\"req\\", (a => Some(a))(inp##req)),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~opt=?, ~req, ()) =>
    f(
      serializeVariables(
        {

          \\"opt\\": opt,

          \\"req\\": req,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Objects enumInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"enumInput\\": string};
  };
  let query = \\"query ($arg: SampleField!)  {\\\\nenumInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"enumInput\\": string};
  type t_variables = {. \\"arg\\": [ | \`FIRST | \`SECOND | \`THIRD]};
  let parse: Raw.t => t =
    value => {

      \\"enumInput\\": {
        let value = value##enumInput;

        value;
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (
            a =>
              Some(
                switch (a) {
                | \`FIRST => Js.Json.string(\\"FIRST\\")
                | \`SECOND => Js.Json.string(\\"SECOND\\")
                | \`THIRD => Js.Json.string(\\"THIRD\\")
                },
              )
          )(
            inp##arg,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Objects explicit_object_record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module RecordsQuery = {
  module Raw = {
    type t = {lists: t_lists}
    and t_lists = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {lists: t_lists}
  and t_lists = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  let parse: Raw.t => t =
    (value) => (
      {

        lists: {
          let value = (value: Raw.t).lists;
          (
            {

              nullableOfNullable: {
                let value = (value: Raw.t_lists).nullableOfNullable;

                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              },

              nullableOfNonNullable: {
                let value = (value: Raw.t_lists).nullableOfNonNullable;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value |> Js.Array.map(value => value))
                | None => None
                };
              },

              nonNullableOfNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNullable;

                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   );
              },

              nonNullableOfNonNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNonNullable;

                value |> Js.Array.map(value => value);
              },
            }: t_lists
          );
        },
      }: t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};

module ObjectsQuery = {
  module Raw = {
    type t = {. \\"lists\\": t_lists}
    and t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"lists\\": t_lists}
  and t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  let parse: Raw.t => t =
    value => {

      \\"lists\\": {
        let value = value##lists;
        {

          \\"nullableOfNullable\\": {
            let value = value##nullableOfNullable;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some(
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   ),
              )
            | None => None
            };
          },

          \\"nullableOfNonNullable\\": {
            let value = value##nullableOfNonNullable;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value |> Js.Array.map(value => value))
            | None => None
            };
          },

          \\"nonNullableOfNullable\\": {
            let value = value##nonNullableOfNullable;

            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               );
          },

          \\"nonNullableOfNonNullable\\": {
            let value = value##nonNullableOfNonNullable;

            value |> Js.Array.map(value => value);
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Objects fragmentDefinition.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];

module Fragments = {
  module ListFragment = {
    let query = \\"fragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        .
        \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
        \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      };
      type t_Lists = t;
    };
    type t = {
      .
      \\"nullableOfNullable\\": option(array(option(string))),
      \\"nullableOfNonNullable\\": option(array(string)),
    };
    type t_Lists = t;

    let parse = (value: Raw.t) => {

      \\"nullableOfNullable\\": {
        let value = value##nullableOfNullable;

        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      },

      \\"nullableOfNonNullable\\": {
        let value = value##nullableOfNonNullable;

        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      },
    };
    let name = \\"ListFragment\\";
  };
  module Another = {
    let query = \\"fragment Another on Lists   {\\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
    module Raw = {
      type t = {. \\"nullableOfNonNullable\\": Js.Nullable.t(array(string))};
      type t_Lists = t;
    };
    type t = {. \\"nullableOfNonNullable\\": option(array(string))};
    type t_Lists = t;

    let parse = (value: Raw.t) => {

      \\"nullableOfNonNullable\\": {
        let value = value##nullableOfNonNullable;

        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      },
    };
    let name = \\"Another\\";
  };
};

module MyQuery = {
  module Raw = {
    type t = {
      .
      \\"l1\\": Fragments.ListFragment.Raw.t,
      \\"l2\\": t_l2,
    }
    and t_l2 = Js.t({.});
  };
  let query =
    (
      (
        (
          (
            (
              (\\"query   {\\\\nl1: lists  {\\\\n...\\" ++ Fragments.ListFragment.name)
              ++ \\"   \\\\n}\\\\n\\\\nl2: lists  {\\\\n...\\"
            )
            ++ Fragments.ListFragment.name
          )
          ++ \\"   \\\\n...\\"
        )
        ++ Fragments.ListFragment.name
      )
      ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
    )
    ++ Fragments.ListFragment.query;
  type t = {
    .
    \\"l1\\": Fragments.ListFragment.t,
    \\"l2\\": t_l2,
  }
  and t_l2 = {
    .
    \\"frag1\\": Fragments.ListFragment.t_Lists,
    \\"frag2\\": Fragments.ListFragment.t_Lists,
  };
  let parse: Raw.t => t =
    value => {

      \\"l1\\": {
        let value = value##l1;

        Fragments.ListFragment.parse(value);
      },

      \\"l2\\": {
        let value = value##l2;
        {

          \\"frag1\\": {
            let value: Fragments.ListFragment.Raw.t = Obj.magic(value);

            Fragments.ListFragment.parse(value);
          },

          \\"frag2\\": {
            let value: Fragments.ListFragment.Raw.t = Obj.magic(value);

            Fragments.ListFragment.parse(value);
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Objects interface.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
"
`;

exports[`Objects lists.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"lists\\": t_lists}
    and t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"lists\\": t_lists}
  and t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  let parse: Raw.t => t =
    value => {

      \\"lists\\": {
        let value = value##lists;
        {

          \\"nullableOfNullable\\": {
            let value = value##nullableOfNullable;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some(
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   ),
              )
            | None => None
            };
          },

          \\"nullableOfNonNullable\\": {
            let value = value##nullableOfNonNullable;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value |> Js.Array.map(value => value))
            | None => None
            };
          },

          \\"nonNullableOfNullable\\": {
            let value = value##nonNullableOfNullable;

            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               );
          },

          \\"nonNullableOfNonNullable\\": {
            let value = value##nonNullableOfNonNullable;

            value |> Js.Array.map(value => value);
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Objects listsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"listsInput\\": string};
  };
  let query = \\"query ($nullableOfNullable: [String], $nullableOfNonNullable: [String!], $nonNullableOfNullable: [String]!, $nonNullableOfNonNullable: [String!]!)  {\\\\nlistsInput(arg: {nullableOfNullable: $nullableOfNullable, nullableOfNonNullable: $nullableOfNonNullable, nonNullableOfNullable: $nonNullableOfNullable, nonNullableOfNonNullable: $nonNullableOfNonNullable})  \\\\n}\\\\n\\";
  type t = {. \\"listsInput\\": string};
  type t_variables = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  let parse: Raw.t => t =
    value => {

      \\"listsInput\\": {
        let value = value##listsInput;

        value;
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"nullableOfNullable\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      a
                      |> Array.map(b =>
                           switch (
                             (
                               a =>
                                 switch (a) {
                                 | None => None
                                 | Some(b) =>
                                   (a => Some(Js.Json.string(a)))(b)
                                 }
                             )(
                               b,
                             )
                           ) {
                           | Some(c) => c
                           | None => Js.Json.null
                           }
                         )
                      |> Js.Json.array,
                    )
                )(
                  b,
                )
              }
          )(
            inp##nullableOfNullable,
          ),
        ),
        (
          \\"nullableOfNonNullable\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      a
                      |> Array.map(b =>
                           switch ((a => Some(Js.Json.string(a)))(b)) {
                           | Some(c) => c
                           | None => Js.Json.null
                           }
                         )
                      |> Js.Json.array,
                    )
                )(
                  b,
                )
              }
          )(
            inp##nullableOfNonNullable,
          ),
        ),
        (
          \\"nonNullableOfNullable\\",
          (
            a =>
              Some(
                a
                |> Array.map(b =>
                     switch (
                       (
                         a =>
                           switch (a) {
                           | None => None
                           | Some(b) => (a => Some(Js.Json.string(a)))(b)
                           }
                       )(
                         b,
                       )
                     ) {
                     | Some(c) => c
                     | None => Js.Json.null
                     }
                   )
                |> Js.Json.array,
              )
          )(
            inp##nonNullableOfNullable,
          ),
        ),
        (
          \\"nonNullableOfNonNullable\\",
          (
            a =>
              Some(
                a
                |> Array.map(b =>
                     switch ((a => Some(Js.Json.string(a)))(b)) {
                     | Some(c) => c
                     | None => Js.Json.null
                     }
                   )
                |> Js.Json.array,
              )
          )(
            inp##nonNullableOfNonNullable,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar =
      (
        ~f,
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      ) =>
    f(
      serializeVariables(
        {

          \\"nullableOfNullable\\": nullableOfNullable,

          \\"nullableOfNonNullable\\": nullableOfNonNullable,

          \\"nonNullableOfNullable\\": nonNullableOfNullable,

          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Objects listsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"listsInput\\": string};
  };
  let query = \\"query ($arg: ListsInput!)  {\\\\nlistsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"listsInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_ListsInput}
  and t_variables_ListsInput = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  let parse: Raw.t => t =
    value => {

      \\"listsInput\\": {
        let value = value##listsInput;

        value;
      },
    };
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (\\"arg\\", (a => Some(serializeInputObjectListsInput(a)))(inp##arg)),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectListsInput: t_variables_ListsInput => Js.Json.t =
    inp =>
      [|
        (
          \\"nullableOfNullable\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      a
                      |> Array.map(b =>
                           switch (
                             (
                               a =>
                                 switch (a) {
                                 | None => None
                                 | Some(b) =>
                                   (a => Some(Js.Json.string(a)))(b)
                                 }
                             )(
                               b,
                             )
                           ) {
                           | Some(c) => c
                           | None => Js.Json.null
                           }
                         )
                      |> Js.Json.array,
                    )
                )(
                  b,
                )
              }
          )(
            inp##nullableOfNullable,
          ),
        ),
        (
          \\"nullableOfNonNullable\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      a
                      |> Array.map(b =>
                           switch ((a => Some(Js.Json.string(a)))(b)) {
                           | Some(c) => c
                           | None => Js.Json.null
                           }
                         )
                      |> Js.Json.array,
                    )
                )(
                  b,
                )
              }
          )(
            inp##nullableOfNonNullable,
          ),
        ),
        (
          \\"nonNullableOfNullable\\",
          (
            a =>
              Some(
                a
                |> Array.map(b =>
                     switch (
                       (
                         a =>
                           switch (a) {
                           | None => None
                           | Some(b) => (a => Some(Js.Json.string(a)))(b)
                           }
                       )(
                         b,
                       )
                     ) {
                     | Some(c) => c
                     | None => Js.Json.null
                     }
                   )
                |> Js.Json.array,
              )
          )(
            inp##nonNullableOfNullable,
          ),
        ),
        (
          \\"nonNullableOfNonNullable\\",
          (
            a =>
              Some(
                a
                |> Array.map(b =>
                     switch ((a => Some(Js.Json.string(a)))(b)) {
                     | Some(c) => c
                     | None => Js.Json.null
                     }
                   )
                |> Js.Json.array,
              )
          )(
            inp##nonNullableOfNonNullable,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    )
  and makeInputObjectListsInput =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      )
      : t_variables_ListsInput => {

    \\"nullableOfNullable\\": nullableOfNullable,

    \\"nullableOfNonNullable\\": nullableOfNonNullable,

    \\"nonNullableOfNullable\\": nonNullableOfNullable,

    \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Objects mutation.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"mutationWithError\\": t_mutationWithError}
    and t_mutationWithError = {
      .
      \\"value\\": Js.Nullable.t(t_mutationWithError_value),
      \\"errors\\": Js.Nullable.t(array(t_mutationWithError_errors)),
    }
    and t_mutationWithError_errors = {
      .
      \\"field\\": t_mutationWithError_errors_field,
      \\"message\\": string,
    }
    and t_mutationWithError_errors_field = string
    and t_mutationWithError_value = {. \\"stringField\\": string};
  };
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nvalue  {\\\\nstringField  \\\\n}\\\\n\\\\nerrors  {\\\\nfield  \\\\nmessage  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"mutationWithError\\": t_mutationWithError}
  and t_mutationWithError = {
    .
    \\"value\\": option(t_mutationWithError_value),
    \\"errors\\": option(array(t_mutationWithError_errors)),
  }
  and t_mutationWithError_errors = {
    .
    \\"field\\": t_mutationWithError_errors_field,
    \\"message\\": string,
  }
  and t_mutationWithError_errors_field = [
    | \`FutureAddedValue(string)
    | \`FIRST
    | \`SECOND
    | \`THIRD
  ]
  and t_mutationWithError_value = {. \\"stringField\\": string};
  let parse: Raw.t => t =
    value => {

      \\"mutationWithError\\": {
        let value = value##mutationWithError;
        {

          \\"value\\": {
            let value = value##value;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some({

                \\"stringField\\": {
                  let value = value##stringField;

                  value;
                },
              })
            | None => None
            };
          },

          \\"errors\\": {
            let value = value##errors;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some(
                value
                |> Js.Array.map(value =>
                     {

                       \\"field\\": {
                         let value = value##field;
                         switch (Obj.magic(value: string)) {
                         | \\"FIRST\\" => \`FIRST
                         | \\"SECOND\\" => \`SECOND
                         | \\"THIRD\\" => \`THIRD
                         | other => \`FutureAddedValue(other)
                         };
                       },

                       \\"message\\": {
                         let value = value##message;

                         value;
                       },
                     }
                   ),
              )
            | None => None
            };
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Objects mutationWithArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"optionalInputArgs\\": string};
  };
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t = {. \\"optionalInputArgs\\": string};
  type t_variables = {. \\"required\\": string};
  let parse: Raw.t => t =
    value => {

      \\"optionalInputArgs\\": {
        let value = value##optionalInputArgs;

        value;
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|(\\"required\\", (a => Some(Js.Json.string(a)))(inp##required))|]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~required, ()) =>
    f(
      serializeVariables(
        {

          \\"required\\": required,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Objects nested.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type record = {
  f1: string,
  f2: string,
};

module MyQuery = {
  module Raw = {
    type t = {
      .
      \\"first\\": t_first,
      \\"second\\": t_second,
      \\"let_\\": t_let,
    }
    and t_let = {. \\"inner\\": Js.Nullable.t(t_let_inner)}
    and t_let_inner = {. \\"inner\\": Js.Nullable.t(t_let_inner_inner)}
    and t_let_inner_inner = {. \\"field\\": string}
    and t_second = {. \\"inner\\": Js.Nullable.t(t_second_inner)}
    and t_second_inner = {. \\"inner\\": Js.Nullable.t(t_second_inner_inner)}
    and t_second_inner_inner = {
      f1: string,
      f2: string,
    }
    and t_first = {. \\"inner\\": Js.Nullable.t(t_first_inner)}
    and t_first_inner = {. \\"inner\\": Js.Nullable.t(t_first_inner_inner)}
    and t_first_inner_inner = {. \\"field\\": string};
  };
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nsecond: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nf1: field  \\\\nf2: field  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nlet: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {
    .
    \\"first\\": t_first,
    \\"second\\": t_second,
    \\"let_\\": t_let,
  }
  and t_let = {. \\"inner\\": option(t_let_inner)}
  and t_let_inner = {. \\"inner\\": option(t_let_inner_inner)}
  and t_let_inner_inner = {. \\"field\\": string}
  and t_second = {. \\"inner\\": option(t_second_inner)}
  and t_second_inner = {. \\"inner\\": option(t_second_inner_inner)}
  and t_second_inner_inner = {
    f1: string,
    f2: string,
  }
  and t_first = {. \\"inner\\": option(t_first_inner)}
  and t_first_inner = {. \\"inner\\": option(t_first_inner_inner)}
  and t_first_inner_inner = {. \\"field\\": string};
  let parse: Raw.t => t =
    value => {

      \\"first\\": {
        let value = value##first;
        {

          \\"inner\\": {
            let value = value##inner;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some({

                \\"inner\\": {
                  let value = value##inner;

                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some({

                      \\"field\\": {
                        let value = value##field;

                        value;
                      },
                    })
                  | None => None
                  };
                },
              })
            | None => None
            };
          },
        };
      },

      \\"second\\": {
        let value = value##second;
        {

          \\"inner\\": {
            let value = value##inner;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some({

                \\"inner\\": {
                  let value = value##inner;

                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some({

                      \\"f1\\": {
                        let value = value##f1;

                        value;
                      },

                      \\"f2\\": {
                        let value = value##f2;

                        value;
                      },
                    })
                  | None => None
                  };
                },
              })
            | None => None
            };
          },
        };
      },

      \\"let_\\": {
        let value = value##let_;
        {

          \\"inner\\": {
            let value = value##inner;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some({

                \\"inner\\": {
                  let value = value##inner;

                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some({

                      \\"field\\": {
                        let value = value##field;

                        value;
                      },
                    })
                  | None => None
                  };
                },
              })
            | None => None
            };
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Objects nonrecursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"nonrecursiveInput\\": string};
  };
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"nonrecursiveInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    .
    \\"field\\": option(string),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  let parse: Raw.t => t =
    value => {

      \\"nonrecursiveInput\\": {
        let value = value##nonrecursiveInput;

        value;
      },
    };
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (a => Some(serializeInputObjectNonrecursiveInput(a)))(inp##arg),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Js.Json.t =
    inp =>
      [|
        (
          \\"field\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##field,
          ),
        ),
        (
          \\"enum\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      switch (a) {
                      | \`FIRST => Js.Json.string(\\"FIRST\\")
                      | \`SECOND => Js.Json.string(\\"SECOND\\")
                      | \`THIRD => Js.Json.string(\\"THIRD\\")
                      },
                    )
                )(
                  b,
                )
              }
          )(
            inp##enum,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    )
  and makeInputObjectNonrecursiveInput =
      (~field=?, ~enum=?, ()): t_variables_NonrecursiveInput => {

    \\"field\\": field,

    \\"enum\\": enum,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Objects pokedexApolloMode.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"pokemon\\": Js.Nullable.t(t_pokemon)}
    and t_pokemon = {
      .
      \\"id\\": string,
      \\"name\\": Js.Nullable.t(string),
    };
  };
  let query = \\"query   {\\\\npokemon(name: \\\\\\"Pikachu\\\\\\")  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"pokemon\\": option(t_pokemon)}
  and t_pokemon = {
    .
    \\"id\\": string,
    \\"name\\": option(string),
  };
  let parse: Raw.t => t =
    value => {

      \\"pokemon\\": {
        let value = value##pokemon;

        switch (Js.toOption(value)) {
        | Some(value) =>
          Some({

            \\"id\\": {
              let value = value##id;

              value;
            },

            \\"name\\": {
              let value = value##name;

              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
          })
        | None => None
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Objects pokedexScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"pokemon\\": Js.Nullable.t(t_pokemon)}
    and t_pokemon = {
      .
      \\"id\\": string,
      \\"name\\": Js.Nullable.t(string),
    };
  };
  let query = \\"query pokemon($id: String, $name: String)  {\\\\npokemon(name: $name, id: $id)  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"pokemon\\": option(t_pokemon)}
  and t_pokemon = {
    .
    \\"id\\": string,
    \\"name\\": option(string),
  };
  type t_variables = {
    .
    \\"id\\": option(string),
    \\"name\\": option(string),
  };
  let parse: Raw.t => t =
    value => {

      \\"pokemon\\": {
        let value = value##pokemon;

        switch (Js.toOption(value)) {
        | Some(value) =>
          Some({

            \\"id\\": {
              let value = value##id;

              value;
            },

            \\"name\\": {
              let value = value##name;

              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
          })
        | None => None
        };
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"id\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##id,
          ),
        ),
        (
          \\"name\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##name,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~id=?, ~name=?, ()) =>
    f(
      serializeVariables(
        {

          \\"id\\": id,

          \\"name\\": name,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Objects record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type scalars = {
  string,
  int,
};

type dog = {
  name: string,
  barkVolume: float,
};

type oneFieldQuery = {nullableString: option(string)};

module MyQuery = {
  module Raw = {
    type t = {. \\"variousScalars\\": scalars};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"variousScalars\\": scalars};
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"int\\": {
            let value = value##int;

            value;
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};

module OneFieldQuery = {
  module Raw = {
    type t = {. \\"variousScalars\\": t_variousScalars}
    and t_variousScalars = {nullableString: Js.Nullable.t(string)};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"variousScalars\\": t_variousScalars}
  and t_variousScalars = {nullableString: option(string)};
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};

module ExternalFragmentQuery = {
  module Fragment = {
    let query = \\"fragment Fragment on VariousScalars   {\\\\nstring  \\\\nint  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        string,
        int,
      };
      type t_VariousScalars = t;
    };
    type t = {
      string,
      int,
    };
    type t_VariousScalars = t;

    let parse = (value: Raw.t) => {

      \\"string\\": {
        let value = value##string;

        value;
      },

      \\"int\\": {
        let value = value##int;

        value;
      },
    };
    let name = \\"Fragment\\";
  };
  module Untitled1 = {
    module Raw = {
      type t = {. \\"variousScalars\\": Fragment.Raw.t};
    };
    let query =
      (
        (\\"query   {\\\\nvariousScalars  {\\\\n...\\" ++ Fragment.name)
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ Fragment.query;
    type t = {. \\"variousScalars\\": Fragment.t};
    let parse: Raw.t => t =
      value => {

        \\"variousScalars\\": {
          let value = value##variousScalars;

          Fragment.parse(value);
        },
      };
    let makeVar = (~f, ()) => f(Js.Json.null);
    let definition = (parse, query, makeVar);
  };
};

module InlineFragmentQuery = {
  module Raw = {
    type t = {. \\"dogOrHuman\\": t_dogOrHuman}
    and t_dogOrHuman
    and t_dogOrHuman_Dog = {
      name: string,
      barkVolume: float,
    };
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"dogOrHuman\\": t_dogOrHuman}
  and t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ]
  and t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  let parse: Raw.t => t =
    value => {

      \\"dogOrHuman\\": {
        let value = value##dogOrHuman;

        switch (Js.Json.decodeObject(Obj.magic(value): Js.Json.t)) {

        | None =>
          Js.Exn.raiseError(
            \\"graphql_ppx: \\"
            ++ \\"Expected union \\"
            ++ \\"DogOrHuman\\"
            ++ \\" to be an object, got \\"
            ++ Js.Json.stringify(Obj.magic(value): Js.Json.t),
          )

        | Some(typename_obj) =>
          switch (Js.Dict.get(typename_obj, \\"__typename\\")) {

          | None =>
            Js.Exn.raiseError(
              \\"graphql_ppx: \\"
              ++ \\"Union \\"
              ++ \\"DogOrHuman\\"
              ++ \\" is missing the __typename field\\",
            )

          | Some(typename) =>
            switch (Js.Json.decodeString(typename)) {

            | None =>
              Js.Exn.raiseError(
                \\"graphql_ppx: \\"
                ++ \\"Union \\"
                ++ \\"DogOrHuman\\"
                ++ \\" has a __typename field that is not a string\\",
              )

            | Some(typename) =>
              switch (typename) {
              | \\"Dog\\" =>
                \`Dog(
                  {
                    let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                    {

                      \\"name\\": {
                        let value = value##name;

                        value;
                      },

                      \\"barkVolume\\": {
                        let value = value##barkVolume;

                        value;
                      },
                    };
                  },
                )
              | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
              }
            }
          }
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};

module UnionExternalFragmentQuery = {
  module DogFragment = {
    let query = \\"fragment DogFragment on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        name: string,
        barkVolume: float,
      };
      type t_Dog = t;
    };
    type t = {
      name: string,
      barkVolume: float,
    };
    type t_Dog = t;

    let parse = (value: Raw.t) => {

      \\"name\\": {
        let value = value##name;

        value;
      },

      \\"barkVolume\\": {
        let value = value##barkVolume;

        value;
      },
    };
    let name = \\"DogFragment\\";
  };
  module Untitled1 = {
    module Raw = {
      type t = {. \\"dogOrHuman\\": t_dogOrHuman}
      and t_dogOrHuman;
    };
    let query =
      (
        (
          \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n...\\"
          ++ DogFragment.name
        )
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ DogFragment.query;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman}
    and t_dogOrHuman = [
      | \`FutureAddedValue(Js.Json.t)
      | \`Dog(DogFragment.t)
    ];
    let parse: Raw.t => t =
      value => {

        \\"dogOrHuman\\": {
          let value = value##dogOrHuman;

          switch (Js.Json.decodeObject(Obj.magic(value): Js.Json.t)) {

          | None =>
            Js.Exn.raiseError(
              \\"graphql_ppx: \\"
              ++ \\"Expected union \\"
              ++ \\"DogOrHuman\\"
              ++ \\" to be an object, got \\"
              ++ Js.Json.stringify(Obj.magic(value): Js.Json.t),
            )

          | Some(typename_obj) =>
            switch (Js.Dict.get(typename_obj, \\"__typename\\")) {

            | None =>
              Js.Exn.raiseError(
                \\"graphql_ppx: \\"
                ++ \\"Union \\"
                ++ \\"DogOrHuman\\"
                ++ \\" is missing the __typename field\\",
              )

            | Some(typename) =>
              switch (Js.Json.decodeString(typename)) {

              | None =>
                Js.Exn.raiseError(
                  \\"graphql_ppx: \\"
                  ++ \\"Union \\"
                  ++ \\"DogOrHuman\\"
                  ++ \\" has a __typename field that is not a string\\",
                )

              | Some(typename) =>
                switch (typename) {
                | \\"Dog\\" =>
                  \`Dog(
                    {
                      let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);

                      DogFragment.parse(value);
                    },
                  )
                | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
                }
              }
            }
          };
        },
      };
    let makeVar = (~f, ()) => f(Js.Json.null);
    let definition = (parse, query, makeVar);
  };
};
"
`;

exports[`Objects recursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"recursiveInput\\": string};
  };
  let query = \\"query ($arg: RecursiveInput!)  {\\\\nrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"recursiveInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_RecursiveInput}
  and t_variables_RecursiveInput = {
    .
    \\"otherField\\": option(string),
    \\"inner\\": option(t_variables_RecursiveInput),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  let parse: Raw.t => t =
    value => {

      \\"recursiveInput\\": {
        let value = value##recursiveInput;

        value;
      },
    };
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (a => Some(serializeInputObjectRecursiveInput(a)))(inp##arg),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectRecursiveInput:
    t_variables_RecursiveInput => Js.Json.t =
    inp =>
      [|
        (
          \\"otherField\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##otherField,
          ),
        ),
        (
          \\"inner\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (a => Some(serializeInputObjectRecursiveInput(a)))(b)
              }
          )(
            inp##inner,
          ),
        ),
        (
          \\"enum\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      switch (a) {
                      | \`FIRST => Js.Json.string(\\"FIRST\\")
                      | \`SECOND => Js.Json.string(\\"SECOND\\")
                      | \`THIRD => Js.Json.string(\\"THIRD\\")
                      },
                    )
                )(
                  b,
                )
              }
          )(
            inp##enum,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    )
  and makeInputObjectRecursiveInput =
      (~otherField=?, ~inner=?, ~enum=?, ()): t_variables_RecursiveInput => {

    \\"otherField\\": otherField,

    \\"inner\\": inner,

    \\"enum\\": enum,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Objects scalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"variousScalars\\": t_variousScalars}
    and t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"variousScalars\\": t_variousScalars}
  and t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Objects scalarsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"scalarsInput\\": string};
  };
  let query = \\"query ($nullableString: String, $string: String!, $nullableInt: Int, $int: Int!, $nullableFloat: Float, $float: Float!, $nullableBoolean: Boolean, $boolean: Boolean!, $nullableID: ID, $id: ID!)  {\\\\nscalarsInput(arg: {nullableString: $nullableString, string: $string, nullableInt: $nullableInt, int: $int, nullableFloat: $nullableFloat, float: $float, nullableBoolean: $nullableBoolean, boolean: $boolean, nullableID: $nullableID, id: $id})  \\\\n}\\\\n\\";
  type t = {. \\"scalarsInput\\": string};
  type t_variables = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"scalarsInput\\": {
        let value = value##scalarsInput;

        value;
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"nullableString\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##nullableString,
          ),
        ),
        (\\"string\\", (a => Some(Js.Json.string(a)))(inp##string)),
        (
          \\"nullableInt\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.number(float_of_int(a))))(b)
              }
          )(
            inp##nullableInt,
          ),
        ),
        (\\"int\\", (a => Some(Js.Json.number(float_of_int(a))))(inp##int)),
        (
          \\"nullableFloat\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.number(a)))(b)
              }
          )(
            inp##nullableFloat,
          ),
        ),
        (\\"float\\", (a => Some(Js.Json.number(a)))(inp##float)),
        (
          \\"nullableBoolean\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.boolean(a)))(b)
              }
          )(
            inp##nullableBoolean,
          ),
        ),
        (\\"boolean\\", (a => Some(Js.Json.boolean(a)))(inp##boolean)),
        (
          \\"nullableID\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##nullableID,
          ),
        ),
        (\\"id\\", (a => Some(Js.Json.string(a)))(inp##id)),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar =
      (
        ~f,
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      ) =>
    f(
      serializeVariables(
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,

          \\"nullableInt\\": nullableInt,

          \\"int\\": int,

          \\"nullableFloat\\": nullableFloat,

          \\"float\\": float,

          \\"nullableBoolean\\": nullableBoolean,

          \\"boolean\\": boolean,

          \\"nullableID\\": nullableID,

          \\"id\\": id,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Objects scalarsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"scalarsInput\\": string};
  };
  let query = \\"query ($arg: VariousScalarsInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"scalarsInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_VariousScalarsInput}
  and t_variables_VariousScalarsInput = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"scalarsInput\\": {
        let value = value##scalarsInput;

        value;
      },
    };
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (a => Some(serializeInputObjectVariousScalarsInput(a)))(inp##arg),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectVariousScalarsInput:
    t_variables_VariousScalarsInput => Js.Json.t =
    inp =>
      [|
        (
          \\"nullableString\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##nullableString,
          ),
        ),
        (\\"string\\", (a => Some(Js.Json.string(a)))(inp##string)),
        (
          \\"nullableInt\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.number(float_of_int(a))))(b)
              }
          )(
            inp##nullableInt,
          ),
        ),
        (\\"int\\", (a => Some(Js.Json.number(float_of_int(a))))(inp##int)),
        (
          \\"nullableFloat\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.number(a)))(b)
              }
          )(
            inp##nullableFloat,
          ),
        ),
        (\\"float\\", (a => Some(Js.Json.number(a)))(inp##float)),
        (
          \\"nullableBoolean\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.boolean(a)))(b)
              }
          )(
            inp##nullableBoolean,
          ),
        ),
        (\\"boolean\\", (a => Some(Js.Json.boolean(a)))(inp##boolean)),
        (
          \\"nullableID\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp##nullableID,
          ),
        ),
        (\\"id\\", (a => Some(Js.Json.string(a)))(inp##id)),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    )
  and makeInputObjectVariousScalarsInput =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      )
      : t_variables_VariousScalarsInput => {

    \\"nullableString\\": nullableString,

    \\"string\\": string,

    \\"nullableInt\\": nullableInt,

    \\"int\\": int,

    \\"nullableFloat\\": nullableFloat,

    \\"float\\": float,

    \\"nullableBoolean\\": nullableBoolean,

    \\"boolean\\": boolean,

    \\"nullableID\\": nullableID,

    \\"id\\": id,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Objects skipDirectives.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {
      .
      \\"v1\\": t_v1,
      \\"v2\\": t_v2,
    }
    and t_v2 = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": Js.Nullable.t(string),
    }
    and t_v1 = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": Js.Nullable.t(string),
    };
  };
  let query = \\"query ($var: Boolean!)  {\\\\nv1: variousScalars  {\\\\nnullableString @skip(if: $var) \\\\nstring @skip(if: $var) \\\\n}\\\\n\\\\nv2: variousScalars  {\\\\nnullableString @include(if: $var) \\\\nstring @include(if: $var) \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {
    .
    \\"v1\\": t_v1,
    \\"v2\\": t_v2,
  }
  and t_v2 = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": option(string),
  }
  and t_v1 = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": option(string),
  };
  type t_variables = {. \\"var\\": bool};
  let parse: Raw.t => t =
    value => {

      \\"v1\\": {
        let value = value##v1;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"string\\": {
            let value = value##string;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },
        };
      },

      \\"v2\\": {
        let value = value##v2;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"string\\": {
            let value = value##string;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },
        };
      },
    };
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|(\\"var\\", (a => Some(Js.Json.boolean(a)))(inp##var))|]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~var, ()) =>
    f(
      serializeVariables(
        {

          \\"var\\": var,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Objects subscription.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"simpleSubscription\\": t_simpleSubscription}
    and t_simpleSubscription
    and t_simpleSubscription_Human = {. \\"name\\": string}
    and t_simpleSubscription_Dog = {. \\"name\\": string};
  };
  let query = \\"subscription   {\\\\nsimpleSubscription  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"simpleSubscription\\": t_simpleSubscription}
  and t_simpleSubscription = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_simpleSubscription_Dog)
    | \`Human(t_simpleSubscription_Human)
  ]
  and t_simpleSubscription_Human = {. \\"name\\": string}
  and t_simpleSubscription_Dog = {. \\"name\\": string};
  let parse: Raw.t => t =
    value => {

      \\"simpleSubscription\\": {
        let value = value##simpleSubscription;

        switch (Js.Json.decodeObject(Obj.magic(value): Js.Json.t)) {

        | None =>
          Js.Exn.raiseError(
            \\"graphql_ppx: \\"
            ++ \\"Expected union \\"
            ++ \\"DogOrHuman\\"
            ++ \\" to be an object, got \\"
            ++ Js.Json.stringify(Obj.magic(value): Js.Json.t),
          )

        | Some(typename_obj) =>
          switch (Js.Dict.get(typename_obj, \\"__typename\\")) {

          | None =>
            Js.Exn.raiseError(
              \\"graphql_ppx: \\"
              ++ \\"Union \\"
              ++ \\"DogOrHuman\\"
              ++ \\" is missing the __typename field\\",
            )

          | Some(typename) =>
            switch (Js.Json.decodeString(typename)) {

            | None =>
              Js.Exn.raiseError(
                \\"graphql_ppx: \\"
                ++ \\"Union \\"
                ++ \\"DogOrHuman\\"
                ++ \\" has a __typename field that is not a string\\",
              )

            | Some(typename) =>
              switch (typename) {
              | \\"Dog\\" =>
                \`Dog(
                  {
                    let value: Raw.t_simpleSubscription_Dog = Obj.magic(value);
                    {

                      \\"name\\": {
                        let value = value##name;

                        value;
                      },
                    };
                  },
                )
              | \\"Human\\" =>
                \`Human(
                  {
                    let value: Raw.t_simpleSubscription_Human =
                      Obj.magic(value);
                    {

                      \\"name\\": {
                        let value = value##name;

                        value;
                      },
                    };
                  },
                )
              | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
              }
            }
          }
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Objects tagged_template.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"variousScalars\\": t_variousScalars}
    and t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"variousScalars\\": t_variousScalars}
  and t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};

module MyQuery2 = {
  module Raw = {
    type t = {. \\"variousScalars\\": t_variousScalars}
    and t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  %raw
  \\"let { graphql } = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t = {. \\"variousScalars\\": t_variousScalars}
  and t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};

module MyQuery3 = {
  module Raw = {
    type t = {. \\"variousScalars\\": t_variousScalars}
    and t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  %raw
  \\"let { graphql } = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t = {. \\"variousScalars\\": t_variousScalars}
  and t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};

module MyQuery4 = {
  module Raw = {
    type t = {. \\"variousScalars\\": t_variousScalars}
    and t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  %raw
  \\"let graphql = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t = {. \\"variousScalars\\": t_variousScalars}
  and t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"variousScalars\\": {
        let value = value##variousScalars;
        {

          \\"nullableString\\": {
            let value = value##nullableString;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"string\\": {
            let value = value##string;

            value;
          },

          \\"nullableInt\\": {
            let value = value##nullableInt;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"int\\": {
            let value = value##int;

            value;
          },

          \\"nullableFloat\\": {
            let value = value##nullableFloat;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"float\\": {
            let value = value##float;

            value;
          },

          \\"nullableBoolean\\": {
            let value = value##nullableBoolean;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"boolean\\": {
            let value = value##boolean;

            value;
          },

          \\"nullableID\\": {
            let value = value##nullableID;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          },

          \\"id\\": {
            let value = value##id;

            value;
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Objects typename.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"first\\": t_first}
    and t_first = {
      .
      \\"__typename\\": string,
      \\"inner\\": Js.Nullable.t(t_first_inner),
    }
    and t_first_inner = {
      .
      \\"__typename\\": string,
      \\"inner\\": Js.Nullable.t(t_first_inner_inner),
    }
    and t_first_inner_inner = {
      .
      \\"__typename\\": string,
      \\"field\\": string,
    };
  };
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"first\\": t_first}
  and t_first = {
    .
    \\"__typename\\": string,
    \\"inner\\": option(t_first_inner),
  }
  and t_first_inner = {
    .
    \\"__typename\\": string,
    \\"inner\\": option(t_first_inner_inner),
  }
  and t_first_inner_inner = {
    .
    \\"__typename\\": string,
    \\"field\\": string,
  };
  let parse: Raw.t => t =
    value => {

      \\"first\\": {
        let value = value##first;
        {

          \\"__typename\\": {
            let value = value##__typename;

            value;
          },

          \\"inner\\": {
            let value = value##inner;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some({

                \\"__typename\\": {
                  let value = value##__typename;

                  value;
                },

                \\"inner\\": {
                  let value = value##inner;

                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some({

                      \\"__typename\\": {
                        let value = value##__typename;

                        value;
                      },

                      \\"field\\": {
                        let value = value##field;

                        value;
                      },
                    })
                  | None => None
                  };
                },
              })
            | None => None
            };
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Objects union.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"dogOrHuman\\": t_dogOrHuman}
    and t_dogOrHuman
    and t_dogOrHuman_Human = {. \\"name\\": string}
    and t_dogOrHuman_Dog = {
      .
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"dogOrHuman\\": t_dogOrHuman}
  and t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ]
  and t_dogOrHuman_Human = {. \\"name\\": string}
  and t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  let parse: Raw.t => t =
    value => {

      \\"dogOrHuman\\": {
        let value = value##dogOrHuman;

        switch (Js.Json.decodeObject(Obj.magic(value): Js.Json.t)) {

        | None =>
          Js.Exn.raiseError(
            \\"graphql_ppx: \\"
            ++ \\"Expected union \\"
            ++ \\"DogOrHuman\\"
            ++ \\" to be an object, got \\"
            ++ Js.Json.stringify(Obj.magic(value): Js.Json.t),
          )

        | Some(typename_obj) =>
          switch (Js.Dict.get(typename_obj, \\"__typename\\")) {

          | None =>
            Js.Exn.raiseError(
              \\"graphql_ppx: \\"
              ++ \\"Union \\"
              ++ \\"DogOrHuman\\"
              ++ \\" is missing the __typename field\\",
            )

          | Some(typename) =>
            switch (Js.Json.decodeString(typename)) {

            | None =>
              Js.Exn.raiseError(
                \\"graphql_ppx: \\"
                ++ \\"Union \\"
                ++ \\"DogOrHuman\\"
                ++ \\" has a __typename field that is not a string\\",
              )

            | Some(typename) =>
              switch (typename) {
              | \\"Dog\\" =>
                \`Dog(
                  {
                    let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                    {

                      \\"name\\": {
                        let value = value##name;

                        value;
                      },

                      \\"barkVolume\\": {
                        let value = value##barkVolume;

                        value;
                      },
                    };
                  },
                )
              | \\"Human\\" =>
                \`Human(
                  {
                    let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                    {

                      \\"name\\": {
                        let value = value##name;

                        value;
                      },
                    };
                  },
                )
              | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
              }
            }
          }
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Objects unionPartial.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"dogOrHuman\\": t_dogOrHuman}
    and t_dogOrHuman
    and t_dogOrHuman_Dog = {
      .
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"dogOrHuman\\": t_dogOrHuman}
  and t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ]
  and t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  let parse: Raw.t => t =
    value => {

      \\"dogOrHuman\\": {
        let value = value##dogOrHuman;

        switch (Js.Json.decodeObject(Obj.magic(value): Js.Json.t)) {

        | None =>
          Js.Exn.raiseError(
            \\"graphql_ppx: \\"
            ++ \\"Expected union \\"
            ++ \\"DogOrHuman\\"
            ++ \\" to be an object, got \\"
            ++ Js.Json.stringify(Obj.magic(value): Js.Json.t),
          )

        | Some(typename_obj) =>
          switch (Js.Dict.get(typename_obj, \\"__typename\\")) {

          | None =>
            Js.Exn.raiseError(
              \\"graphql_ppx: \\"
              ++ \\"Union \\"
              ++ \\"DogOrHuman\\"
              ++ \\" is missing the __typename field\\",
            )

          | Some(typename) =>
            switch (Js.Json.decodeString(typename)) {

            | None =>
              Js.Exn.raiseError(
                \\"graphql_ppx: \\"
                ++ \\"Union \\"
                ++ \\"DogOrHuman\\"
                ++ \\" has a __typename field that is not a string\\",
              )

            | Some(typename) =>
              switch (typename) {
              | \\"Dog\\" =>
                \`Dog(
                  {
                    let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                    {

                      \\"name\\": {
                        let value = value##name;

                        value;
                      },

                      \\"barkVolume\\": {
                        let value = value##barkVolume;

                        value;
                      },
                    };
                  },
                )
              | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
              }
            }
          }
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Records argNamedQuery.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {argNamedQuery: int};
  };
  let query = \\"query ($query: String!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\";
  type t = {argNamedQuery: int};
  type t_variables = {query: string};
  let parse: Raw.t => t =
    (value) => (
      {

        argNamedQuery: {
          let value = (value: Raw.t).argNamedQuery;

          value;
        },
      }: t
    );
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|(\\"query\\", (a => Some(Js.Json.string(a)))(inp.query))|]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~query, ()) =>
    f(
      serializeVariables(
        {

          query: query,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Records comment.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {nonrecursiveInput: string};
  };
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {nonrecursiveInput: string};
  type t_variables = {arg: t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    field: option(string),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  let parse: Raw.t => t =
    (value) => (
      {

        nonrecursiveInput: {
          let value = (value: Raw.t).nonrecursiveInput;

          value;
        },
      }: t
    );
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (a => Some(serializeInputObjectNonrecursiveInput(a)))(inp.arg),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Js.Json.t =
    inp =>
      [|
        (
          \\"field\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp.field,
          ),
        ),
        (
          \\"enum\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      switch (a) {
                      | \`FIRST => Js.Json.string(\\"FIRST\\")
                      | \`SECOND => Js.Json.string(\\"SECOND\\")
                      | \`THIRD => Js.Json.string(\\"THIRD\\")
                      },
                    )
                )(
                  b,
                )
              }
          )(
            inp.enum,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          arg: arg,
        }: t_variables,
      ),
    )
  and makeInputObjectNonrecursiveInput =
      (~field=?, ~enum=?, ()): t_variables_NonrecursiveInput => {

    field,

    enum,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Records customDecoder.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module StringOfInt = {
  let parse = string_of_int;
  type t = string;
};
module IntOfString = {
  let parse = int_of_string;
  type t = int;
};

module MyQuery = {
  module Raw = {
    type t = {variousScalars: t_variousScalars}
    and t_variousScalars = {
      string,
      int,
    };
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {variousScalars: t_variousScalars}
  and t_variousScalars = {
    string: IntOfString.t,
    int: StringOfInt.t,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {

              string: {
                let value = (value: Raw.t_variousScalars).string;

                IntOfString.parse(value);
              },

              int: {
                let value = (value: Raw.t_variousScalars).int;

                StringOfInt.parse(value);
              },
            }: t_variousScalars
          );
        },
      }: t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Records customScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {customScalarField: t_customScalarField}
    and t_customScalarField = {
      nullable: Js.Nullable.t(Js.Json.t),
      nonNullable: Js.Json.t,
    };
  };
  let query = \\"query ($opt: CustomScalar, $req: CustomScalar!)  {\\\\ncustomScalarField(argOptional: $opt, argRequired: $req)  {\\\\nnullable  \\\\nnonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {customScalarField: t_customScalarField}
  and t_customScalarField = {
    nullable: option(Js.Json.t),
    nonNullable: Js.Json.t,
  };
  type t_variables = {
    opt: option(Js.Json.t),
    req: Js.Json.t,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        customScalarField: {
          let value = (value: Raw.t).customScalarField;
          (
            {

              nullable: {
                let value = (value: Raw.t_customScalarField).nullable;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              nonNullable: {
                let value = (value: Raw.t_customScalarField).nonNullable;

                value;
              },
            }: t_customScalarField
          );
        },
      }: t
    );
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"opt\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(a))(b)
              }
          )(
            inp.opt,
          ),
        ),
        (\\"req\\", (a => Some(a))(inp.req)),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~opt=?, ~req, ()) =>
    f(
      serializeVariables(
        {

          opt,

          req,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Records enumInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {enumInput: string};
  };
  let query = \\"query ($arg: SampleField!)  {\\\\nenumInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {enumInput: string};
  type t_variables = {arg: [ | \`FIRST | \`SECOND | \`THIRD]};
  let parse: Raw.t => t =
    (value) => (
      {

        enumInput: {
          let value = (value: Raw.t).enumInput;

          value;
        },
      }: t
    );
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (
            a =>
              Some(
                switch (a) {
                | \`FIRST => Js.Json.string(\\"FIRST\\")
                | \`SECOND => Js.Json.string(\\"SECOND\\")
                | \`THIRD => Js.Json.string(\\"THIRD\\")
                },
              )
          )(
            inp.arg,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          arg: arg,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Records explicit_object_record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module RecordsQuery = {
  module Raw = {
    type t = {lists: t_lists}
    and t_lists = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {lists: t_lists}
  and t_lists = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  let parse: Raw.t => t =
    (value) => (
      {

        lists: {
          let value = (value: Raw.t).lists;
          (
            {

              nullableOfNullable: {
                let value = (value: Raw.t_lists).nullableOfNullable;

                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              },

              nullableOfNonNullable: {
                let value = (value: Raw.t_lists).nullableOfNonNullable;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value |> Js.Array.map(value => value))
                | None => None
                };
              },

              nonNullableOfNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNullable;

                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   );
              },

              nonNullableOfNonNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNonNullable;

                value |> Js.Array.map(value => value);
              },
            }: t_lists
          );
        },
      }: t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};

module ObjectsQuery = {
  module Raw = {
    type t = {. \\"lists\\": t_lists}
    and t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"lists\\": t_lists}
  and t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  let parse: Raw.t => t =
    value => {

      \\"lists\\": {
        let value = value##lists;
        {

          \\"nullableOfNullable\\": {
            let value = value##nullableOfNullable;

            switch (Js.toOption(value)) {
            | Some(value) =>
              Some(
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   ),
              )
            | None => None
            };
          },

          \\"nullableOfNonNullable\\": {
            let value = value##nullableOfNonNullable;

            switch (Js.toOption(value)) {
            | Some(value) => Some(value |> Js.Array.map(value => value))
            | None => None
            };
          },

          \\"nonNullableOfNullable\\": {
            let value = value##nonNullableOfNullable;

            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               );
          },

          \\"nonNullableOfNonNullable\\": {
            let value = value##nonNullableOfNonNullable;

            value |> Js.Array.map(value => value);
          },
        };
      },
    };
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Records fragmentDefinition.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];

module Fragments = {
  module ListFragment = {
    let query = \\"fragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
        nullableOfNonNullable: Js.Nullable.t(array(string)),
      };
      type t_Lists = t;
    };
    type t = {
      nullableOfNullable: option(array(option(string))),
      nullableOfNonNullable: option(array(string)),
    };
    type t_Lists = t;

    let parse = (value: Raw.t): t => {

      nullableOfNullable: {
        let value = (value: Raw.t).nullableOfNullable;

        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      },

      nullableOfNonNullable: {
        let value = (value: Raw.t).nullableOfNonNullable;

        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      },
    };
    let name = \\"ListFragment\\";
  };
  module Another = {
    let query = \\"fragment Another on Lists   {\\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
    module Raw = {
      type t = {nullableOfNonNullable: Js.Nullable.t(array(string))};
      type t_Lists = t;
    };
    type t = {nullableOfNonNullable: option(array(string))};
    type t_Lists = t;

    let parse = (value: Raw.t): t => {

      nullableOfNonNullable: {
        let value = (value: Raw.t).nullableOfNonNullable;

        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      },
    };
    let name = \\"Another\\";
  };
};

module MyQuery = {
  module Raw = {
    type t = {
      l1: Fragments.ListFragment.Raw.t,
      l2: t_l2,
    }
    and t_l2;
  };
  let query =
    (
      (
        (
          (
            (
              (\\"query   {\\\\nl1: lists  {\\\\n...\\" ++ Fragments.ListFragment.name)
              ++ \\"   \\\\n}\\\\n\\\\nl2: lists  {\\\\n...\\"
            )
            ++ Fragments.ListFragment.name
          )
          ++ \\"   \\\\n...\\"
        )
        ++ Fragments.ListFragment.name
      )
      ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
    )
    ++ Fragments.ListFragment.query;
  type t = {
    l1: Fragments.ListFragment.t,
    l2: t_l2,
  }
  and t_l2 = {
    frag1: Fragments.ListFragment.t_Lists,
    frag2: Fragments.ListFragment.t_Lists,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        l1: {
          let value = (value: Raw.t).l1;

          Fragments.ListFragment.parse(value);
        },

        l2: {
          let value = (value: Raw.t).l2;
          (
            {

              frag1: {
                let value: Fragments.ListFragment.Raw.t = Obj.magic(value);

                Fragments.ListFragment.parse(value);
              },

              frag2: {
                let value: Fragments.ListFragment.Raw.t = Obj.magic(value);

                Fragments.ListFragment.parse(value);
              },
            }: t_l2
          );
        },
      }: t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Records interface.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
"
`;

exports[`Records lists.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {lists: t_lists}
    and t_lists = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {lists: t_lists}
  and t_lists = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  let parse: Raw.t => t =
    (value) => (
      {

        lists: {
          let value = (value: Raw.t).lists;
          (
            {

              nullableOfNullable: {
                let value = (value: Raw.t_lists).nullableOfNullable;

                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              },

              nullableOfNonNullable: {
                let value = (value: Raw.t_lists).nullableOfNonNullable;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value |> Js.Array.map(value => value))
                | None => None
                };
              },

              nonNullableOfNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNullable;

                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   );
              },

              nonNullableOfNonNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNonNullable;

                value |> Js.Array.map(value => value);
              },
            }: t_lists
          );
        },
      }: t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Records listsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {listsInput: string};
  };
  let query = \\"query ($nullableOfNullable: [String], $nullableOfNonNullable: [String!], $nonNullableOfNullable: [String]!, $nonNullableOfNonNullable: [String!]!)  {\\\\nlistsInput(arg: {nullableOfNullable: $nullableOfNullable, nullableOfNonNullable: $nullableOfNonNullable, nonNullableOfNullable: $nonNullableOfNullable, nonNullableOfNonNullable: $nonNullableOfNonNullable})  \\\\n}\\\\n\\";
  type t = {listsInput: string};
  type t_variables = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  let parse: Raw.t => t =
    (value) => (
      {

        listsInput: {
          let value = (value: Raw.t).listsInput;

          value;
        },
      }: t
    );
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"nullableOfNullable\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      a
                      |> Array.map(b =>
                           switch (
                             (
                               a =>
                                 switch (a) {
                                 | None => None
                                 | Some(b) =>
                                   (a => Some(Js.Json.string(a)))(b)
                                 }
                             )(
                               b,
                             )
                           ) {
                           | Some(c) => c
                           | None => Js.Json.null
                           }
                         )
                      |> Js.Json.array,
                    )
                )(
                  b,
                )
              }
          )(
            inp.nullableOfNullable,
          ),
        ),
        (
          \\"nullableOfNonNullable\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      a
                      |> Array.map(b =>
                           switch ((a => Some(Js.Json.string(a)))(b)) {
                           | Some(c) => c
                           | None => Js.Json.null
                           }
                         )
                      |> Js.Json.array,
                    )
                )(
                  b,
                )
              }
          )(
            inp.nullableOfNonNullable,
          ),
        ),
        (
          \\"nonNullableOfNullable\\",
          (
            a =>
              Some(
                a
                |> Array.map(b =>
                     switch (
                       (
                         a =>
                           switch (a) {
                           | None => None
                           | Some(b) => (a => Some(Js.Json.string(a)))(b)
                           }
                       )(
                         b,
                       )
                     ) {
                     | Some(c) => c
                     | None => Js.Json.null
                     }
                   )
                |> Js.Json.array,
              )
          )(
            inp.nonNullableOfNullable,
          ),
        ),
        (
          \\"nonNullableOfNonNullable\\",
          (
            a =>
              Some(
                a
                |> Array.map(b =>
                     switch ((a => Some(Js.Json.string(a)))(b)) {
                     | Some(c) => c
                     | None => Js.Json.null
                     }
                   )
                |> Js.Json.array,
              )
          )(
            inp.nonNullableOfNonNullable,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar =
      (
        ~f,
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      ) =>
    f(
      serializeVariables(
        {

          nullableOfNullable,

          nullableOfNonNullable,

          nonNullableOfNullable,

          nonNullableOfNonNullable,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Records listsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {listsInput: string};
  };
  let query = \\"query ($arg: ListsInput!)  {\\\\nlistsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {listsInput: string};
  type t_variables = {arg: t_variables_ListsInput}
  and t_variables_ListsInput = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  let parse: Raw.t => t =
    (value) => (
      {

        listsInput: {
          let value = (value: Raw.t).listsInput;

          value;
        },
      }: t
    );
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|(\\"arg\\", (a => Some(serializeInputObjectListsInput(a)))(inp.arg))|]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectListsInput: t_variables_ListsInput => Js.Json.t =
    inp =>
      [|
        (
          \\"nullableOfNullable\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      a
                      |> Array.map(b =>
                           switch (
                             (
                               a =>
                                 switch (a) {
                                 | None => None
                                 | Some(b) =>
                                   (a => Some(Js.Json.string(a)))(b)
                                 }
                             )(
                               b,
                             )
                           ) {
                           | Some(c) => c
                           | None => Js.Json.null
                           }
                         )
                      |> Js.Json.array,
                    )
                )(
                  b,
                )
              }
          )(
            inp.nullableOfNullable,
          ),
        ),
        (
          \\"nullableOfNonNullable\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      a
                      |> Array.map(b =>
                           switch ((a => Some(Js.Json.string(a)))(b)) {
                           | Some(c) => c
                           | None => Js.Json.null
                           }
                         )
                      |> Js.Json.array,
                    )
                )(
                  b,
                )
              }
          )(
            inp.nullableOfNonNullable,
          ),
        ),
        (
          \\"nonNullableOfNullable\\",
          (
            a =>
              Some(
                a
                |> Array.map(b =>
                     switch (
                       (
                         a =>
                           switch (a) {
                           | None => None
                           | Some(b) => (a => Some(Js.Json.string(a)))(b)
                           }
                       )(
                         b,
                       )
                     ) {
                     | Some(c) => c
                     | None => Js.Json.null
                     }
                   )
                |> Js.Json.array,
              )
          )(
            inp.nonNullableOfNullable,
          ),
        ),
        (
          \\"nonNullableOfNonNullable\\",
          (
            a =>
              Some(
                a
                |> Array.map(b =>
                     switch ((a => Some(Js.Json.string(a)))(b)) {
                     | Some(c) => c
                     | None => Js.Json.null
                     }
                   )
                |> Js.Json.array,
              )
          )(
            inp.nonNullableOfNonNullable,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          arg: arg,
        }: t_variables,
      ),
    )
  and makeInputObjectListsInput =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      )
      : t_variables_ListsInput => {

    nullableOfNullable,

    nullableOfNonNullable,

    nonNullableOfNullable,

    nonNullableOfNonNullable,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Records mutation.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {mutationWithError: t_mutationWithError}
    and t_mutationWithError = {
      value: Js.Nullable.t(t_mutationWithError_value),
      errors: Js.Nullable.t(array(t_mutationWithError_errors)),
    }
    and t_mutationWithError_errors = {
      field: t_mutationWithError_errors_field,
      message: string,
    }
    and t_mutationWithError_errors_field = string
    and t_mutationWithError_value = {stringField: string};
  };
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nvalue  {\\\\nstringField  \\\\n}\\\\n\\\\nerrors  {\\\\nfield  \\\\nmessage  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {mutationWithError: t_mutationWithError}
  and t_mutationWithError = {
    value: option(t_mutationWithError_value),
    errors: option(array(t_mutationWithError_errors)),
  }
  and t_mutationWithError_errors = {
    field: t_mutationWithError_errors_field,
    message: string,
  }
  and t_mutationWithError_errors_field = [
    | \`FutureAddedValue(string)
    | \`FIRST
    | \`SECOND
    | \`THIRD
  ]
  and t_mutationWithError_value = {stringField: string};
  let parse: Raw.t => t =
    (value) => (
      {

        mutationWithError: {
          let value = (value: Raw.t).mutationWithError;
          (
            {

              value: {
                let value = (value: Raw.t_mutationWithError).value;

                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {

                      stringField: {
                        let value =
                          (value: Raw.t_mutationWithError_value).stringField;

                        value;
                      },
                    }: t_mutationWithError_value,
                  )
                | None => None
                };
              },

              errors: {
                let value = (value: Raw.t_mutationWithError).errors;

                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map((value) =>
                         (
                           {

                             field: {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).field;
                               switch (Obj.magic(value: string)) {
                               | \\"FIRST\\" => \`FIRST
                               | \\"SECOND\\" => \`SECOND
                               | \\"THIRD\\" => \`THIRD
                               | other => \`FutureAddedValue(other)
                               };
                             },

                             message: {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).
                                   message;

                               value;
                             },
                           }: t_mutationWithError_errors
                         )
                       ),
                  )
                | None => None
                };
              },
            }: t_mutationWithError
          );
        },
      }: t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Records mutationWithArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {optionalInputArgs: string};
  };
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t = {optionalInputArgs: string};
  type t_variables = {required: string};
  let parse: Raw.t => t =
    (value) => (
      {

        optionalInputArgs: {
          let value = (value: Raw.t).optionalInputArgs;

          value;
        },
      }: t
    );
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|(\\"required\\", (a => Some(Js.Json.string(a)))(inp.required))|]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~required, ()) =>
    f(
      serializeVariables(
        {

          required: required,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Records nested.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type record = {
  f1: string,
  f2: string,
};

module MyQuery = {
  module Raw = {
    type t = {
      first: t_first,
      second: t_second,
      let_: t_let,
    }
    and t_let = {inner: Js.Nullable.t(t_let_inner)}
    and t_let_inner = {inner: Js.Nullable.t(t_let_inner_inner)}
    and t_let_inner_inner = {field: string}
    and t_second = {inner: Js.Nullable.t(t_second_inner)}
    and t_second_inner = {inner: Js.Nullable.t(t_second_inner_inner)}
    and t_second_inner_inner = {
      f1: string,
      f2: string,
    }
    and t_first = {inner: Js.Nullable.t(t_first_inner)}
    and t_first_inner = {inner: Js.Nullable.t(t_first_inner_inner)}
    and t_first_inner_inner = {field: string};
  };
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nsecond: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nf1: field  \\\\nf2: field  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nlet: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {
    first: t_first,
    second: t_second,
    let_: t_let,
  }
  and t_let = {inner: option(t_let_inner)}
  and t_let_inner = {inner: option(t_let_inner_inner)}
  and t_let_inner_inner = {field: string}
  and t_second = {inner: option(t_second_inner)}
  and t_second_inner = {inner: option(t_second_inner_inner)}
  and t_second_inner_inner = {
    f1: string,
    f2: string,
  }
  and t_first = {inner: option(t_first_inner)}
  and t_first_inner = {inner: option(t_first_inner_inner)}
  and t_first_inner_inner = {field: string};
  let parse: Raw.t => t =
    (value) => (
      {

        first: {
          let value = (value: Raw.t).first;
          (
            {

              inner: {
                let value = (value: Raw.t_first).inner;

                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {

                      inner: {
                        let value = (value: Raw.t_first_inner).inner;

                        switch (Js.toOption(value)) {
                        | Some(value) =>
                          Some(
                            {

                              field: {
                                let value =
                                  (value: Raw.t_first_inner_inner).field;

                                value;
                              },
                            }: t_first_inner_inner,
                          )
                        | None => None
                        };
                      },
                    }: t_first_inner,
                  )
                | None => None
                };
              },
            }: t_first
          );
        },

        second: {
          let value = (value: Raw.t).second;
          (
            {

              inner: {
                let value = (value: Raw.t_second).inner;

                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {

                      inner: {
                        let value = (value: Raw.t_second_inner).inner;

                        switch (Js.toOption(value)) {
                        | Some(value) =>
                          Some(
                            {

                              f1: {
                                let value =
                                  (value: Raw.t_second_inner_inner).f1;

                                value;
                              },

                              f2: {
                                let value =
                                  (value: Raw.t_second_inner_inner).f2;

                                value;
                              },
                            }: t_second_inner_inner,
                          )
                        | None => None
                        };
                      },
                    }: t_second_inner,
                  )
                | None => None
                };
              },
            }: t_second
          );
        },

        let_: {
          let value = (value: Raw.t).let_;
          (
            {

              inner: {
                let value = (value: Raw.t_let).inner;

                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {

                      inner: {
                        let value = (value: Raw.t_let_inner).inner;

                        switch (Js.toOption(value)) {
                        | Some(value) =>
                          Some(
                            {

                              field: {
                                let value =
                                  (value: Raw.t_let_inner_inner).field;

                                value;
                              },
                            }: t_let_inner_inner,
                          )
                        | None => None
                        };
                      },
                    }: t_let_inner,
                  )
                | None => None
                };
              },
            }: t_let
          );
        },
      }: t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Records nonrecursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {nonrecursiveInput: string};
  };
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {nonrecursiveInput: string};
  type t_variables = {arg: t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    field: option(string),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  let parse: Raw.t => t =
    (value) => (
      {

        nonrecursiveInput: {
          let value = (value: Raw.t).nonrecursiveInput;

          value;
        },
      }: t
    );
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (a => Some(serializeInputObjectNonrecursiveInput(a)))(inp.arg),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Js.Json.t =
    inp =>
      [|
        (
          \\"field\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp.field,
          ),
        ),
        (
          \\"enum\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      switch (a) {
                      | \`FIRST => Js.Json.string(\\"FIRST\\")
                      | \`SECOND => Js.Json.string(\\"SECOND\\")
                      | \`THIRD => Js.Json.string(\\"THIRD\\")
                      },
                    )
                )(
                  b,
                )
              }
          )(
            inp.enum,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          arg: arg,
        }: t_variables,
      ),
    )
  and makeInputObjectNonrecursiveInput =
      (~field=?, ~enum=?, ()): t_variables_NonrecursiveInput => {

    field,

    enum,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Records pokedexApolloMode.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {pokemon: Js.Nullable.t(t_pokemon)}
    and t_pokemon = {
      id: string,
      name: Js.Nullable.t(string),
    };
  };
  let query = \\"query   {\\\\npokemon(name: \\\\\\"Pikachu\\\\\\")  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {pokemon: option(t_pokemon)}
  and t_pokemon = {
    id: string,
    name: option(string),
  };
  let parse: Raw.t => t =
    (value) => (
      {

        pokemon: {
          let value = (value: Raw.t).pokemon;

          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {

                id: {
                  let value = (value: Raw.t_pokemon).id;

                  value;
                },

                name: {
                  let value = (value: Raw.t_pokemon).name;

                  switch (Js.toOption(value)) {
                  | Some(value) => Some(value)
                  | None => None
                  };
                },
              }: t_pokemon,
            )
          | None => None
          };
        },
      }: t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Records pokedexScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {pokemon: Js.Nullable.t(t_pokemon)}
    and t_pokemon = {
      id: string,
      name: Js.Nullable.t(string),
    };
  };
  let query = \\"query pokemon($id: String, $name: String)  {\\\\npokemon(name: $name, id: $id)  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {pokemon: option(t_pokemon)}
  and t_pokemon = {
    id: string,
    name: option(string),
  };
  type t_variables = {
    id: option(string),
    name: option(string),
  };
  let parse: Raw.t => t =
    (value) => (
      {

        pokemon: {
          let value = (value: Raw.t).pokemon;

          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {

                id: {
                  let value = (value: Raw.t_pokemon).id;

                  value;
                },

                name: {
                  let value = (value: Raw.t_pokemon).name;

                  switch (Js.toOption(value)) {
                  | Some(value) => Some(value)
                  | None => None
                  };
                },
              }: t_pokemon,
            )
          | None => None
          };
        },
      }: t
    );
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"id\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp.id,
          ),
        ),
        (
          \\"name\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp.name,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~id=?, ~name=?, ()) =>
    f(
      serializeVariables(
        {

          id,

          name,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Records record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type scalars = {
  string,
  int,
};

type dog = {
  name: string,
  barkVolume: float,
};

type oneFieldQuery = {nullableString: option(string)};

module MyQuery = {
  module Raw = {
    type t = {variousScalars: scalars};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {variousScalars: scalars};
  let parse: Raw.t => t =
    (value) => (
      {

        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {

              string: {
                let value = (value: Raw.t_variousScalars).string;

                value;
              },

              int: {
                let value = (value: Raw.t_variousScalars).int;

                value;
              },
            }: scalars
          );
        },
      }: t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};

module OneFieldQuery = {
  module Raw = {
    type t = {variousScalars: t_variousScalars}
    and t_variousScalars = {nullableString: Js.Nullable.t(string)};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {variousScalars: t_variousScalars}
  and t_variousScalars = {nullableString: option(string)};
  let parse: Raw.t => t =
    (value) => (
      {

        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {

              nullableString: {
                let value = (value: Raw.t_variousScalars).nullableString;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
            }: t_variousScalars
          );
        },
      }: t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};

module ExternalFragmentQuery = {
  module Fragment = {
    let query = \\"fragment Fragment on VariousScalars   {\\\\nstring  \\\\nint  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        string,
        int,
      };
      type t_VariousScalars = t;
    };
    type t = {
      string,
      int,
    };
    type t_VariousScalars = t;

    let parse = (value: Raw.t): t => {

      string: {
        let value = (value: Raw.t).string;

        value;
      },

      int: {
        let value = (value: Raw.t).int;

        value;
      },
    };
    let name = \\"Fragment\\";
  };
  module Untitled1 = {
    module Raw = {
      type t = {variousScalars: Fragment.Raw.t};
    };
    let query =
      (
        (\\"query   {\\\\nvariousScalars  {\\\\n...\\" ++ Fragment.name)
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ Fragment.query;
    type t = {variousScalars: Fragment.t};
    let parse: Raw.t => t =
      (value) => (
        {

          variousScalars: {
            let value = (value: Raw.t).variousScalars;

            Fragment.parse(value);
          },
        }: t
      );
    let makeVar = (~f, ()) => f(Js.Json.null);
    let definition = (parse, query, makeVar);
  };
};

module InlineFragmentQuery = {
  module Raw = {
    type t = {dogOrHuman: t_dogOrHuman}
    and t_dogOrHuman
    and t_dogOrHuman_Dog = {
      name: string,
      barkVolume: float,
    };
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {dogOrHuman: t_dogOrHuman}
  and t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ]
  and t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        dogOrHuman: {
          let value = (value: Raw.t).dogOrHuman;

          switch (Js.Json.decodeObject(Obj.magic(value): Js.Json.t)) {

          | None =>
            Js.Exn.raiseError(
              \\"graphql_ppx: \\"
              ++ \\"Expected union \\"
              ++ \\"DogOrHuman\\"
              ++ \\" to be an object, got \\"
              ++ Js.Json.stringify(Obj.magic(value): Js.Json.t),
            )

          | Some(typename_obj) =>
            switch (Js.Dict.get(typename_obj, \\"__typename\\")) {

            | None =>
              Js.Exn.raiseError(
                \\"graphql_ppx: \\"
                ++ \\"Union \\"
                ++ \\"DogOrHuman\\"
                ++ \\" is missing the __typename field\\",
              )

            | Some(typename) =>
              switch (Js.Json.decodeString(typename)) {

              | None =>
                Js.Exn.raiseError(
                  \\"graphql_ppx: \\"
                  ++ \\"Union \\"
                  ++ \\"DogOrHuman\\"
                  ++ \\" has a __typename field that is not a string\\",
                )

              | Some(typename) =>
                switch (typename) {
                | \\"Dog\\" =>
                  \`Dog(
                    {
                      let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                      (
                        {

                          name: {
                            let value = (value: Raw.t_dogOrHuman_Dog).name;

                            value;
                          },

                          barkVolume: {
                            let value =
                              (value: Raw.t_dogOrHuman_Dog).barkVolume;

                            value;
                          },
                        }: t_dogOrHuman_Dog
                      );
                    },
                  )
                | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
                }
              }
            }
          };
        },
      }: t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};

module UnionExternalFragmentQuery = {
  module DogFragment = {
    let query = \\"fragment DogFragment on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        name: string,
        barkVolume: float,
      };
      type t_Dog = t;
    };
    type t = {
      name: string,
      barkVolume: float,
    };
    type t_Dog = t;

    let parse = (value: Raw.t): t => {

      name: {
        let value = (value: Raw.t).name;

        value;
      },

      barkVolume: {
        let value = (value: Raw.t).barkVolume;

        value;
      },
    };
    let name = \\"DogFragment\\";
  };
  module Untitled1 = {
    module Raw = {
      type t = {dogOrHuman: t_dogOrHuman}
      and t_dogOrHuman;
    };
    let query =
      (
        (
          \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n...\\"
          ++ DogFragment.name
        )
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ DogFragment.query;
    type t = {dogOrHuman: t_dogOrHuman}
    and t_dogOrHuman = [
      | \`FutureAddedValue(Js.Json.t)
      | \`Dog(DogFragment.t)
    ];
    let parse: Raw.t => t =
      (value) => (
        {

          dogOrHuman: {
            let value = (value: Raw.t).dogOrHuman;

            switch (Js.Json.decodeObject(Obj.magic(value): Js.Json.t)) {

            | None =>
              Js.Exn.raiseError(
                \\"graphql_ppx: \\"
                ++ \\"Expected union \\"
                ++ \\"DogOrHuman\\"
                ++ \\" to be an object, got \\"
                ++ Js.Json.stringify(Obj.magic(value): Js.Json.t),
              )

            | Some(typename_obj) =>
              switch (Js.Dict.get(typename_obj, \\"__typename\\")) {

              | None =>
                Js.Exn.raiseError(
                  \\"graphql_ppx: \\"
                  ++ \\"Union \\"
                  ++ \\"DogOrHuman\\"
                  ++ \\" is missing the __typename field\\",
                )

              | Some(typename) =>
                switch (Js.Json.decodeString(typename)) {

                | None =>
                  Js.Exn.raiseError(
                    \\"graphql_ppx: \\"
                    ++ \\"Union \\"
                    ++ \\"DogOrHuman\\"
                    ++ \\" has a __typename field that is not a string\\",
                  )

                | Some(typename) =>
                  switch (typename) {
                  | \\"Dog\\" =>
                    \`Dog(
                      {
                        let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);

                        DogFragment.parse(value);
                      },
                    )
                  | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
                  }
                }
              }
            };
          },
        }: t
      );
    let makeVar = (~f, ()) => f(Js.Json.null);
    let definition = (parse, query, makeVar);
  };
};
"
`;

exports[`Records recursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {recursiveInput: string};
  };
  let query = \\"query ($arg: RecursiveInput!)  {\\\\nrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {recursiveInput: string};
  type t_variables = {arg: t_variables_RecursiveInput}
  and t_variables_RecursiveInput = {
    otherField: option(string),
    inner: option(t_variables_RecursiveInput),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  let parse: Raw.t => t =
    (value) => (
      {

        recursiveInput: {
          let value = (value: Raw.t).recursiveInput;

          value;
        },
      }: t
    );
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (a => Some(serializeInputObjectRecursiveInput(a)))(inp.arg),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectRecursiveInput:
    t_variables_RecursiveInput => Js.Json.t =
    inp =>
      [|
        (
          \\"otherField\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp.otherField,
          ),
        ),
        (
          \\"inner\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (a => Some(serializeInputObjectRecursiveInput(a)))(b)
              }
          )(
            inp.inner,
          ),
        ),
        (
          \\"enum\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) =>
                (
                  a =>
                    Some(
                      switch (a) {
                      | \`FIRST => Js.Json.string(\\"FIRST\\")
                      | \`SECOND => Js.Json.string(\\"SECOND\\")
                      | \`THIRD => Js.Json.string(\\"THIRD\\")
                      },
                    )
                )(
                  b,
                )
              }
          )(
            inp.enum,
          ),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          arg: arg,
        }: t_variables,
      ),
    )
  and makeInputObjectRecursiveInput =
      (~otherField=?, ~inner=?, ~enum=?, ()): t_variables_RecursiveInput => {

    otherField,

    inner,

    enum,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Records scalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {variousScalars: t_variousScalars}
    and t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {variousScalars: t_variousScalars}
  and t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {

              nullableString: {
                let value = (value: Raw.t_variousScalars).nullableString;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              string: {
                let value = (value: Raw.t_variousScalars).string;

                value;
              },

              nullableInt: {
                let value = (value: Raw.t_variousScalars).nullableInt;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              int: {
                let value = (value: Raw.t_variousScalars).int;

                value;
              },

              nullableFloat: {
                let value = (value: Raw.t_variousScalars).nullableFloat;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              float: {
                let value = (value: Raw.t_variousScalars).float;

                value;
              },

              nullableBoolean: {
                let value = (value: Raw.t_variousScalars).nullableBoolean;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              boolean: {
                let value = (value: Raw.t_variousScalars).boolean;

                value;
              },

              nullableID: {
                let value = (value: Raw.t_variousScalars).nullableID;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              id: {
                let value = (value: Raw.t_variousScalars).id;

                value;
              },
            }: t_variousScalars
          );
        },
      }: t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Records scalarsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {scalarsInput: string};
  };
  let query = \\"query ($nullableString: String, $string: String!, $nullableInt: Int, $int: Int!, $nullableFloat: Float, $float: Float!, $nullableBoolean: Boolean, $boolean: Boolean!, $nullableID: ID, $id: ID!)  {\\\\nscalarsInput(arg: {nullableString: $nullableString, string: $string, nullableInt: $nullableInt, int: $int, nullableFloat: $nullableFloat, float: $float, nullableBoolean: $nullableBoolean, boolean: $boolean, nullableID: $nullableID, id: $id})  \\\\n}\\\\n\\";
  type t = {scalarsInput: string};
  type t_variables = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        scalarsInput: {
          let value = (value: Raw.t).scalarsInput;

          value;
        },
      }: t
    );
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"nullableString\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp.nullableString,
          ),
        ),
        (\\"string\\", (a => Some(Js.Json.string(a)))(inp.string)),
        (
          \\"nullableInt\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.number(float_of_int(a))))(b)
              }
          )(
            inp.nullableInt,
          ),
        ),
        (\\"int\\", (a => Some(Js.Json.number(float_of_int(a))))(inp.int)),
        (
          \\"nullableFloat\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.number(a)))(b)
              }
          )(
            inp.nullableFloat,
          ),
        ),
        (\\"float\\", (a => Some(Js.Json.number(a)))(inp.float)),
        (
          \\"nullableBoolean\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.boolean(a)))(b)
              }
          )(
            inp.nullableBoolean,
          ),
        ),
        (\\"boolean\\", (a => Some(Js.Json.boolean(a)))(inp.boolean)),
        (
          \\"nullableID\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp.nullableID,
          ),
        ),
        (\\"id\\", (a => Some(Js.Json.string(a)))(inp.id)),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar =
      (
        ~f,
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      ) =>
    f(
      serializeVariables(
        {

          nullableString,

          string,

          nullableInt,

          int,

          nullableFloat,

          float,

          nullableBoolean,

          boolean,

          nullableID,

          id,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Records scalarsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {scalarsInput: string};
  };
  let query = \\"query ($arg: VariousScalarsInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {scalarsInput: string};
  type t_variables = {arg: t_variables_VariousScalarsInput}
  and t_variables_VariousScalarsInput = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        scalarsInput: {
          let value = (value: Raw.t).scalarsInput;

          value;
        },
      }: t
    );
  let rec serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|
        (
          \\"arg\\",
          (a => Some(serializeInputObjectVariousScalarsInput(a)))(inp.arg),
        ),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_
  and serializeInputObjectVariousScalarsInput:
    t_variables_VariousScalarsInput => Js.Json.t =
    inp =>
      [|
        (
          \\"nullableString\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp.nullableString,
          ),
        ),
        (\\"string\\", (a => Some(Js.Json.string(a)))(inp.string)),
        (
          \\"nullableInt\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.number(float_of_int(a))))(b)
              }
          )(
            inp.nullableInt,
          ),
        ),
        (\\"int\\", (a => Some(Js.Json.number(float_of_int(a))))(inp.int)),
        (
          \\"nullableFloat\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.number(a)))(b)
              }
          )(
            inp.nullableFloat,
          ),
        ),
        (\\"float\\", (a => Some(Js.Json.number(a)))(inp.float)),
        (
          \\"nullableBoolean\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.boolean(a)))(b)
              }
          )(
            inp.nullableBoolean,
          ),
        ),
        (\\"boolean\\", (a => Some(Js.Json.boolean(a)))(inp.boolean)),
        (
          \\"nullableID\\",
          (
            a =>
              switch (a) {
              | None => None
              | Some(b) => (a => Some(Js.Json.string(a)))(b)
              }
          )(
            inp.nullableID,
          ),
        ),
        (\\"id\\", (a => Some(Js.Json.string(a)))(inp.id)),
      |]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~arg, ()) =>
    f(
      serializeVariables(
        {

          arg: arg,
        }: t_variables,
      ),
    )
  and makeInputObjectVariousScalarsInput =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      )
      : t_variables_VariousScalarsInput => {

    nullableString,

    string,

    nullableInt,

    int,

    nullableFloat,

    float,

    nullableBoolean,

    boolean,

    nullableID,

    id,
  };
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Records skipDirectives.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {
      v1: t_v1,
      v2: t_v2,
    }
    and t_v2 = {
      nullableString: Js.Nullable.t(string),
      string: Js.Nullable.t(string),
    }
    and t_v1 = {
      nullableString: Js.Nullable.t(string),
      string: Js.Nullable.t(string),
    };
  };
  let query = \\"query ($var: Boolean!)  {\\\\nv1: variousScalars  {\\\\nnullableString @skip(if: $var) \\\\nstring @skip(if: $var) \\\\n}\\\\n\\\\nv2: variousScalars  {\\\\nnullableString @include(if: $var) \\\\nstring @include(if: $var) \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {
    v1: t_v1,
    v2: t_v2,
  }
  and t_v2 = {
    nullableString: option(string),
    string: option(string),
  }
  and t_v1 = {
    nullableString: option(string),
    string: option(string),
  };
  type t_variables = {var: bool};
  let parse: Raw.t => t =
    (value) => (
      {

        v1: {
          let value = (value: Raw.t).v1;
          (
            {

              nullableString: {
                let value = (value: Raw.t_v1).nullableString;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              string: {
                let value = (value: Raw.t_v1).string;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
            }: t_v1
          );
        },

        v2: {
          let value = (value: Raw.t).v2;
          (
            {

              nullableString: {
                let value = (value: Raw.t_v2).nullableString;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              string: {
                let value = (value: Raw.t_v2).string;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
            }: t_v2
          );
        },
      }: t
    );
  let serializeVariables: t_variables => Js.Json.t =
    inp =>
      [|(\\"var\\", (a => Some(Js.Json.boolean(a)))(inp.var))|]
      |> Js.Array.filter(
           fun
           | (_, None) => false
           | (_, Some(_)) => true,
         )
      |> Js.Array.map(
           fun
           | (k, Some(v)) => (k, v)
           | (k, None) => (k, Js.Json.null),
         )
      |> Js.Dict.fromArray
      |> Js.Json.object_;
  let makeVar = (~f, ~var, ()) =>
    f(
      serializeVariables(
        {

          var: var,
        }: t_variables,
      ),
    );
  let definition = (parse, query, makeVar);
  let makeVariables = makeVar(~f=f => f);
};
"
`;

exports[`Records subscription.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {simpleSubscription: t_simpleSubscription}
    and t_simpleSubscription
    and t_simpleSubscription_Human = {name: string}
    and t_simpleSubscription_Dog = {name: string};
  };
  let query = \\"subscription   {\\\\nsimpleSubscription  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {simpleSubscription: t_simpleSubscription}
  and t_simpleSubscription = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_simpleSubscription_Dog)
    | \`Human(t_simpleSubscription_Human)
  ]
  and t_simpleSubscription_Human = {name: string}
  and t_simpleSubscription_Dog = {name: string};
  let parse: Raw.t => t =
    (value) => (
      {

        simpleSubscription: {
          let value = (value: Raw.t).simpleSubscription;

          switch (Js.Json.decodeObject(Obj.magic(value): Js.Json.t)) {

          | None =>
            Js.Exn.raiseError(
              \\"graphql_ppx: \\"
              ++ \\"Expected union \\"
              ++ \\"DogOrHuman\\"
              ++ \\" to be an object, got \\"
              ++ Js.Json.stringify(Obj.magic(value): Js.Json.t),
            )

          | Some(typename_obj) =>
            switch (Js.Dict.get(typename_obj, \\"__typename\\")) {

            | None =>
              Js.Exn.raiseError(
                \\"graphql_ppx: \\"
                ++ \\"Union \\"
                ++ \\"DogOrHuman\\"
                ++ \\" is missing the __typename field\\",
              )

            | Some(typename) =>
              switch (Js.Json.decodeString(typename)) {

              | None =>
                Js.Exn.raiseError(
                  \\"graphql_ppx: \\"
                  ++ \\"Union \\"
                  ++ \\"DogOrHuman\\"
                  ++ \\" has a __typename field that is not a string\\",
                )

              | Some(typename) =>
                switch (typename) {
                | \\"Dog\\" =>
                  \`Dog(
                    {
                      let value: Raw.t_simpleSubscription_Dog =
                        Obj.magic(value);
                      (
                        {

                          name: {
                            let value =
                              (value: Raw.t_simpleSubscription_Dog).name;

                            value;
                          },
                        }: t_simpleSubscription_Dog
                      );
                    },
                  )
                | \\"Human\\" =>
                  \`Human(
                    {
                      let value: Raw.t_simpleSubscription_Human =
                        Obj.magic(value);
                      (
                        {

                          name: {
                            let value =
                              (value: Raw.t_simpleSubscription_Human).name;

                            value;
                          },
                        }: t_simpleSubscription_Human
                      );
                    },
                  )
                | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
                }
              }
            }
          };
        },
      }: t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Records tagged_template.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {variousScalars: t_variousScalars}
    and t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {variousScalars: t_variousScalars}
  and t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {

              nullableString: {
                let value = (value: Raw.t_variousScalars).nullableString;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              string: {
                let value = (value: Raw.t_variousScalars).string;

                value;
              },

              nullableInt: {
                let value = (value: Raw.t_variousScalars).nullableInt;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              int: {
                let value = (value: Raw.t_variousScalars).int;

                value;
              },

              nullableFloat: {
                let value = (value: Raw.t_variousScalars).nullableFloat;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              float: {
                let value = (value: Raw.t_variousScalars).float;

                value;
              },

              nullableBoolean: {
                let value = (value: Raw.t_variousScalars).nullableBoolean;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              boolean: {
                let value = (value: Raw.t_variousScalars).boolean;

                value;
              },

              nullableID: {
                let value = (value: Raw.t_variousScalars).nullableID;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              id: {
                let value = (value: Raw.t_variousScalars).id;

                value;
              },
            }: t_variousScalars
          );
        },
      }: t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};

module MyQuery2 = {
  module Raw = {
    type t = {variousScalars: t_variousScalars}
    and t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
  };
  %raw
  \\"let { graphql } = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t = {variousScalars: t_variousScalars}
  and t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {

              nullableString: {
                let value = (value: Raw.t_variousScalars).nullableString;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              string: {
                let value = (value: Raw.t_variousScalars).string;

                value;
              },

              nullableInt: {
                let value = (value: Raw.t_variousScalars).nullableInt;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              int: {
                let value = (value: Raw.t_variousScalars).int;

                value;
              },

              nullableFloat: {
                let value = (value: Raw.t_variousScalars).nullableFloat;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              float: {
                let value = (value: Raw.t_variousScalars).float;

                value;
              },

              nullableBoolean: {
                let value = (value: Raw.t_variousScalars).nullableBoolean;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              boolean: {
                let value = (value: Raw.t_variousScalars).boolean;

                value;
              },

              nullableID: {
                let value = (value: Raw.t_variousScalars).nullableID;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              id: {
                let value = (value: Raw.t_variousScalars).id;

                value;
              },
            }: t_variousScalars
          );
        },
      }: t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};

module MyQuery3 = {
  module Raw = {
    type t = {variousScalars: t_variousScalars}
    and t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
  };
  %raw
  \\"let { graphql } = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t = {variousScalars: t_variousScalars}
  and t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {

              nullableString: {
                let value = (value: Raw.t_variousScalars).nullableString;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              string: {
                let value = (value: Raw.t_variousScalars).string;

                value;
              },

              nullableInt: {
                let value = (value: Raw.t_variousScalars).nullableInt;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              int: {
                let value = (value: Raw.t_variousScalars).int;

                value;
              },

              nullableFloat: {
                let value = (value: Raw.t_variousScalars).nullableFloat;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              float: {
                let value = (value: Raw.t_variousScalars).float;

                value;
              },

              nullableBoolean: {
                let value = (value: Raw.t_variousScalars).nullableBoolean;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              boolean: {
                let value = (value: Raw.t_variousScalars).boolean;

                value;
              },

              nullableID: {
                let value = (value: Raw.t_variousScalars).nullableID;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              id: {
                let value = (value: Raw.t_variousScalars).id;

                value;
              },
            }: t_variousScalars
          );
        },
      }: t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};

module MyQuery4 = {
  module Raw = {
    type t = {variousScalars: t_variousScalars}
    and t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
  };
  %raw
  \\"let graphql = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t = {variousScalars: t_variousScalars}
  and t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        variousScalars: {
          let value = (value: Raw.t).variousScalars;
          (
            {

              nullableString: {
                let value = (value: Raw.t_variousScalars).nullableString;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              string: {
                let value = (value: Raw.t_variousScalars).string;

                value;
              },

              nullableInt: {
                let value = (value: Raw.t_variousScalars).nullableInt;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              int: {
                let value = (value: Raw.t_variousScalars).int;

                value;
              },

              nullableFloat: {
                let value = (value: Raw.t_variousScalars).nullableFloat;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              float: {
                let value = (value: Raw.t_variousScalars).float;

                value;
              },

              nullableBoolean: {
                let value = (value: Raw.t_variousScalars).nullableBoolean;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              boolean: {
                let value = (value: Raw.t_variousScalars).boolean;

                value;
              },

              nullableID: {
                let value = (value: Raw.t_variousScalars).nullableID;

                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },

              id: {
                let value = (value: Raw.t_variousScalars).id;

                value;
              },
            }: t_variousScalars
          );
        },
      }: t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Records typename.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {first: t_first}
    and t_first = {
      __typename: string,
      inner: Js.Nullable.t(t_first_inner),
    }
    and t_first_inner = {
      __typename: string,
      inner: Js.Nullable.t(t_first_inner_inner),
    }
    and t_first_inner_inner = {
      __typename: string,
      field: string,
    };
  };
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {first: t_first}
  and t_first = {
    __typename: string,
    inner: option(t_first_inner),
  }
  and t_first_inner = {
    __typename: string,
    inner: option(t_first_inner_inner),
  }
  and t_first_inner_inner = {
    __typename: string,
    field: string,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        first: {
          let value = (value: Raw.t).first;
          (
            {

              __typename: {
                let value = (value: Raw.t_first).__typename;

                value;
              },

              inner: {
                let value = (value: Raw.t_first).inner;

                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {

                      __typename: {
                        let value = (value: Raw.t_first_inner).__typename;

                        value;
                      },

                      inner: {
                        let value = (value: Raw.t_first_inner).inner;

                        switch (Js.toOption(value)) {
                        | Some(value) =>
                          Some(
                            {

                              __typename: {
                                let value =
                                  (value: Raw.t_first_inner_inner).__typename;

                                value;
                              },

                              field: {
                                let value =
                                  (value: Raw.t_first_inner_inner).field;

                                value;
                              },
                            }: t_first_inner_inner,
                          )
                        | None => None
                        };
                      },
                    }: t_first_inner,
                  )
                | None => None
                };
              },
            }: t_first
          );
        },
      }: t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Records union.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {dogOrHuman: t_dogOrHuman}
    and t_dogOrHuman
    and t_dogOrHuman_Human = {name: string}
    and t_dogOrHuman_Dog = {
      name: string,
      barkVolume: float,
    };
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {dogOrHuman: t_dogOrHuman}
  and t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ]
  and t_dogOrHuman_Human = {name: string}
  and t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        dogOrHuman: {
          let value = (value: Raw.t).dogOrHuman;

          switch (Js.Json.decodeObject(Obj.magic(value): Js.Json.t)) {

          | None =>
            Js.Exn.raiseError(
              \\"graphql_ppx: \\"
              ++ \\"Expected union \\"
              ++ \\"DogOrHuman\\"
              ++ \\" to be an object, got \\"
              ++ Js.Json.stringify(Obj.magic(value): Js.Json.t),
            )

          | Some(typename_obj) =>
            switch (Js.Dict.get(typename_obj, \\"__typename\\")) {

            | None =>
              Js.Exn.raiseError(
                \\"graphql_ppx: \\"
                ++ \\"Union \\"
                ++ \\"DogOrHuman\\"
                ++ \\" is missing the __typename field\\",
              )

            | Some(typename) =>
              switch (Js.Json.decodeString(typename)) {

              | None =>
                Js.Exn.raiseError(
                  \\"graphql_ppx: \\"
                  ++ \\"Union \\"
                  ++ \\"DogOrHuman\\"
                  ++ \\" has a __typename field that is not a string\\",
                )

              | Some(typename) =>
                switch (typename) {
                | \\"Dog\\" =>
                  \`Dog(
                    {
                      let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                      (
                        {

                          name: {
                            let value = (value: Raw.t_dogOrHuman_Dog).name;

                            value;
                          },

                          barkVolume: {
                            let value =
                              (value: Raw.t_dogOrHuman_Dog).barkVolume;

                            value;
                          },
                        }: t_dogOrHuman_Dog
                      );
                    },
                  )
                | \\"Human\\" =>
                  \`Human(
                    {
                      let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                      (
                        {

                          name: {
                            let value = (value: Raw.t_dogOrHuman_Human).name;

                            value;
                          },
                        }: t_dogOrHuman_Human
                      );
                    },
                  )
                | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
                }
              }
            }
          };
        },
      }: t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;

exports[`Records unionPartial.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {dogOrHuman: t_dogOrHuman}
    and t_dogOrHuman
    and t_dogOrHuman_Dog = {
      name: string,
      barkVolume: float,
    };
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {dogOrHuman: t_dogOrHuman}
  and t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ]
  and t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  let parse: Raw.t => t =
    (value) => (
      {

        dogOrHuman: {
          let value = (value: Raw.t).dogOrHuman;

          switch (Js.Json.decodeObject(Obj.magic(value): Js.Json.t)) {

          | None =>
            Js.Exn.raiseError(
              \\"graphql_ppx: \\"
              ++ \\"Expected union \\"
              ++ \\"DogOrHuman\\"
              ++ \\" to be an object, got \\"
              ++ Js.Json.stringify(Obj.magic(value): Js.Json.t),
            )

          | Some(typename_obj) =>
            switch (Js.Dict.get(typename_obj, \\"__typename\\")) {

            | None =>
              Js.Exn.raiseError(
                \\"graphql_ppx: \\"
                ++ \\"Union \\"
                ++ \\"DogOrHuman\\"
                ++ \\" is missing the __typename field\\",
              )

            | Some(typename) =>
              switch (Js.Json.decodeString(typename)) {

              | None =>
                Js.Exn.raiseError(
                  \\"graphql_ppx: \\"
                  ++ \\"Union \\"
                  ++ \\"DogOrHuman\\"
                  ++ \\" has a __typename field that is not a string\\",
                )

              | Some(typename) =>
                switch (typename) {
                | \\"Dog\\" =>
                  \`Dog(
                    {
                      let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                      (
                        {

                          name: {
                            let value = (value: Raw.t_dogOrHuman_Dog).name;

                            value;
                          },

                          barkVolume: {
                            let value =
                              (value: Raw.t_dogOrHuman_Dog).barkVolume;

                            value;
                          },
                        }: t_dogOrHuman_Dog
                      );
                    },
                  )
                | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
                }
              }
            }
          };
        },
      }: t
    );
  let makeVar = (~f, ()) => f(Js.Json.null);
  let definition = (parse, query, makeVar);
};
"
`;
